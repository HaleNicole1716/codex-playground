<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>现券交易指令管理系统 - 离线版</title>
    <style>
        :root {
            --primary: #1976d2;
            --primary-dark: #115293;
            --primary-light: #4fc3f7;
            --success: #4caf50;
            --warning: #ff9800;
            --danger: #f44336;
            --info: #2196f3;
            --bg-primary: #f5f5f5;
            --bg-secondary: #ffffff;
            --text-primary: #212121;
            --text-secondary: #757575;
            --border: #e0e0e0;
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.12);
            --shadow-md: 0 4px 6px rgba(0,0,0,0.16);
            --shadow-lg: 0 10px 20px rgba(0,0,0,0.19);
        }

        /* 撤销快照与自动匹配分配（说明：功能代码已在<script>中，避免在<style>中混放JS）
        function snapshotForUndo() {
            const data = AppState.unifiedData || {};
            data._undo = {
                deals: (data.deals||[]).map(d=>({ id: d.dealId, fillWan: d.fillWan||0, state: d.state||'unfilled' })),
                quotes: (data.quotes||[]).map(q=>({ id: q.quoteId, filledWan: q.filledWan||0, completed: !!q.completed, fills: JSON.parse(JSON.stringify(q.fills||[])) })),
                links: (data.links||[]).map(l=>({ id: l.linkId, confirmed: !!l.confirmed, fillWan: l.fillWan||0 }))
            };
        }

        function undoAutoMatch() {
            const data = AppState.unifiedData || {};
            const u = data._undo;
            if (!u) { showToast('无可回撤记录', 'warning'); return; }
            const dMap = new Map((data.deals||[]).map(x=>[x.dealId,x]));
            const qMap = new Map((data.quotes||[]).map(x=>[x.quoteId,x]));
            const lMap = new Map((data.links||[]).map(x=>[x.linkId,x]));
            (u.deals||[]).forEach(s => { const d=dMap.get(s.id); if(d){ d.fillWan=s.fillWan; d.state=s.state; } });
            (u.quotes||[]).forEach(s => { const q=qMap.get(s.id); if(q){ q.filledWan=s.filledWan; q.completed=s.completed; q.fills = s.fills||[]; } });
            (u.links||[]).forEach(s => { const l=lMap.get(s.id); if(l){ l.confirmed=s.confirmed; l.fillWan=s.fillWan; } });
            delete data._undo;
            DataStorage.saveAppState();
            renderUnifiedBoard();
            showToast('已撤销上一步', 'success');
        }

        // 统一模式：自动匹配预览与手动匹配（全局可调用）
        const UnifiedIntent = { nextAction: null }; // 'auto' | 'manual' | null
        function openAutoMatchPreview(){
            const data = AppState.unifiedData || {};
            const deals  = data.deals  || [];
            const quotes = data.quotes || [];
            const doneText  = (document.getElementById('unifiedDoneInput') && document.getElementById('unifiedDoneInput').value || '').trim();
            const quoteText = (document.getElementById('unifiedQuoteInput') && document.getElementById('unifiedQuoteInput').value || '').trim();
            const prefs = data.prefs || (data.prefs = {});

            if (!deals.length && doneText)  { try { parseUnifiedDone();  } catch(e){} }
            if (!quotes.length && quoteText){ try { parseUnifiedQuote(); } catch(e){} }

            if (prefs.previewBeforeMerge && ((!deals.length && doneText) || (!quotes.length && quoteText))) {
                window.UnifiedIntent = window.UnifiedIntent || { nextAction: null };
                window.UnifiedIntent.nextAction = 'auto';
                showToast('已打开解析确认窗口，请先“确认并导入”，系统将自动回到“自动匹配（预览）”', 'info');
                return;
            }

            try { if (typeof MatchEngine !== 'undefined') MatchEngine.run(); } catch(e){}
            openBatchLinkPickerModal();
            batchPickTop1();
        }

        function openManualMatchWizard() {
            const data = AppState.unifiedData || {};
            const deals  = data.deals  || [];
            const quotes = data.quotes || [];

            const doneText  = (document.getElementById('unifiedDoneInput') && document.getElementById('unifiedDoneInput').value || '').trim();
            const quoteText = (document.getElementById('unifiedQuoteInput') && document.getElementById('unifiedQuoteInput').value || '').trim();
            const prefs = data.prefs || (data.prefs = {});

            if (!deals.length && doneText)  { try { parseUnifiedDone();  } catch(e){} }
            if (!quotes.length && quoteText){ try { parseUnifiedQuote(); } catch(e){} }

            if (prefs.previewBeforeMerge && ((!deals.length && doneText) || (!quotes.length && quoteText))) {
                window.UnifiedIntent = window.UnifiedIntent || { nextAction: null };
                window.UnifiedIntent.nextAction = 'manual';
                showToast('已打开解析确认窗口，请先“确认并导入”，系统将自动回到“手动匹配”', 'info');
                return;
            }

            const dNow = (AppState.unifiedData.deals||[]);
            const qNow = (AppState.unifiedData.quotes||[]);
            if (!qNow.length) {
                if (!dNow.length) { showToast('请先输入 DONE 或 报价文本', 'warning'); return; }
                const firstUnmatched = dNow.find(d => (d.state||'unfilled') === 'unfilled');
                const first = firstUnmatched || dNow[0];
                openLinkPickerModal(first.raw && first.raw.指令ID || first.dealId);
                return;
            }

            try { if (typeof MatchEngine !== 'undefined') MatchEngine.run(); } catch(e){}
            openBatchLinkPickerModal();
            batchPickTop1();
        }



        function autoMatchAndAllocate() {
            try { if (typeof MatchEngine !== 'undefined') MatchEngine.run(); } catch(e){}
            const data = AppState.unifiedData || {};
            const { deals=[], quotes=[], links=[] } = data;
            if (!deals.length || !quotes.length) { showToast('请先解析 DONE 与 报价文本', 'warning'); return; }

            snapshotForUndo();

            deals.forEach(d => { d.fillWan = d.fillWan||0; });
            quotes.forEach(q => { q.filledWan = q.filledWan||0; q.fills = q.fills||[]; });

            const linksByDeal = (links||[]).reduce((m,l)=>{ 
                if (!m[l.dealId]) m[l.dealId] = [];
                m[l.dealId].push(l); 
                return m; 
            }, {});
            Object.values(linksByDeal).forEach(arr => arr.sort((a,b)=>(b.score||0)-(a.score||0)));

            const sortedDeals = [...deals].sort((a,b)=>{ const ax = a.bondKey ? 0 : 1, bx = b.bondKey ? 0 : 1; return ax - bx; });

            for (const d of sortedDeals) {
                const need = (d.volumeWan||0) - (d.fillWan||0);
                if (need <= 0) { d.state = 'filled'; continue; }
                const cands = linksByDeal[d.dealId] || [];
                let left = need;
                for (const l of cands) {
                    const q = quotes.find(x=>x.quoteId===l.quoteId);
                    if (!q) continue;
                    const qRemain = (q.volumeWan||0) - (q.filledWan||0);
                    if (qRemain <= 0) continue;
                    const alloc = Math.min(left, qRemain);
                    if (alloc <= 0) continue;
                    l.confirmed = true;
                    l.auto = true;
                    l.fillWan = (l.fillWan||0) + alloc;
                    d.fillWan = (d.fillWan||0) + alloc;
                    q.filledWan = (q.filledWan||0) + alloc;
                    if (!q.fills) q.fills = [];
                    q.fills.push({ linkId: l.linkId, dealId: d.dealId, fillWan: alloc, at: Date.now() });
                    left -= alloc;
                    if (left <= 0) break;
                }
                d.state = left <= 0 ? 'filled' : (d.fillWan > 0 ? 'partial' : 'unfilled');
            }

            quotes.forEach(q => { q.completed = (q.filledWan||0) >= (q.volumeWan||0) - 1e-6; });

            data.stats.totalDeals = deals.length;
            data.stats.matchedDeals = deals.filter(d => d.state !== 'unfilled').length;
            data.stats.coverage = deals.length ? Math.round(100 * data.stats.matchedDeals / deals.length) : 0;
            data.stats.totalQuotes = quotes.length;
            data.stats.completedQuotes = quotes.filter(q => q.completed).length;
            data.stats.completionRate = quotes.length ? Math.round(100 * data.stats.completedQuotes / quotes.length) : 0;
            data.stats.totalQuoteWan = quotes.reduce((s,q)=> s + (q.volumeWan||0), 0);
            data.stats.filledQuoteWan = quotes.reduce((s,q)=> s + (q.filledWan||0), 0);
            data.stats.remainingQuoteWan = (data.stats.totalQuoteWan||0) - (data.stats.filledQuoteWan||0);

            DataStorage.saveAppState();
            renderUnifiedBoard();
            showToast('自动匹配完成', 'success');
        }

        function clearQuoteAlloc(quoteId) {
            const data = AppState.unifiedData || {};
            const q = (data.quotes||[]).find(x=>x.quoteId===quoteId);
            if (!q) return;
            const links = data.links||[];
            (q.fills||[]).forEach(f=>{
                const l = links.find(x=>x.linkId===f.linkId);
                const d = (data.deals||[]).find(x=>x.dealId===f.dealId);
                if (l) l.fillWan = Math.max(0, (l.fillWan||0) - (f.fillWan||0));
                if (d) d.fillWan = Math.max(0, (d.fillWan||0) - (f.fillWan||0));
            });
            q.fills = [];
            q.filledWan = 0;
            q.completed = false;
            (data.deals||[]).forEach(d=>{
                const remain = (d.volumeWan||0) - (d.fillWan||0);
                d.state = remain<=0 ? 'filled' : (d.fillWan>0 ? 'partial' : 'unfilled');
            });
            DataStorage.saveAppState();
            renderUnifiedBoard();
            showToast('已清除该报价分配', 'success');
        }

        function renderQuoteProgress() {
            const data = AppState.unifiedData || {};
            const { deals=[], quotes=[], links=[] } = data;
            const linksByQuote = links.filter(l=>l.confirmed).reduce((m,l)=>{ 
                if (!m[l.quoteId]) m[l.quoteId] = [];
                m[l.quoteId].push(l); 
                return m; 
            }, {});
            let list = quotes.slice();
            if (UnifiedViewState.quoteDone) list = list.filter(q=>q.completed);
            const rows = list.map(q=>{
                const prog = (q.volumeWan>0) ? Math.min(100, Math.round(100*(q.filledWan||0)/q.volumeWan)) : 0;
                const dn = (linksByQuote[q.quoteId]||[]).length;
                const bar = `
      <div style="height:10px;background:#eee;border-radius:4px;overflow:hidden;">
        <div style="height:100%;width:${prog}%;background:#4caf50;"></div>
      </div>`;
                return `
      <tr>
        <td>${q.code||'-'}</td>
        <td>${q.name||'-'}</td>
        <td>${q.side||'-'}</td>
        <td>${q.volumeWan||'-'}</td>
        <td>${q.filledWan||0}</td>
        <td>${(q.volumeWan||0)-(q.filledWan||0)}</td>
        <td style="min-width:140px;">${bar} <div style="font-size:12px;color:#666;text-align:right;">${prog}%</div></td>
        <td>${dn}</td>
        <td>${q.manager||'-'}</td>
        <td style="text-align:center;">
          <button class="btn btn-sm" onclick="openEditFromUnified('quote','${q.quoteId}')">编辑</button>
          <button class="btn btn-sm" onclick="clearQuoteAlloc('${q.quoteId}')">重置进度</button>
        </td>
      </tr>`;
            }).join('');
            const html = `
    <h4 style="margin:12px 0 6px;">报价成交进度</h4>
    <table class="orders-table" style="width:100%; background:white; border-radius:8px;">
      <thead><tr>
        <th>债券代码</th><th>债券名称</th><th>边</th>
        <th>报价量(万)</th><th>已成交(万)</th><th>剩余(万)</th>
        <th>进度</th><th>关联DONE</th><th>投资经理</th><th>操作</th>
      </tr></thead>
      <tbody>${rows || ''}</tbody>
    </table>`;
            const el = document.getElementById('quoteProgressTable'); if (el) el.innerHTML = html;
        }
        */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Microsoft YaHei', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
        }

        /* 模式选择界面 */
        .mode-selector {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .mode-container {
            background: white;
            border-radius: 20px;
            padding: 60px;
            box-shadow: var(--shadow-lg);
            max-width: 600px;
            width: 90%;
            text-align: center;
        }

        .mode-container h1 {
            color: var(--text-primary);
            margin-bottom: 20px;
            font-size: 32px;
        }

        .mode-container p {
            color: var(--text-secondary);
            margin-bottom: 40px;
            font-size: 16px;
        }

        .mode-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
        }

        .mode-btn {
            padding: 20px 40px;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            color: white;
            flex: 1;
            max-width: 200px;
        }

        .mode-btn.standard {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .mode-btn.enhanced {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .mode-btn:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow-md);
        }

        /* 主应用容器 */
        .app-container {
            display: none;
            min-height: 100vh;
        }

        /* 标准版界面 */
        .standard-app {
            display: none;
            padding: 40px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .standard-header {
            background: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: var(--shadow-sm);
        }

        .standard-header h2 {
            color: var(--primary);
            margin-bottom: 20px;
        }

        .input-section {
            background: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: var(--shadow-sm);
        }

        .input-section h3 {
            margin-bottom: 20px;
            color: var(--text-primary);
        }

        .trader-input {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--border);
            border-radius: 8px;
            font-size: 16px;
            margin-bottom: 20px;
        }

        .text-input {
            width: 100%;
            min-height: 200px;
            padding: 15px;
            border: 2px solid var(--border);
            border-radius: 8px;
            font-size: 14px;
            font-family: 'Consolas', 'Monaco', monospace;
            resize: vertical;
        }

        .button-group {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-secondary {
            background: var(--text-secondary);
            color: white;
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn:hover {
            opacity: 0.9;
            transform: translateY(-2px);
        }

        /* 拆单按钮样式 */
        .split-ratio-btn {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #fff;
            color: #333;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
            text-align: center;
        }

        .split-ratio-btn:hover {
            background: #f8f9fa;
            border-color: #3498db;
            color: #3498db;
        }

        .split-ratio-btn.active {
            background: #3498db;
            border-color: #3498db;
            color: white;
        }

        /* 指令选择项样式 */
        .order-select-item {
            padding: 10px;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            margin-bottom: 8px;
            background: #fff;
            transition: all 0.2s;
            cursor: pointer;
        }

        .order-select-item:hover {
            background: #f8f9fa;
            border-color: #3498db;
        }

        .order-select-item.selected {
            background: #e3f2fd;
            border-color: #2196f3;
        }

        /* 扩展版界面 */
        .enhanced-app {
            display: none;
            height: 100vh;
        }

        .sidebar {
            width: 280px;
            background: #2c3e50;
            color: white;
            padding: 20px;
            overflow-y: auto;
        }

        .sidebar h3 {
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }

        .manager-list {
            list-style: none;
        }

        .manager-item {
            margin-bottom: 10px;
        }

        .manager-header {
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .manager-header:hover {
            background: rgba(255,255,255,0.2);
        }

        .order-list {
            list-style: none;
            padding-left: 15px;
            margin-top: 10px;
            display: none;
        }

        .order-list.expanded {
            display: block;
        }

        .order-item {
            padding: 8px;
            margin: 5px 0;
            background: rgba(255,255,255,0.05);
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .order-item:hover {
            background: rgba(255,255,255,0.15);
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .top-bar {
            background: white;
            padding: 20px;
            box-shadow: var(--shadow-sm);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .top-bar h2 {
            color: var(--primary);
        }

        .toolbar {
            display: flex;
            gap: 10px;
        }

        .content-area {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
        }

        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: var(--shadow-sm);
        }

        .stat-card h4 {
            color: var(--text-secondary);
            font-size: 14px;
            margin-bottom: 10px;
        }

        .stat-value {
            font-size: 32px;
            font-weight: bold;
            color: var(--primary);
        }

        .stat-unit {
            font-size: 14px;
            color: var(--text-secondary);
            margin-left: 5px;
        }

        .order-detail {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: var(--shadow-sm);
            margin-bottom: 20px;
        }

        .order-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border);
            margin-bottom: 20px;
        }

        .order-info {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .bond-code {
            font-weight: bold;
            color: var(--primary);
        }

        .bond-name {
            color: var(--text-primary);
        }

        .direction {
            padding: 4px 12px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 12px;
        }

        .direction.buy {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .direction.sell {
            background: #ffebee;
            color: #c62828;
        }

        .progress-container {
            margin: 20px 0;
        }

        .progress-bar {
            height: 30px;
            background: var(--bg-primary);
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #8bc34a);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .split-table {
            width: 100%;
            margin-top: 20px;
        }

        .split-table table {
            width: 100%;
            border-collapse: collapse;
        }

        .split-table th,
        .split-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .split-table th {
            background: var(--bg-primary);
            font-weight: 600;
            color: var(--text-secondary);
        }

        .split-table tr:hover {
            background: #f9f9f9;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
        }

        .status-badge.pending {
            background: #e3f2fd;
            color: #1976d2;
        }

        .status-badge.executing {
            background: #fff3e0;
            color: #f57c00;
        }

        .status-badge.completed {
            background: #e8f5e9;
            color: #388e3c;
        }

        /* 模态框 */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 2001;
            justify-content: center;
            align-items: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 2002;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-header h3 {
            color: var(--primary);
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-secondary);
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .form-control {
            width: 100%;
            padding: 10px;
            border: 2px solid var(--border);
            border-radius: 5px;
            font-size: 14px;
        }

        .form-control:focus {
            outline: none;
            border-color: var(--primary);
        }

        /* 响应式设计 */
        @media (max-width: 768px) {
            .enhanced-app {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                height: auto;
            }

            .dashboard {
                grid-template-columns: 1fr;
            }
        }

        /* 加载动画 */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0,0,0,.1);
            border-radius: 50%;
            border-top-color: var(--primary);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* 提示信息 */
        .toast {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: #333;
            color: white;
            padding: 15px 25px;
            border-radius: 5px;
            box-shadow: var(--shadow-md);
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
            z-index: 2000;
        }

        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }

        .toast.success {
            background: var(--success);
        }

        .toast.error {
            background: var(--danger);
        }

        .toast.info {
            background: var(--info);
        }

        .toast.warning {
            background: #ffc107;
            color: #212529;
        }
        /* === 统一预览表视觉修正 === */
        .orders-table {
            table-layout: fixed;
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
        }
        .orders-table th, .orders-table td {
            padding: 8px 10px;
            text-align: center;
            vertical-align: middle;
        }
        .orders-table th {
            background: #f8f9fa;
            font-weight: 600;
        }
        .orders-table thead th {
            position: sticky;
            top: 0;
            z-index: 2;
        }
        /* 数量/收益率/交易日不换行（考虑到首列加入选择框，索引为5/6/7） */
        .orders-table td:nth-child(5),
        .orders-table td:nth-child(6),
        .orders-table td:nth-child(7) {
            white-space: nowrap;
        }
        input[type="checkbox"]{ width:14px; height:14px; accent-color:#1677ff; }
        .stat-card {
            background:#f8f9fa;
            padding:12px;
            border-radius:8px;
            cursor:pointer;
            user-select:none;
            transition:transform .05s ease;
        }
        .stat-card:active { transform:scale(0.98); }
        .stat-card.disabled { cursor:default; opacity:.7; }
        .s-label { font-size:12px; color:#666; }
        .s-value { font-weight:700; font-size:22px; }
        .progress-bar { height:10px; background:#eee; border-radius:4px; overflow:hidden; }
        .progress-bar > .fill { height:100%; background:#4caf50; }

        /* 统一模式顶栏 */
        .topbar{
            position: sticky; top: 0;
            display: flex; align-items: center; gap: 8px;
            background: var(--bg-secondary); padding: 8px 12px;
            border-bottom: 1px solid var(--border);
            z-index: 1000;
        }
        .topbar .spacer{ flex: 1; }
        .topbar .btn{ margin-left: 8px; }
    </style>
</head>
<body>
    <!-- 模式选择界面 -->
    <div id="modeSelector" class="mode-selector">
        <div class="mode-container">
            <h1>现券交易管理系统</h1>
            <p>请选择使用模式</p>
            <div class="mode-buttons">
                <button class="mode-btn standard" onclick="selectMode('standard')">
                    标准版<br>
                    <small style="font-size: 12px; opacity: 0.9;">债券解析器</small>
                </button>
                <button class="mode-btn enhanced" onclick="selectMode('enhanced')">
                    扩展版<br>
                    <small style="font-size: 12px; opacity: 0.9;">指令管理系统</small>
                </button>
                <button class="mode-btn" style="background: #6c757d;" onclick="selectMode('unified')">
                    统一模式<br>
                    <small style="font-size: 12px; opacity: 0.9;">DONE×报价看板</small>
                </button>
            </div>
        </div>
    </div>

    <!-- Modal dialogs moved outside modeSelector for unified mode visibility -->
    <!-- 匹配选择弹窗 -->
    <div id="linkPickerModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>匹配预览与选择</h3>
                <button class="close-btn" onclick="closeModal('linkPickerModal')">&times;</button>
            </div>
            <div id="linkPickerBody" style="max-height:60vh;overflow:auto;"></div>
            <div class="button-group" style="margin-top: 12px;">
                <button class="btn btn-primary" onclick="confirmLinkSelection()">确认选择</button>
                <button class="btn btn-secondary" onclick="closeModal('linkPickerModal')">取消</button>
            </div>
        </div>
    </div>

    <!-- 手动录入报价弹窗 -->
    <div id="manualQuoteModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>手动录入报价</h3>
                <button class="close-btn" onclick="closeModal('manualQuoteModal')">&times;</button>
            </div>
            <div class="form-group"><label>债券代码</label><input id="mq_code" class="form-control"></div>
            <div class="form-group"><label>债券名称</label><input id="mq_name" class="form-control"></div>
            <div class="form-group"><label>边(Bid/Ofr/买入/卖出)</label><input id="mq_side" class="form-control"></div>
            <div class="form-group"><label>收益率(%)</label><input id="mq_yield" type="number" step="0.0001" class="form-control"></div>
            <div class="form-group"><label>数量(万)</label><input id="mq_vol" type="number" step="0.01" class="form-control"></div>
            <div class="form-group"><label>投资经理</label><input id="mq_manager" class="form-control" placeholder="留空则使用默认经理"></div>
            <div class="button-group" style="margin-top:12px;">
                <button class="btn btn-primary" onclick="saveManualQuote()">保存并绑定</button>
                <button class="btn btn-secondary" onclick="closeModal('manualQuoteModal')">取消</button>
            </div>
        </div>
    </div>

    <!-- 批量匹配选择弹窗 -->
    <div id="batchLinkPickerModal" class="modal">
        <div class="modal-content" style="max-width:1100px;">
            <div class="modal-header">
                <h3>批量匹配预览与选择</h3>
                <button class="close-btn" onclick="closeModal('batchLinkPickerModal')">&times;</button>
            </div>

            <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px; flex-wrap:wrap;">
                <button class="btn btn-sm" onclick="batchPickTop1()">一键选择Top1</button>
                <button class="btn btn-sm" onclick="batchClearSelections()">清空选择</button>
                <input id="batchPickSearch" class="form-control" style="height:32px; width:220px;" placeholder="按代码/名称搜索" oninput="renderBatchLinkPickerContent()">
                <label><input id="batchOnlyNoCandidate" type="checkbox" onchange="renderBatchLinkPickerContent()"> 仅看无候选</label>
                <label><input id="batchOnlyUnconfirmed" type="checkbox" checked onchange="renderBatchLinkPickerContent()"> 仅看待确认</label>
            </div>

            <div id="batchLinkPickerBody" style="max-height:60vh; overflow:auto;"></div>

            <div class="button-group" style="margin-top:12px; display:flex; gap:8px; flex-wrap:wrap;">
                <button class="btn btn-primary" onclick="confirmBatchLinkSelections()">确认并生成匹配</button>
                <button class="btn btn-success" onclick="applyBatchSelectionsAndAllocate()">应用所选（落地）</button>
                <button class="btn btn-secondary" onclick="closeModal('batchLinkPickerModal')">取消</button>
            </div>
        </div>
    </div>

    <!-- 标准版应用 -->
    <div id="standardApp" class="app-container standard-app">
        <div class="standard-header">
            <h2>债券交易记录解析器 - 标准版</h2>
            <p>支持批量解析债券交易记录，自动识别交易要素</p>
        </div>

        <div class="input-section">
            <h3>交易员信息</h3>
            <input type="text" class="trader-input" id="traderName" placeholder="请输入交易员姓名（可选）">
        </div>

        <div class="input-section">
            <h3>交易记录输入</h3>
            <textarea class="text-input" id="standardInput" placeholder="请粘贴交易记录文本，每行一条记录...

示例：
21国开05 bid 1.84 2000万
240737.SH 24株国05 2.0 bid 2000
102400608.IB 24晋城国资MTN001 1.89 bid 1kw"></textarea>
            
            <div class="button-group">
                <button class="btn btn-primary" onclick="parseStandard()">开始解析</button>
                <button class="btn btn-secondary" onclick="loadSampleData()">加载示例</button>
                <button class="btn btn-secondary" onclick="clearStandard()">清空</button>
                <button class="btn btn-danger" onclick="returnToModeSelector()">返回选择</button>
            </div>
        </div>

        <div id="standardResults" style="display:none;">
            <div class="input-section">
                <h3>解析结果</h3>
                <div id="standardResultsContent"></div>
                <div class="button-group">
                    <button class="btn btn-success" onclick="exportStandardExcel()">导出Excel</button>
                    <button class="btn btn-primary" onclick="exportStandardCSV()">导出CSV</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 扩展版应用 -->
    <div id="enhancedApp" class="app-container enhanced-app">
        <!-- 左侧边栏 -->
        <div class="sidebar">
            <h3>投资经理</h3>
            <div class="button-group" style="margin-bottom: 20px;">
                <button class="btn btn-primary" style="width: 100%;" onclick="showImportModal()">导入指令</button>
            </div>
            
            <!-- 批量操作工具栏 -->
            <div id="enhancedBatchTools" style="margin-bottom: 15px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px; display: none;">
                <div style="margin-bottom: 8px; font-size: 12px; font-weight: bold; color: #ecf0f1;">批量操作</div>
                <div style="display: flex; flex-direction: column; gap: 5px;">
                    <div style="display: flex; gap: 5px;">
                        <button class="btn btn-sm" style="flex: 1; padding: 4px 8px; font-size: 11px; background: #3498db;" onclick="selectAllEnhancedOrders()">全选</button>
                        <button class="btn btn-sm" style="flex: 1; padding: 4px 8px; font-size: 11px; background: #7f8c8d;" onclick="deselectAllEnhancedOrders()">清空</button>
                    </div>
                    <button class="btn btn-sm" style="width: 100%; padding: 4px 8px; font-size: 11px; background: #e74c3c;" onclick="batchDeleteEnhancedOrders()">批量删除</button>
                    <div id="enhancedSelectedCount" style="font-size: 10px; color: #bdc3c7; text-align: center; margin-top: 5px;">已选择: 0 项</div>
                </div>
            </div>
            
            <ul class="manager-list" id="managerList">
                <!-- 动态生成 -->
            </ul>
        </div>

        <!-- 主内容区 -->
        <div class="main-content">
            <div class="top-bar">
                <h2>交易指令管理系统</h2>
                <div class="toolbar">
                    <button class="btn btn-primary" onclick="showAddOrderModal()">新增指令</button>
                    <button class="btn btn-info" onclick="showBatchProgressModal()">批量进度</button>
                    <button class="btn btn-success" onclick="exportReport()">生成报告</button>
                    <button class="btn btn-danger" onclick="returnToModeSelector()">返回</button>
                </div>
            </div>

            <div class="content-area">
                <!-- 统计仪表板 -->
                <div class="dashboard">
                    <div class="stat-card">
                        <h4>总指令数</h4>
                        <div><span class="stat-value" id="totalOrders">0</span><span class="stat-unit">条</span></div>
                    </div>
                    <div class="stat-card">
                        <h4>执行中</h4>
                        <div><span class="stat-value" id="executingOrders">0</span><span class="stat-unit">条</span></div>
                    </div>
                    <div class="stat-card">
                        <h4>已完成</h4>
                        <div><span class="stat-value" id="completedOrders">0</span><span class="stat-unit">条</span></div>
                    </div>
                    <div class="stat-card">
                        <h4>总进度</h4>
                        <div><span class="stat-value" id="totalProgress">0</span><span class="stat-unit">%</span></div>
                    </div>
                </div>

                <!-- 指令列表区 -->
                <div class="orders-container">
                    <div class="orders-header">
                        <h3>交易指令总览</h3>
                        <div class="view-options">
                            <button class="btn btn-sm" id="tableViewBtn" onclick="switchToTableView()" 
                                    style="background: #3498db; color: white;">表格视图</button>
                            <button class="btn btn-sm" id="detailViewBtn" onclick="switchToDetailView()" 
                                    style="background: #95a5a6; color: white;">详情视图</button>
                        </div>
                    </div>
                    
                    <!-- 筛选和排序工具栏 -->
                    <div class="filter-toolbar" style="padding: 10px; background: #f8f9fa; border-radius: 5px; margin-bottom: 15px;">
                        <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">
                            <div>
                                <label style="font-size: 12px; color: #666;">投资经理:</label>
                                <select id="managerFilter" onchange="applyFilters()" style="padding: 4px 8px; border: 1px solid #ddd; border-radius: 3px;">
                                    <option value="">全部</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size: 12px; color: #666;">方向:</label>
                                <select id="directionFilter" onchange="applyFilters()" style="padding: 4px 8px; border: 1px solid #ddd; border-radius: 3px;">
                                    <option value="">全部</option>
                                    <option value="买入">买入</option>
                                    <option value="卖出">卖出</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size: 12px; color: #666;">状态:</label>
                                <select id="statusFilter" onchange="applyFilters()" style="padding: 4px 8px; border: 1px solid #ddd; border-radius: 3px;">
                                    <option value="">全部</option>
                                    <option value="待执行">待执行</option>
                                    <option value="执行中">执行中</option>
                                    <option value="已完成">已完成</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size: 12px; color: #666;">搜索:</label>
                                <input type="text" id="searchInput" placeholder="债券名称/代码" onkeyup="applyFilters()" 
                                       style="padding: 4px 8px; border: 1px solid #ddd; border-radius: 3px; width: 150px;">
                            </div>
                        </div>
                    </div>
                    
                    <!-- 表格视图 -->
                    <div id="ordersTableView">
                        <table class="orders-table" style="width: 100%; border-collapse: collapse; background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                            <thead>
                                <tr style="background: #f8f9fa; border-bottom: 2px solid #dee2e6;">
                                    <th style="padding: 12px; text-align: left; font-weight: 600; color: #495057; cursor: pointer;" onclick="sortTable('债券名称')">债券名称 ↕</th>
                                    <th style="padding: 12px; text-align: left; font-weight: 600; color: #495057; cursor: pointer;" onclick="sortTable('投资经理')">投资经理 ↕</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600; color: #495057; cursor: pointer;" onclick="sortTable('方向')">方向 ↕</th>
                                    <th style="padding: 12px; text-align: right; font-weight: 600; color: #495057; cursor: pointer;" onclick="sortTable('交易量')">交易量(万) ↕</th>
                                    <th style="padding: 12px; text-align: right; font-weight: 600; color: #495057; cursor: pointer;" onclick="sortTable('收益率')">收益率(%) ↕</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600; color: #495057; cursor: pointer;" onclick="sortTable('状态')">状态 ↕</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600; color: #495057; cursor: pointer;" onclick="sortTable('完成进度')">进度 ↕</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600; color: #495057;">操作</th>
                                </tr>
                            </thead>
                            <tbody id="ordersTableBody">
                                <!-- 动态生成 -->
                            </tbody>
                        </table>
                    </div>
                    
                    <!-- 详情视图（保留原功能） -->
                    <div id="orderDetailView" style="display: none;">
                <div id="orderDetails">
                    <!-- 动态生成 -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 统一模式应用（新增） -->
    <div id="unifiedApp" class="app-container" style="display:none; padding:16px;">
        <div id="unifiedTopbar" class="topbar">
            <div class="spacer"></div>
            <div class="right">
                <button class="btn btn-danger" onclick="returnToModeSelector()" title="返回模式选择">返回</button>
            </div>
        </div>
        <div style="display:grid; grid-template-columns: 1fr 1fr; gap:16px;">
            <div>
                <h3>输入 & 解析</h3>
                <div style="margin:8px 0;">
                    <label style="display:flex;align-items:center;gap:6px;">
                        <input type="checkbox" id="unifiedPreviewBeforeMerge" onchange="if(!AppState.unifiedData) AppState.unifiedData = {}; if(!AppState.unifiedData.prefs) AppState.unifiedData.prefs = {}; AppState.unifiedData.prefs.previewBeforeMerge=this.checked; DataStorage.saveAppState();" checked>
                        解析后先确认
                    </label>
                </div>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:12px;">
                    <div>
                        <div class="form-group" style="margin:8px 0;">
                            <label>DONE默认投资经理</label>
                            <input type="text" id="unifiedDefaultManagerDone" class="form-control" placeholder="仅用于本次解析的DONE默认投资经理"
                                   oninput="((AppState.unifiedData ||= {}).prefs ||= {}).defaultManagerDone=this.value; DataStorage.saveAppState();">
                        </div>
                        <div style="font-weight:600;">DONE 文本（标准版）</div>
                        <textarea id="unifiedDoneInput" rows="8" style="width:100%;"></textarea>
                        <div style="margin-top:8px; display:flex; gap:8px;">
                            <button class="btn btn-primary" onclick="parseUnifiedDone()">解析DONE</button>
                            <button class="btn btn-secondary" onclick="exportUnifiedDealsCSV()">导出DONE CSV（标准版）</button>
                        </div>
                    </div>
                    <div>
                        <div class="form-group" style="margin:8px 0;">
                            <label>报价默认投资经理</label>
                            <input type="text" id="unifiedDefaultManagerQuote" class="form-control" placeholder="仅用于本次解析的报价默认投资经理"
                                   oninput="((AppState.unifiedData ||= {}).prefs ||= {}).defaultManagerQuote=this.value; DataStorage.saveAppState();">
                        </div>
                        <div style="font-weight:600;">报价文本（ofr/bid，扩展版）</div>
                        <textarea id="unifiedQuoteInput" rows="8" style="width:100%;"></textarea>
                        <div style="margin-top:8px; display:flex; gap:8px;">
                            <button class="btn btn-primary" onclick="parseUnifiedQuote()">解析报价</button>
                            <button class="btn btn-secondary" onclick="exportUnifiedQuotesCSV()">导出报价CSV（扩展版）</button>
                        </div>
                    </div>
                </div>
            </div>

            <div>
                <h3>统一看板</h3>
                <div id="unifiedStats"></div>
                <div id="unifiedFilters" style="margin:8px 0;"></div>
                <div style="margin:8px 0; font-size:12px; color:#666; line-height:1.6;">
                    匹配逻辑：优先匹配债券代码，其次匹配投资经理；债券名称相似度与交易量仅作为加分项，不再作为硬性过滤条件。
                </div>
            </div>
        </div>
        <!-- 统一预览（新增） -->
        <div id="unifiedPreviews" style="margin-top:16px;">
            <div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
                <div>
                    <button class="btn btn-secondary" onclick="toggleUnifiedPreview('deals')">DONE预览</button>
                    <button class="btn btn-secondary" onclick="toggleUnifiedPreview('quotes')">报价预览</button>
                </div>
                <div id="unifiedMassOps" style="display:flex; gap:8px; align-items:center;">
                    <button class="btn btn-danger btn-sm" onclick="deleteSelectedUnified('deal')">删除选中DONE</button>
                    <button class="btn btn-danger btn-sm" onclick="deleteSelectedUnified('quote')">删除选中报价</button>
                    <button class="btn btn-warning btn-sm" onclick="clearUnified('deal')">清空DONE</button>
                    <button class="btn btn-warning btn-sm" onclick="clearUnified('quote')">清空报价</button>
                    <div style="display:flex;gap:8px;align-items:center;">
                        <input id="bulkManagerInput" class="form-control" placeholder="批量设置投资经理" style="height:32px;">
                        <button class="btn btn-secondary btn-sm" onclick="bulkSetManager()">应用到选中</button>
                    </div>
                    <button class="btn btn-primary btn-sm" onclick="openBatchLinkPickerModal()">批量选择匹配</button>
                </div>
            </div>
            <div id="unifiedDealsPreview" style="margin-top:8px; display:none;"></div>
            <div id="unifiedQuotesPreview" style="margin-top:8px; display:none;"></div>
        </div>
    </div>

    <!-- 导入模态框 -->
    <div id="importModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>导入交易指令</h3>
                <button class="close-btn" onclick="closeModal('importModal')">&times;</button>
            </div>
            <div class="form-group">
                <label>投资经理</label>
                <input type="text" class="form-control" id="importManager" placeholder="输入投资经理名称">
            </div>
            <div class="form-group">
                <label>指令文本</label>
                <textarea class="form-control" id="importText" rows="10" placeholder="粘贴交易指令文本...
                
扩展版高级功能：
• FSM块级解析：支持【bid】/【ofr】上下文方向
• 智能识别：中介、户名、发单方式
• 报价行优先：自动识别报价行收益率
• 复杂格式：支持多行结构化数据
• 例如：
  【TP】1) 21国开05 1.84 给 3亿
  240225.IB 24国开25 1.95 出给 国信证券
  3.5Y+N 24华夏银行02 1.95 拿 5000万 发张三 QQ
  【BGC】云南信托金穗10号 2.15 bid 2000万 T+1"></textarea>
            </div>
            <div class="button-group">
                <button class="btn btn-primary" onclick="importOrders()">导入</button>
                <button class="btn btn-secondary" onclick="closeModal('importModal')">取消</button>
            </div>
        </div>
    </div>

    <!-- 新增指令模态框 -->
    <div id="addOrderModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>新增交易指令</h3>
                <button class="close-btn" onclick="closeModal('addOrderModal')">&times;</button>
            </div>
            <div class="form-group">
                <label>投资经理</label>
                <input type="text" class="form-control" id="addManager" placeholder="输入投资经理名称">
            </div>
            <div class="form-group">
                <label>债券代码</label>
                <input type="text" class="form-control" id="addCode" placeholder="如：210205.IB">
            </div>
            <div class="form-group">
                <label>债券名称</label>
                <input type="text" class="form-control" id="addName" placeholder="如：21国开05">
            </div>
            <div class="form-group">
                <label>交易方向</label>
                <select class="form-control" id="addDirection">
                    <option value="买入">买入(BID)</option>
                    <option value="卖出">卖出(OFR)</option>
                </select>
            </div>
            <div class="form-group">
                <label>交易量（万元）</label>
                <input type="number" class="form-control" id="addVolume" placeholder="如：1000">
            </div>
            <div class="form-group">
                <label>目标收益率（%）</label>
                <input type="number" class="form-control" id="addYield" step="0.01" placeholder="如：2.85">
            </div>
            <div class="button-group">
                <button class="btn btn-primary" onclick="addOrder()">添加</button>
                <button class="btn btn-secondary" onclick="closeModal('addOrderModal')">取消</button>
            </div>
        </div>
    </div>



    <!-- 批量进度更新模态框 -->
    <div id="batchProgressModal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">
                <h3>批量进度更新</h3>
                <button class="close-btn" onclick="closeModal('batchProgressModal')">&times;</button>
            </div>
            
            <!-- 指令选择区域 -->
            <div class="form-group">
                <label style="font-weight: bold; margin-bottom: 10px; display: block;">选择要更新进度的指令</label>
                <div style="max-height: 250px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; padding: 15px; background: #f8f9fa;">
                    <div style="margin-bottom: 10px;">
                        <label style="display: flex; align-items: center; gap: 8px; font-weight: normal;">
                            <input type="checkbox" id="selectAllProgressOrders" onchange="toggleAllProgressOrders(this)">
                            <span style="font-weight: bold;">全选指令</span>
                        </label>
                    </div>
                    <div id="progressOrdersList">
                        <!-- 动态生成指令列表 -->
                    </div>
                </div>
            </div>
            
            <!-- 进度更新方式 -->
            <div class="form-group">
                <label style="font-weight: bold; margin-bottom: 10px; display: block;">选择更新方式</label>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <!-- 统一进度 -->
                    <div>
                        <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
                            <input type="radio" name="progressMode" value="uniform" checked onchange="switchProgressMode()">
                            <span style="font-weight: bold;">统一设置进度</span>
                        </label>
                        <div id="uniformProgressArea">
                            <input type="number" id="uniformProgress" class="form-control" 
                                   min="0" max="100" value="50" placeholder="输入进度百分比"
                                   oninput="updateProgressPreview()">
                            <div style="font-size: 12px; color: #666; margin-top: 5px;">
                                为所有选中的指令设置相同的进度值
                            </div>
                        </div>
                    </div>
                    
                    <!-- 增量更新 -->
                    <div>
                        <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
                            <input type="radio" name="progressMode" value="increment" onchange="switchProgressMode()">
                            <span style="font-weight: bold;">增量更新进度</span>
                        </label>
                        <div id="incrementProgressArea" style="display: none;">
                            <input type="number" id="incrementProgress" class="form-control" 
                                   min="-100" max="100" value="10" placeholder="输入增量值"
                                   oninput="updateProgressPreview()">
                            <div style="font-size: 12px; color: #666; margin-top: 5px;">
                                在当前进度基础上增加或减少指定值
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 预览区域 -->
            <div id="progressPreviewArea" style="margin-top: 20px;">
                <label style="font-weight: bold; margin-bottom: 10px; display: block;">预览更新结果</label>
                <div id="progressPreview" style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; padding: 15px; background: #fff;">
                    <div style="text-align: center; color: #999; padding: 20px;">请选择指令和更新方式</div>
                </div>
            </div>
            
            <div class="button-group" style="margin-top: 20px;">
                <button class="btn btn-primary" onclick="executeBatchProgress()">更新进度</button>
                <button class="btn btn-secondary" onclick="closeModal('batchProgressModal')">取消</button>
            </div>
        </div>
    </div>

    <!-- 编辑现有指令模态框 -->
    <div id="editOrderModal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">
                <h3>编辑交易指令</h3>
                <span class="close" onclick="closeModal('editOrderModal')">&times;</span>
            </div>
            
            <div style="padding: 20px;">
                <!-- 指令基本信息 -->
                <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; font-size: 14px;">
                        <div><strong>指令ID:</strong> <span id="editOrderId">-</span></div>
                        <div><strong>创建时间:</strong> <span id="editOrderCreateTime">-</span></div>
                        <div><strong>当前状态:</strong> <span id="editOrderStatus">-</span></div>
                        <div><strong>完成进度:</strong> <span id="editOrderProgress">-</span>%</div>
                    </div>
                    <div style="margin-top: 10px;">
                        <strong>原始文本:</strong> <span id="editOrderOriginalText" style="font-size: 12px; color: #666;">-</span>
                    </div>
                </div>
                
                <!-- 编辑表单 -->
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
                    <div>
                        <label>投资经理 <span style="color: red;">*</span>:</label>
                        <input type="text" id="editOrderManager" class="form-control" readonly>
                    </div>
                    <div>
                        <label>债券代码 <span style="color: red;">*</span>:</label>
                        <input type="text" id="editOrderCode" class="form-control" placeholder="如: 102400608.IB">
                    </div>
                    <div>
                        <label>债券名称 <span style="color: red;">*</span>:</label>
                        <input type="text" id="editOrderName" class="form-control" placeholder="如: 24晋城国资MTN001">
                    </div>
                    <div>
                        <label>交易方向 <span style="color: red;">*</span>:</label>
                        <select id="editOrderDirection" class="form-control">
                            <option value="买入">买入</option>
                            <option value="卖出">卖出</option>
                        </select>
                    </div>
                    <div>
                        <label>交易量(万元) <span style="color: red;">*</span>:</label>
                        <input type="number" id="editOrderVolume" class="form-control" step="0.01" placeholder="如: 5000">
                    </div>
                    <div>
                        <label>收益率(%):</label>
                        <input type="number" id="editOrderYield" class="form-control" step="0.001" placeholder="如: 1.89">
                    </div>
                    <div>
                        <label>收益率类型:</label>
                        <select id="editOrderYieldType" class="form-control">
                            <option value="">请选择</option>
                            <option value="到期收益率">到期收益率</option>
                            <option value="行权收益率">行权收益率</option>
                            <option value="参考收益率">参考收益率</option>
                            <option value="报价收益率">报价收益率</option>
                        </select>
                    </div>
                    <div>
                        <label>交易场所:</label>
                        <select id="editOrderTradingVenue" class="form-control">
                            <option value="">请选择</option>
                            <option value="银行间">银行间</option>
                            <option value="交易所">交易所</option>
                        </select>
                    </div>
                    <div>
                        <label>中介:</label>
                        <input type="text" id="editOrderIntermediary" class="form-control" placeholder="如: 国际">
                    </div>
                    <div>
                        <label>清算速度:</label>
                        <select id="editOrderSettlement" class="form-control">
                            <option value="">请选择</option>
                            <option value="T+0">T+0</option>
                            <option value="T+1">T+1</option>
                            <option value="T+2">T+2</option>
                        </select>
                    </div>
                    <div>
                        <label>净价:</label>
                        <input type="number" id="editOrderNetPrice" class="form-control" step="0.0001" placeholder="如: 100.50">
                    </div>
                    <div>
                        <label>全价:</label>
                        <input type="number" id="editOrderFullPrice" class="form-control" step="0.0001" placeholder="如: 101.20">
                    </div>
                </div>
                
                <div style="margin-top: 15px;">
                    <label>备注:</label>
                    <textarea id="editOrderRemarks" class="form-control" rows="3" placeholder="补充说明信息..."></textarea>
                </div>
                
                <!-- 智能提示 -->
                <div id="editOrderSmartTips" style="margin-top: 15px; padding: 10px; background: #e3f2fd; border-radius: 5px; display: none;">
                    <div style="font-weight: bold; margin-bottom: 8px;">💡 智能提示:</div>
                    <div id="editOrderTipsContent"></div>
                </div>
            </div>
            
            <div class="button-group" style="margin-top: 20px;">
                <button class="btn btn-info" onclick="autoFillOrderInfo()">智能填充</button>
                <button class="btn btn-primary" onclick="saveOrderEdit()">保存修改</button>
                <button class="btn btn-secondary" onclick="closeModal('editOrderModal')">取消</button>
            </div>
        </div>
    </div>

    <!-- 解析结果编辑模态框 -->
    <div id="parseResultsModal" class="modal">
        <div class="modal-content" style="max-width: 95%; max-height: 90%; width: 1200px;">
            <div class="modal-header">
                <h3>解析结果确认与修正</h3>
                <span class="close" onclick="closeModal('parseResultsModal')">&times;</span>
            </div>
            
            <div style="padding: 20px;">
                <!-- 统计信息 -->
                <div id="parseStatsInfo" style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <!-- 动态生成统计信息 -->
                </div>
                
                <!-- 操作工具栏 -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding: 10px; background: #e9ecef; border-radius: 5px;">
                    <div>
                        <button class="btn btn-sm btn-info" onclick="autoFixCommonErrors()">智能修正</button>
                        <button class="btn btn-sm btn-secondary" onclick="selectAllRecords()">全选</button>
                        <button class="btn btn-sm btn-secondary" onclick="deselectAllRecords()">清空</button>
                        <button class="btn btn-sm btn-warning" onclick="deleteSelectedRecords()">删除选中</button>
                    </div>
                    <div>
                        <span id="editingRecordCount">共 0 条记录</span>
                    </div>
                </div>
                
                <!-- 记录列表 -->
                <div style="max-height: 500px; overflow-y: auto; border: 1px solid #ddd; border-radius: 5px;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead style="background: #f8f9fa; position: sticky; top: 0;">
                            <tr>
                                <th style="padding: 8px; border: 1px solid #ddd; width: 40px;">选择</th>
                                <th style="padding: 8px; border: 1px solid #ddd; width: 60px;">序号</th>
                                <th style="padding: 8px; border: 1px solid #ddd; width: 120px;">债券代码</th>
                                <th style="padding: 8px; border: 1px solid #ddd; width: 150px;">债券名称</th>
                                <th style="padding: 8px; border: 1px solid #ddd; width: 80px;">方向</th>
                                <th style="padding: 8px; border: 1px solid #ddd; width: 100px;">交易量(万)</th>
                                <th style="padding: 8px; border: 1px solid #ddd; width: 100px;">收益率(%)</th>
                                <th style="padding: 8px; border: 1px solid #ddd; width: 120px;">收益率类型</th>
                                <th style="padding: 8px; border: 1px solid #ddd; width: 100px;">交易场所</th>
                                <th style="padding: 8px; border: 1px solid #ddd; width: 60px;">操作</th>
                                <th style="padding: 8px; border: 1px solid #ddd;">原始文本</th>
                            </tr>
                        </thead>
                        <tbody id="parseResultsTable">
                            <!-- 动态生成 -->
                        </tbody>
                    </table>
                </div>
                
                <!-- 单条记录编辑表单 -->
                <div id="recordEditForm" style="display: none; margin-top: 20px; padding: 20px; background: #f8f9fa; border-radius: 5px; border: 2px solid #007bff;">
                    <h4 style="margin-top: 0;">编辑记录 <span id="editingRecordIndex"></span></h4>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
                        <div>
                            <label>债券代码:</label>
                            <input type="text" id="editBondCode" class="form-control">
                        </div>
                        <div>
                            <label>债券名称:</label>
                            <input type="text" id="editBondName" class="form-control">
                        </div>
                        <div>
                            <label>方向:</label>
                            <select id="editDirection" class="form-control">
                                <option value="买入">买入</option>
                                <option value="卖出">卖出</option>
                            </select>
                        </div>
                        <div>
                            <label>交易量(万元):</label>
                            <input type="number" id="editVolume" class="form-control" step="0.01">
                        </div>
                        <div>
                            <label>收益率(%):</label>
                            <input type="number" id="editYield" class="form-control" step="0.001">
                        </div>
                        <div>
                            <label>收益率类型:</label>
                            <select id="editYieldType" class="form-control">
                                <option value="到期收益率">到期收益率</option>
                                <option value="行权收益率">行权收益率</option>
                                <option value="参考收益率">参考收益率</option>
                                <option value="报价收益率">报价收益率</option>
                            </select>
                        </div>
                        <div>
                            <label>交易场所:</label>
                            <select id="editTradingVenue" class="form-control">
                                <option value="银行间">银行间</option>
                                <option value="交易所">交易所</option>
                                <option value="">未知</option>
                            </select>
                        </div>
                        <div>
                            <label>中介:</label>
                            <input type="text" id="editIntermediary" class="form-control">
                        </div>
                        <div>
                            <label>备注:</label>
                            <input type="text" id="editRemarks" class="form-control">
                        </div>
                    </div>
                    <div style="margin-top: 15px;">
                        <button class="btn btn-primary" onclick="saveRecordEdit()">保存修改</button>
                        <button class="btn btn-secondary" onclick="cancelRecordEdit()">取消</button>
                    </div>
                </div>
            </div>
            
            <!-- 底部按钮 -->
            <div class="button-group" style="margin-top: 20px;">
                <button class="btn btn-primary" onclick="confirmParseResults()">确认并导入</button>
                <button class="btn btn-secondary" onclick="reparse()">重新解析</button>
                <button class="btn btn-danger" onclick="closeModal('parseResultsModal')">取消</button>
            </div>
        </div>
    </div>

    <!-- 提示框 -->
    <div id="toast" class="toast"></div>
    <!-- 离线SheetJS库 - 请将xlsx.full.min.js下载到本地 -->
    <script>
        // 开发期：全局JS错误提示
        window.addEventListener('error', function(e){
            try { showToast('JS错误: ' + (e.message || (e.error && e.error.message) || e.filename || ''), 'error'); } catch(_) {}
            console.error(e);
        });
        // 内嵌轻量级Excel导出功能，确保完全离线运行
        window.offlineXLSX = {
            // 简单的CSV到Excel转换
            writeFile: function(workbook, filename) {
                const csv = this.utils.sheet_to_csv(workbook.Sheets[workbook.SheetNames[0]]);
                this.downloadCSV(csv, filename.replace('.xlsx', '.csv'));
            },
            
            utils: {
                book_new: function() {
                    return { Sheets: {}, SheetNames: [] };
                },
                
                aoa_to_sheet: function(data) {
                    return {
                        data: data,
                        '!ref': `A1:${this.encode_cell({ r: data.length - 1, c: Math.max(...data.map(row => row.length)) - 1 })}`
                    };
                },
                
                book_append_sheet: function(workbook, sheet, name) {
                    workbook.Sheets[name] = sheet;
                    workbook.SheetNames.push(name);
                },
                
                sheet_to_csv: function(sheet) {
                    if (!sheet.data) return '';
                    return sheet.data.map(row => 
                        row.map(cell => {
                            const cellStr = String(cell || '');
                            // 如果包含逗号、引号或换行符，需要用引号包围并转义引号
                            if (cellStr.includes(',') || cellStr.includes('"') || cellStr.includes('\n')) {
                                return '"' + cellStr.replace(/"/g, '""') + '"';
                            }
                            return cellStr;
                        }).join(',')
                    ).join('\n');
                },
                
                encode_cell: function(cell) {
                    const col = String.fromCharCode(65 + cell.c);
                    return col + (cell.r + 1);
                },
                
                // 添加encode_range函数以兼容旧版本代码
                encode_range: function(range) {
                    if (!range || !range.s || !range.e) return 'A1:A1';
                    const startCol = String.fromCharCode(65 + range.s.c);
                    const endCol = String.fromCharCode(65 + range.e.c);
                    return `${startCol}${range.s.r + 1}:${endCol}${range.e.r + 1}`;
                }
            },
            
            downloadCSV: function(csv, filename) {
                // 添加BOM以确保Excel正确显示中文
                const BOM = '\uFEFF';
                const csvContent = BOM + csv;
                
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                setTimeout(() => URL.revokeObjectURL(url), 100);
            }
        };
        
        // 如果没有加载XLSX库，使用我们的离线版本
        if (typeof XLSX === 'undefined') {
            window.XLSX = window.offlineXLSX;
            console.log('使用离线Excel导出功能');
        }
    </script>
    
    <script>
        // 全局状态管理
        const AppState = {
            mode: null,
            standardData: [],
            enhancedData: {
                managers: {},
                orders: [],
                stats: {
                    total: 0,
                    executing: 0,
                    completed: 0,
                    progress: 0
                }
            },
            currentOrder: null
        };

        // Unified 数据容器（新增）
        if (!AppState.unifiedData) {
            AppState.unifiedData = {
                deals: [],
                quotes: [],
                links: [],
                stats: { totalDeals: 0, matchedDeals: 0, coverage: 0, lastMatchedAt: null },
                prefs: {
                    bpTolerance: 2,
                    volToleranceRatio: 0.3,
                    timeWindowDays: 5,
                    nameSimThreshold: 0.80,
                    previewBeforeMerge: true,
                    sideStrict: true,
                    codeFirst: true,
                    maxLinkPerDeal: 3,
                    allowCrossManager: true,
                    useBpInScoring: false
                }
            };
        }

        // 生成稳定ID（不影响原有ID）
        function genId(prefix='U') { return `${prefix}_${Date.now()}_${Math.random().toString(16).slice(2,8)}`; }

        // 名义BondKey：优先代码，其次规整后的名称
        function normalizeBondKey(code, name) {
            if (code && typeof code === 'string') return code.replace(/\.(IB|SH|SZ)$/i,'').trim();
            if (!name) return '';
            return (name || '').replace(/\s+/g, '').replace(/[（）()]/g,'').toUpperCase();
        }

        // 方向映射：DONE"买入"→期望匹配"OFR"，DONE"卖出"→期望匹配"BID"
        function expectedQuoteSideByDeal(directionCN) {
            return directionCN === '买入' ? '卖出' : directionCN === '卖出' ? '买入' : '';
        }

        // 规范化：把标准/扩展输出映射为统一记录字段（不改源对象）
        function decorateDealRecord(stdRec, idx) {
            return {
                dealId: stdRec.指令ID || genId('D'),
                source: 'standard',
                bondKey: normalizeBondKey(stdRec.债券代码, stdRec.债券名称),
                code: stdRec.债券代码 || '',
                name: stdRec.债券名称 || '',
                direction: stdRec.方向,
                expQuoteSide: expectedQuoteSideByDeal(stdRec.方向),
                term: stdRec.期限 || '',
                yield: parseFloat((stdRec.收益率||'').toString().replace('%','')) || null,
                yieldType: stdRec.收益率类型 || '',
                volumeWan: parseFloat(stdRec.交易量) || 0,
                tradeDate: stdRec.交易日期 || '',
                manager: stdRec.投资经理 || ((AppState.unifiedData && AppState.unifiedData.prefs && AppState.unifiedData.prefs.defaultManager) || ''),
                raw: stdRec,
                fillWan: 0,
                state: 'unfilled'
            };
        }

        // 报价统一化（扩展版）：把 ofr/bid 变成中文方向以对齐
        function decorateQuoteRecord(qRec, idx) {
            return {
                quoteId: qRec.指令ID || genId('Q'),
                source: 'enhanced',
                bondKey: normalizeBondKey(qRec.债券代码, qRec.债券名称),
                code: qRec.债券代码 || '',
                name: qRec.债券名称 || '',
                side: qRec.方向,
                term: qRec.期限 || '',
                yield: typeof qRec.收益率 === 'number' ? qRec.收益率 : parseFloat((qRec.收益率||'').toString().replace('%','')) || null,
                yieldType: qRec.收益率类型 || '',
                volumeWan: parseFloat(qRec.交易量) || 0,
                tradeDate: qRec.交易日期 || '',
                manager: qRec.投资经理 || '',
                raw: qRec,
                filledWan: 0,
                fills: [],
                completed: false
            };
        }

        class MatchEngine {
            static simName(a, b) {
                if (!a || !b) return 0;
                a = a.replace(/\s+/g,'').toUpperCase();
                b = b.replace(/\s+/g,'').toUpperCase();
                if (a === b) return 1;
                let max=0;
                for (let i=0;i<a.length;i++){
                    for (let j=i+1;j<=a.length;j++){
                        const sub=a.slice(i,j);
                        if (b.includes(sub)) max=Math.max(max, sub.length);
                    }
                }
                return max / Math.max(a.length,b.length);
            }

            static bpDiff(dealYield, quoteYield) {
                if (dealYield==null || quoteYield==null) return null;
                return Math.round((dealYield - quoteYield)*100);
            }

            static sameManager(a, b) {
                const na = (a||'').replace(/\s+/g,'').toUpperCase();
                const nb = (b||'').replace(/\s+/g,'').toUpperCase();
                if (!na || !nb) return false;
                return na === nb;
            }

            static score(deal, quote, prefs) {
                const reasons = [];
                let s=0;

                if (deal.bondKey && quote.bondKey && deal.bondKey === quote.bondKey) {
                    s+=100; reasons.push('code=exact');
                }

                if (MatchEngine.sameManager(deal.manager, quote.manager)) {
                    s+=60; reasons.push('manager=exact');
                }

                const sim = MatchEngine.simName(deal.name, quote.name);
                if (sim >= (prefs.nameSimThreshold || 0.8)) { s+=25; reasons.push(`name~${Math.round(sim*100)}%`); }

                const need = deal.expQuoteSide;
                if (need && ((need==='买入' && quote.side==='买入') || (need==='卖出' && quote.side==='卖出'))) {
                    s+=30; reasons.push('side=ok');
                } else {
                    reasons.push('side=diff');
                    if (prefs.sideStrict) { s = -999; }
                }

                if (prefs.useBpInScoring) {
                    const bp = MatchEngine.bpDiff(deal.yield, quote.yield);
                    if (bp!=null) {
                        const abp = Math.abs(bp);
                        if (abp<=1) { s+=25; reasons.push('≤1bp'); }
                        else if (abp<=2){ s+=18; reasons.push('≤2bp'); }
                        else if (abp<=5){ s+=10; reasons.push('≤5bp'); }
                        else { reasons.push(`>${abp}bp`); }
                    }
                }

                if (deal.volumeWan>0 && quote.volumeWan>0) {
                    const ratio = Math.abs(quote.volumeWan - deal.volumeWan) / deal.volumeWan;
                    if (ratio <= (prefs.volToleranceRatio || 0.3)){ s+=10; reasons.push('vol~'); }
                }

                if (deal.tradeDate && quote.tradeDate) {
                    if (deal.tradeDate === quote.tradeDate) { s+=5; reasons.push('same-day'); }
                }

                return { s, reasons, bp: null };
            }

            static run() {
                const prefs = AppState.unifiedData.prefs;
                const deals = AppState.unifiedData.deals || [];
                const quotes = AppState.unifiedData.quotes || [];
                const links = [];

                for (const d of deals) {
                    if (!d.expQuoteSide) continue;
                    const cands = [];
                    for (const q of quotes) {
                        if (prefs.sideStrict && d.expQuoteSide && q.side !== d.expQuoteSide) continue;

                        const codeOk = (d.bondKey && q.bondKey && d.bondKey===q.bondKey);
                        const managerOk = MatchEngine.sameManager(d.manager, q.manager);
                        const nameOk = MatchEngine.simName(d.name, q.name) >= (prefs.nameSimThreshold || 0.8);

                        // 如果不允许跨投资经理，则强制要求经理一致
                        if (prefs.allowCrossManager === false && !managerOk) continue;

                        // 接受准入规则：优先代码或经理，其次在信息缺失时允许名称相似
                        let accept = false;
                        if (codeOk || managerOk) {
                            accept = true;
                        } else {
                            const bothCodeMissing = !d.bondKey && !q.bondKey;
                            const bothManagerMissing = !d.manager && !q.manager;
                            if ((bothCodeMissing || bothManagerMissing) && nameOk) accept = true;
                        }
                        if (!accept) continue;

                        if (prefs.timeWindowDays>0 && d.tradeDate && q.tradeDate){
                            const dt = new Date(d.tradeDate), qt = new Date(q.tradeDate);
                            const diff = Math.abs((qt-dt)/86400000);
                            if (diff > prefs.timeWindowDays) continue;
                        }
                        const { s, reasons } = MatchEngine.score(d, q, prefs);
                        if (s>0) {
                            cands.push({ quoteId:q.quoteId, score:s, reasons });
                        }
                    }
                    cands.sort((a,b)=>b.score-a.score);
                    (cands.slice(0, prefs.maxLinkPerDeal||3)).forEach((c,rank)=>{
                        links.push({
                            linkId: genId('L'),
                            dealId: d.dealId,
                            quoteId: c.quoteId,
                            score: c.score,
                            volMatch: null,
                            timeDiffMin: null,
                            reason: c.reasons
                        });
                    });
                }

                AppState.unifiedData.links = links;

                const gid = new Map();
                for (const l of links) {
                    if (!gid.has(l.dealId)) gid.set(l.dealId, true);
                }
                const matched = gid.size;

                AppState.unifiedData.stats.totalDeals = deals.length;
                AppState.unifiedData.stats.matchedDeals = matched;
                AppState.unifiedData.stats.coverage = deals.length? Math.round(matched*100/deals.length) : 0;
                AppState.unifiedData.stats.lastMatchedAt = new Date().toISOString();

                // === 完成判定：基于已生成的 links 回填报价完成状态 ===
                const prefs2 = AppState.unifiedData.prefs || {};
                const linksByQuote = links.reduce((m, l) => {
                    if (!m[l.quoteId]) m[l.quoteId] = []; m[l.quoteId].push(l);
                    return m;
                }, {});
                quotes.forEach(q => {
                    const candidates = (linksByQuote[q.quoteId] || []).sort((a,b)=>b.score-a.score);
                    const ok = candidates.find(l => true);
                    q.completed = !!ok;
                    q.primaryDealId = ok && ok.dealId || '';
                    q.primaryLinkId = ok && ok.linkId || '';
                });

                // 统计完成率
                AppState.unifiedData.stats.totalQuotes = quotes.length;
                AppState.unifiedData.stats.completedQuotes = quotes.filter(q => q.completed).length;
                AppState.unifiedData.stats.completionRate = quotes.length
                  ? Math.round(AppState.unifiedData.stats.completedQuotes * 100 / quotes.length)
                  : 0;
            }
        }

        // 通用工具函数：分割主句与请求段
        function splitMainAndRequest(text) {
            const idx = (text || '').indexOf('【请求】');
            return {
                main: idx === -1 ? (text || '') : (text || '').slice(0, idx),
                request: idx === -1 ? '' : (text || '').slice(idx)
            };
        }
        // 债券解析器核心 - 基础版
        class BondParser {
            constructor() {
                this.setupPatterns();
                this.setupCaches();
            }

            setupCaches() {
                // 性能优化：缓存
                this.codeCache = new Map();
                this.directionCache = new Map();
                this.nameCache = new Map();
                this.cachedResults = new Map();
            }

            setupPatterns() {
                // 方向识别（扩展词汇 - 参考清洁版.py完整功能）
                this.buyVerbs = ['bid', 'BID', 'Bid', '买入', '买', '拿', '收', '要', '求', '询', 
                               '收购', '采购', '购买', '需要', '寻求', '帮忙拿', '接', '吃', '捡', 
                               'b', 'B', '收票', '吃掉', '扫货', '要拿', '拿一下', '收一下', 
                               '要一下', '求一口', '接货', '接盘', '承接', '看多', 'buy', 'BUY', 
                               '询价', '接收', '拿货', '收货', '找货', '买进', '增持'];
                this.sellVerbs = ['ofr', 'OFR', 'Ofr', 'offer', 'OFFER', 'Offer', '卖出', '卖', 
                                '给', '出', '售', '让', '转', '抛', '出售', '供应', '提供', 
                                '释放', '挂牌', '出给', '挂给', 'of', 'OF', '甩', '放', 
                                '报价', '给一下', '报一口', '挂一下', '抛一下', '让一下', 
                                '放一下', '出一下', '甩货', '抛售', '减持', 'sell', 'SELL', 
                                'ask', 'ASK', '供给', '供货', '派发', '分销', '看空', '售出'];
                
                // 编译正则表达式（基于清洁版.py逻辑）
                this.patterns = {
                    // 债券代码模式（按优先级排序）
                    codeExchange: /(\d{6,9}\.(?:SH|SZ|IB))/gi,
                    codeInterbank: /(\d{9})(?!\d)/g,
                    code8digit: /(\d{8})(?!\d)/g,
                    code7digit: /(\d{7})(?!\d)/g,
                    code6digit: /(\d{6})(?!\d)/g,
                    
                    // 期限信息
                    termSingle: /(\d+\.?\d*[YD])/g,
                    termComplex: /(\d+\.?\d*[YD]\s*\+\s*\d+\.?\d*[YD])/g,
                    termSpecial: /(\+\s*N(?:Y)?(?:\([^)]*\))?)/g,
                    
                    // 债券名称（增强模式）
                    bondName: [
                        /([A-Z]{2,6}[\u4e00-\u9fa5]+\d{2,4})/g,
                        /(\d{2}[\u4e00-\u9fa5]+(?:银行|证券|金融|集团|公司|国际|投资|控股|发展|建设|交通|城投|地产|能源|煤业|钢铁|化工|电力|水务|环保|科技)?(?:永续债|二级资本债|专项债|企业债|公司债|中期票据|MTN|可转债|私募债)?\d*)/g,
                        /([\u4e00-\u9fa5]+(?:永续债|二级资本债|专项债|企业债|公司债|中期票据|MTN|可转债|私募债)\d*)/g,
                        /([A-Z]{2,6}\d{2,4})/g,
                        // 增强的债券名称模式，支持PPN/SCP/CP等后缀
                        /(\d{2}[\u4e00-\u9fa5]{2,8}(?:PPN|SCP|CP|MTN)\d*)/g,  // 如"24豫航空港PPN004"
                        /([\u4e00-\u9fa5]{2,8}\d{2,4}(?:PPN|SCP|CP|MTN)\d*)/g,  // 中文+数字+后缀
                        // 新增：支持"数字+字母"或"数字+字母(字母)"结尾（如 01BC、02A(BC)）
                        /(\d{2}[\u4e00-\u9fa5]{1,12}\d{2}[A-Z]{1,3}(?:\([A-Z]{1,4}\))?)/g,
                        /([\u4e00-\u9fa5]{2,12}\d{2}[A-Z]{1,3}(?:\([A-Z]{1,4}\))?)/g,
                        // 新增：支持汉字后跟字母数字（如 东证C2）及全角括号内容（如 （特））
                        /(\d{2}[\u4e00-\u9fa5]{1,12}[A-Z]\d{1,3}(?:（[^）]{1,6}）)?)/g,
                        /([\u4e00-\u9fa5]{2,12}[A-Z]\d{1,3}(?:（[^）]{1,6}）)?)/g,
                        // 新增：支持通用字母后缀格式，如"23河钢集GN002"
                        /(\d{2}[\u4e00-\u9fa5]{1,8}[A-Z]{1,4}\d{1,4})/g,
                        // 新增：支持"21株国04"格式（2位年份+中文+2-4位数字，无字母）
                        /(\d{2}[\u4e00-\u9fa5]{2,6}\d{2,4})/g,
                        /([\u4e00-\u9fa5]{3,8}\d{2,4})/g  // 原模式，保持兼容性
                    ],
                    
                    // 交易量（增强识别）
                    volumeKw: /(\d+(?:\.\d+)?)\s*(?:kw|KW|Kw)\b/g,
                    volumeK: /(\d+(?:\.\d+)?)\s*[kK](?![wW])\b/g,
                    volumeWan: /(\d+(?:\.\d+)?)\s*[万Ww](?![\u4e00-\u9fa5])/g,
                    volumeYi: /(\d+(?:\.\d+)?)\s*亿/g,
                    volumeNumber: /(\d{3,5})(?!\d)/g,
                    volumeScientific: /(\d+(?:\.\d+)?)[Ee](?:\s*万?)?/g,
                    
                    // 收益率（增强识别）
                    yieldExercise: /(\d+\.\d{2,4})\s*(?:行权)/g,
                    yieldMaturity: /(\d+\.\d{2,4})\s*(?:到期)/g,
                    yieldRate: /(\d+\.\d{2,4})(?:\s*%|\s*\*|(?=\s|$))/g,
                    yieldWithStar: /(\d+\.\d{2,4})\*/g,
                    bidOfferPair: /(\d+\.\d{2,4})\s*\/\s*(\d+\.\d{2,4})/g,
                    
                    // 日期（增强识别）
                    dateToday: /今天|今日|T\+0|t\+0|T0|t0/gi,
                    dateTomorrow: /明天|明日|T\+1|t\+1|T1|t1/gi,
                    dateMD: /(\d{1,2})[.\-\/](\d{1,2})/g,
                    dateDot: /(\d{2})\.(\d{2})(?!\d)/g,
                    dateDash: /(\d{2})-(\d{2})(?!\d)/g,
                    date4digit: /(?<!\d)(\d{2})(\d{2})(?!\d)/g,
                    
                    // 清算速度
                    settlementT0: /T\+0|t\+0|T0|t0/gi,
                    settlementT1: /T\+1|t\+1|T1|t1/gi,
                    settlementExchange: /交易所/g,
                    settlementRemote: /远期|远/g,
                    
                    // 中介和对手方
                    intermediary: /【([^】]+)】/g,
                    counterparty: /([^\s]+(?:\s+[^\s]+)*)\s+出给\s+([^\s]+(?:\s+[^\s]+)*)/g
                };
            }


            parseBondCode(text) {
                // 使用缓存
                if (this.codeCache.has(text)) {
                    return this.codeCache.get(text);
                }
                
                let result = '';
                let match;
                
                // 带交易所后缀的代码
                match = text.match(this.patterns.codeExchange);
                if (match) {
                    result = match[0].toUpperCase();
                    this.codeCache.set(text, result);
                    return result;
                }
                
                // 9位银行间代码
                match = text.match(this.patterns.codeInterbank);
                if (match) {
                    result = match[0] + '.IB';
                    this.codeCache.set(text, result);
                    return result;
                }
                
                // 8位代码
                match = text.match(this.patterns.code8digit);
                if (match) {
                    const code = match[0];
                    // 如果没有后缀，默认银行间
                    result = code.includes('.') ? code : code + '.IB';
                    this.codeCache.set(text, result);
                    return result;
                }
                
                // 7位代码
                match = text.match(this.patterns.code7digit);
                if (match) {
                    const code = match[0];
                    // 如果没有后缀，默认银行间
                    result = code.includes('.') ? code : code + '.IB';
                    this.codeCache.set(text, result);
                    return result;
                }
                
                // 6位代码
                match = text.match(this.patterns.code6digit);
                if (match) {
                    const code = match[0];
                    if (code.startsWith('1') || code.startsWith('5')) {
                        result = code + '.SH';
                    } else if (code.startsWith('3')) {
                        result = code + '.SZ';
                    } else {
                        // 其他6位代码默认银行间
                        result = code + '.IB';
                    }
                    this.codeCache.set(text, result);
                    return result;
                }
                
                this.codeCache.set(text, result);
                return result;
            }

            parseBondName(text) {
                // 使用缓存
                if (this.nameCache.has(text)) {
                    return this.nameCache.get(text);
                }
                // 若已识别出债券代码，则优先使用基于代码的精准提取
                try {
                    const codeForName = this.parseBondCode(text);
                    if (codeForName) {
                        const precise = extractBondNameByCleanMethod(text, codeForName);
                        if (precise) {
                            this.nameCache.set(text, precise);
                            return precise;
                        }
                    }
                } catch (e) {}
                
                let result = '';
                
                // 重构：收集所有匹配，选择最佳匹配（优先级 > 长度）
                let allMatches = [];
                
                for (let pattern of this.patterns.bondName) {
                    const matches = text.matchAll(new RegExp(pattern.source, pattern.flags));
                    for (const match of matches) {
                        if (this.isValidBondNameMatch(match[0], text)) {
                            let priority = 5; // 默认优先级
                            const matchText = match[0];
                            
                            // 精确的优先级分配
                            if (/^[A-Z]{2,6}[\u4e00-\u9fa5]+\d{2,4}$/.test(matchText)) {
                                // 字母+中文+数字（如"GC核融03"）
                                priority = 15;
                            } else if (/^\d{2}[\u4e00-\u9fa5]{1,8}[A-Z]{1,4}\d{1,4}$/.test(matchText)) {
                                // 年份+中文+字母+数字（如"23河钢集GN002"）
                                priority = 15;
                            } else if (/^\d{2}[\u4e00-\u9fa5]{2,6}\d{2,4}$/.test(matchText)) {
                                // 年份+中文+数字（如"21株国04"），高优先级
                                priority = 16;
                            } else if (/^[\u4e00-\u9fa5]{3,8}\d{2,4}$/.test(matchText)) {
                                // 简洁的中文+数字（如"衡阳03"，长度<10）
                                priority = matchText.length <= 10 ? 15 : 8;
                            } else if (/(?:PPN|MTN|SCP|CP)\d*$/.test(matchText)) {
                                // 标准后缀格式
                                priority = 12;
                            } else if (/(?:永续债|二级资本债|专项债|企业债|公司债|中期票据|可转债)\d*$/.test(matchText)) {
                                // 债券类型后缀
                                priority = 8;
                            } else if (matchText.length > 15) {
                                // 过长的匹配，可能是误匹配
                                priority = 3;
                            }
                            
                            allMatches.push({
                                text: matchText,
                                length: matchText.length,
                                index: match.index,
                                priority: priority
                            });
                        }
                    }
                }
                
                // 选择最佳匹配：首先按优先级，然后按长度（短的优先）
                if (allMatches.length > 0) {
                    allMatches.sort((a, b) => {
                        if (a.priority !== b.priority) {
                            return b.priority - a.priority; // 优先级高的在前
                        }
                        // 相同优先级下，短的在前（对于债券名称，短的通常更准确）
                        return a.length - b.length;
                    });
                    result = allMatches[0].text;
                }
                
                // 如果有代码但没匹配到，则尝试基于代码的直接回溯（如“23长江02”紧跟在代码后）
                if (!result && this.parseBondCode(text)) {
                    const code = this.parseBondCode(text);
                    const precise = extractBondNameByCleanMethod(text, code);
                    if (precise) result = precise;
                }

                // 如果没有找到且没有债券代码，尝试无代码提取
                if (!result && !this.parseBondCode(text)) {
                    result = this.extractBondNameWithoutCode(text);
                }
                
                this.nameCache.set(text, result);
                return result;
            }
            
            extractBondNameWithoutCode(line) {
                // 代码缺失时的债券名称提取
                if (!line) return '';
                
                let cleanedLine = line;
                
                // 去掉开头的标记和序号
                cleanedLine = cleanedLine.replace(/^[^【\[]*[\[【][^】\]]*[】\]]?\s*/, '');
                cleanedLine = cleanedLine.replace(/^\d+\)\s*/, '');
                cleanedLine = cleanedLine.replace(/^(买入|卖出)\s+/i, '');
                
                let text = cleanedLine.trim();
                
                // 去掉期限信息（含 +N / +NY / +N(休1)）
                text = text.replace(/\d+\.?\d*[YD]\s*(?:\+\s*\d+\.?\d*[YD])?/g, '');
                text = text.replace(/\+\s*N(?:Y)?(?:\([^)]*\))?/g, '');
                text = text.trim();
                
                if (!text) return '';
                
                // 跳过以收益率开头的行
                if (/^\d+\.\d{2,4}%?\s/.test(text)) {
                    return '';
                }
                
                // 跳过以代码开头的行
                if (/^\d{4,6}\s/.test(text)) {
                    return '';
                }
                
                // 查找结束标记
                const endMarkers = [
                    /\s+\d+\.\d{2,4}(?:%|行权|到期)?/,
                    /\s+\d{3,6}(?:\s|$)/,
                    /\s+出给/,
                    /\s+T\+\d/,
                    /\s+交易所/,
                    /\s+远/
                ];
                
                let minPos = text.length;
                for (let pattern of endMarkers) {
                    const match = text.match(pattern);
                    if (match) {
                        minPos = Math.min(minPos, match.index);
                    }
                }
                
                let bondName = text.substring(0, minPos).trim();
                bondName = bondName.replace(/[,，。、\s]+$/, '');
                
                if (this.isValidExtractedBondName(bondName)) {
                    return bondName;
                }
                
                return '';
            }
            
            // 验证标准模式匹配的债券名称是否有效
            isValidBondNameMatch(match, fullText) {
                if (!this.isValidExtractedBondName(match)) return false;
                
                // 额外检查：确保匹配的内容不是收益率的一部分
                const matchIndex = fullText.indexOf(match);
                if (matchIndex === -1) return false;
                
                // 检查匹配文本前面是否有收益率数字
                const beforeMatch = fullText.substring(0, matchIndex);
                if (/\d+\.\d+\s*$/.test(beforeMatch)) {
                    // 如果前面紧跟数字，很可能是收益率的一部分，如"1.88行权"
                    return false;
                }
                
                // 检查是否在收益率语境中
                const aroundMatch = fullText.substring(Math.max(0, matchIndex - 10), matchIndex + match.length + 10);
                if (/\d+\.\d+\s*行权|\d+\.\d+\s*到期/.test(aroundMatch)) {
                    return false;
                }

                // 额外排除：出现在“出给”或“【请求】”之后的匹配不应作为债券名称
                const giveIdx = fullText.indexOf('出给');
                if (giveIdx !== -1 && matchIndex > giveIdx) return false;
                const reqIdx = fullText.indexOf('【请求】');
                if (reqIdx !== -1 && matchIndex > reqIdx) return false;
                
                return true;
            }
            
            isValidExtractedBondName(bondName) {
                // 验证提取的债券名称是否有效
                if (!bondName || bondName.length < 2) {
                    return false;
                }
                
                if (/^\d+$/.test(bondName)) {
                    return false;
                }
                
                const hasEnglish = /[A-Z]/.test(bondName);
                if (hasEnglish) {
                    const chineseChars = bondName.match(/[\u4e00-\u9fa5]/g);
                    if (!chineseChars || chineseChars.length < 1) {
                        return false;
                    }
                } else {
                    const chineseChars = bondName.match(/[\u4e00-\u9fa5]/g);
                    if (!chineseChars || chineseChars.length < 2) {
                        return false;
                    }
                }
                
                // 无效的开头模式
                const invalidPatterns = [
                    /^行权/, /^到期/, /^出给/,
                    /^\d+\.\d+$/, /^\d+$/,
                    /^\d+行权$/, /^\d+到期$/, // 排除"88行权"、"90到期"等收益率相关文本
                    /^AAA?[+-]?(?:spc)?$/, // 排除评级如"AAAspc"
                ];
                
                for (let pattern of invalidPatterns) {
                    if (pattern.test(bondName)) {
                        return false;
                    }
                }
                
                // 金融机构名称不是债券名称
                const financialInstitutions = [
                    '华夏基金', '华夏银行', '华福证券', '申港证券', '平安理财', '中银理财',
                    '长城证券', '国泰君安', '中信证券', '海通证券', '招商证券', '广发证券'
                ];
                
                if (financialInstitutions.includes(bondName)) {
                    return false;
                }

                // 进一步排除：交易场所关键词不应出现在债券名称中
                const invalidKeywords = ['交易所'];
                for (const kw of invalidKeywords) {
                    if (bondName.includes(kw)) {
                        return false;
                    }
                }
                
                // 排除信托产品和资管产品名称（关键修复）
                const trustProductPatterns = [
                    /.*信托.*\d+号/,              // 如"外贸信托臻今60号"
                    /.*信托.*计划/,               // 信托计划
                    /.*集合.*计划/,               // 集合计划
                    /.*资管.*计划/,               // 资管计划
                    /.*金穗\d+号?/,               // 金穗系列
                    /.*专户.*\d+号/               // 专户产品
                ];
                
                for (const pattern of trustProductPatterns) {
                    if (pattern.test(bondName)) {
                        return false;
                    }
                }
                
                return true;
            }

            parseVolume(text) {
                // 将解析范围收敛到当前行，避免跨行把其他指令的数量误判进来
                if (text && (text.includes('\n') || text.includes('\r'))) {
                    try {
                        let narrowed = '';
                        const dirRe = /(买入|卖出|BID|OFR|Bid|Ofr|offer|Offer)/;
                        const m = dirRe.exec(text);
                        if (m) {
                            const idx = m.index;
                            const startNL = text.lastIndexOf('\n', idx);
                            const startCR = text.lastIndexOf('\r', idx);
                            let start = Math.max(startNL, startCR);
                            start = start < 0 ? 0 : start + 1;
                            const endNL = text.indexOf('\n', idx);
                            const endCR = text.indexOf('\r', idx);
                            let end = Math.min(endNL === -1 ? Infinity : endNL, endCR === -1 ? Infinity : endCR);
                            end = end === Infinity ? text.length : end;
                            narrowed = text.slice(start, end);
                        } else {
                            const firstLine = (text.match(/[^\r\n]+/g) || [text])[0];
                            narrowed = firstLine;
                        }
                        text = narrowed;
                    } catch (e) {}
                }

                let match;
                let volume = 0;
                
                // 优先：方向就近的数量（如 "卖出5000w" / "买入1E"），容忍方向与数字之间存在标点
                const dirNearVol = text.match(/(?:买入|卖出)\s*[:：,，\-\s]*\s*(\d+(?:\.\d+)?)\s*(kw|KW|k(?!w)|K(?!W)|w|W|万|亿|[Ee]\b)?/);
                if (dirNearVol) {
                    const num = parseFloat(dirNearVol[1]);
                    const unit = (dirNearVol[2] || '').toLowerCase();
                    if (unit === 'kw') return num * 1000; // 1kw = 1000万
                    if (unit === 'k')  return num * 1000; // 1k = 1000万（按你的规则）
                    if (unit === 'w' || unit === '万' || unit === '') return num; // 默认万
                    if (unit === '亿') return num * 10000;
                    if (/[e]/.test(unit)) return num * 10000; // 1E = 1亿 = 10000万
                }

                // 最高优先级：收益率后的数字（允许中间带方向词和单位）
                const yieldNear = text.match(/(\d+\.\d{2,4})(?:%|\s*行权|\s*到期)?\s*(?:买入|卖出)?\s*(\d+(?:\.\d+)?)(?:\s*(kw|KW|k(?!w)|K(?!W)|w|W|万|亿|[Ee]\b))?/i);
                if (yieldNear) {
                    const num = parseFloat(yieldNear[2]);
                    const unit = (yieldNear[3] || '').toLowerCase();
                    if (unit === 'kw' || unit === 'k') return num * 1000;
                    if (unit === 'w' || unit === '万' || unit === '') return num;
                    if (unit === '亿' || unit === 'e') return num * 10000;
                    if (!unit && num >= 100 && num <= 100000) return num;
                }
                
                
                // 亿格式 (需要优先于其他格式)
                match = text.match(this.patterns.volumeYi);
                if (match) {
                    volume = parseFloat(match[1]) * 10000;
                    return volume;
                }
                
                // kw格式 (千万)
                match = text.match(this.patterns.volumeKw);
                if (match) {
                    volume = parseFloat(match[1]) * 1000;
                    return volume;
                }
                
                // k格式 (千万)
                match = text.match(this.patterns.volumeK);
                if (match) {
                    volume = parseFloat(match[1]) * 1000;
                    return volume;
                }
                
                // 万格式
                match = text.match(this.patterns.volumeWan);
                if (match) {
                    volume = parseFloat(match[1]);
                    return volume;
                }
                
                // 科学计数法 E/e：行业口径常用 1E 表示 1 亿（= 10000 万）或 1000 万两种写法
                // 统一按 1E = 10000 万处理；若后接 '万' 则维持万单位不变
                let sciMatch = text.match(/(\d+(?:\.\d+)?)\s*[Ee](?:\s*万)?/g);
                if (sciMatch) {
                    const m = /(\d+(?:\.\d+)?)\s*[Ee](?:\s*(万))?/i.exec(sciMatch[0]);
                    if (m) {
                        const baseValue = parseFloat(m[1]);
                        const hasWan = !!m[2];
                        return hasWan ? baseValue * 1000 : baseValue * 10000;
                    }
                }
                
                // 特殊格式：数字+单位组合 (如：5千万、3百万)
                const specialMatch = text.match(/(\d+(?:\.\d+)?)\s*(千万|百万|十万)/);
                if (specialMatch) {
                    const num = parseFloat(specialMatch[1]);
                    const unit = specialMatch[2];
                    if (unit === '千万') {
                        return num * 1000;
                    } else if (unit === '百万') {
                        return num * 100;
                    } else if (unit === '十万') {
                        return num * 10;
                    }
                }
                
                // 纯数字（根据大小和上下文判断单位）
                // 先排除债券代码区域，避免误匹配债券代码中的数字
                let volumeMatches = [];
                const volumeRegex = new RegExp(this.patterns.volumeNumber.source, 'g');
                let volumeMatch;
                while ((volumeMatch = volumeRegex.exec(text)) !== null) {
                    volumeMatches.push({
                        value: volumeMatch[0],
                        index: volumeMatch.index
                    });
                }
                
                // 获取所有债券代码位置，排除这些区域
                const bondCodePatterns = [
                    this.patterns.codeExchange,
                    this.patterns.codeInterbank,
                    this.patterns.code8digit,
                    this.patterns.code7digit,
                    this.patterns.code6digit
                ];
                
                let bondCodeRanges = [];
                for (const pattern of bondCodePatterns) {
                    const regex = new RegExp(pattern.source, 'g');
                    let codeMatch;
                    while ((codeMatch = regex.exec(text)) !== null) {
                        bondCodeRanges.push({
                            start: codeMatch.index,
                            end: codeMatch.index + codeMatch[0].length
                        });
                    }
                }
                
                // 找到不在债券代码区域内的数字
                for (const volMatch of volumeMatches) {
                    const volStart = volMatch.index;
                    const volEnd = volStart + volMatch.value.length;
                    
                    // 检查是否与债券代码区域重叠
                    let isInBondCode = false;
                    for (const codeRange of bondCodeRanges) {
                        if ((volStart >= codeRange.start && volStart < codeRange.end) ||
                            (volEnd > codeRange.start && volEnd <= codeRange.end) ||
                            (volStart < codeRange.start && volEnd > codeRange.end)) {
                            isInBondCode = true;
                            break;
                        }
                    }
                    
                    if (!isInBondCode) {
                        const num = parseFloat(volMatch.value);
                        // 100-9999通常是万元
                        if (num >= 100 && num < 10000) {
                            return num;
                        }
                        // 10000-99999可能是十万或万
                        else if (num >= 10000 && num <= 99999) {
                            // 如果前后有价格信息，更可能是万
                            if (/\d+\.\d{2,4}/.test(text)) {
                                return num / 10000;  // 作为绝对金额处理
                            }
                            return num / 10;  // 作为十万处理
                        }
                        // 100000以上作为绝对金额（元）转换为万
                        else if (num >= 100000) {
                            return num / 10000;
                        }
                    }
                }
                
                return 0;
            }

            parseYield(text, direction='') {
                // 先将解析范围收敛到包含方向的当前行，避免跨行串扰
                if (text && (text.includes('\n') || text.includes('\r'))) {
                    try {
                        let narrowed = '';
                        if (direction) {
                            const re = direction === '买入'
                                ? /(买入|bid|BID|Bid)/
                                : /(卖出|ofr|OFR|Offer|offer)/;
                            const m = re.exec(text);
                            if (m) {
                                const idx = m.index;
                                const startNL = text.lastIndexOf('\n', idx);
                                const startCR = text.lastIndexOf('\r', idx);
                                let start = Math.max(startNL, startCR);
                                start = start < 0 ? 0 : start + 1;
                                const endNL = text.indexOf('\n', idx);
                                const endCR = text.indexOf('\r', idx);
                                let end = Math.min(endNL === -1 ? Infinity : endNL, endCR === -1 ? Infinity : endCR);
                                end = end === Infinity ? text.length : end;
                                narrowed = text.slice(start, end);
                            }
                        }
                        if (!narrowed) {
                            const firstLine = (text.match(/[^\r\n]+/g) || [text])[0];
                            narrowed = firstLine;
                        }
                        text = narrowed;
                    } catch (e) {}
                }

                // 先识别"行权/到期"并优先取其数值
                let type = '到期收益率';
                let val = null;

                // A. 方向就近：如 "2.425 卖出5000w" 或 "1.71 offer 1000"
                let near = text.match(/(\d+\.\d{2,4})\s*(?=(?:卖出|买入|ofr|offer|bid)\b)/i);
                if (!near) near = text.match(/(?:(?:卖出|买入|ofr|offer|bid)\b)[^\d]{0,6}(\d+\.\d{2,4})/i);
                if (near) {
                    val = parseFloat(near[1]);
                }

                const exerciseMatch = !val && text.match(/(\d+\.\d{2,4})\s*行权/);
                const maturityMatch = !val && text.match(/(\d+\.\d{2,4})\s*到期/);
                if (exerciseMatch) {
                    type = '行权收益率';
                    val = parseFloat(exerciseMatch[1]);
                } else if (maturityMatch) {
                    type = '到期收益率';
                    val = parseFloat(maturityMatch[1]);
                } else {
                    // 双边价：x/y 或 bid x / ofr y
                    const pair = !val && text.match(/(\d+\.\d{2,4})\s*\/\s*(\d+\.\d{2,4})/);
                    const bidOfr = !val && text.match(/bid\s*(\d+\.\d{2,4}).*?(?:ofr|offer|ask)\s*(\d+\.\d{2,4})/i);
                    if (pair || bidOfr) {
                        const a = parseFloat(pair ? pair[1] : bidOfr[1]);
                        const b = parseFloat(pair ? pair[2] : bidOfr[2]);
                        if (direction === '买入') val = b;        // 取对手卖价
                        else if (direction === '卖出') val = a;   // 取对手买价
                        else val = a; // 未知方向，先取bid（更保守）
                    }

                    // 单价兜底（排除日期/净价/全价/期限）
                    if (val == null) {
                        const best = this.extractBestYield(text); // 该函数已有合理范围与排除逻辑
                        if (best) {
                            val = parseFloat(best.replace('%',''));
                            try { result.备注 = (result.备注?result.备注+'; ':'') + '收益率来源:兜底'; } catch(e){}
                        }
                    }
                }

                if (val == null) return { value: '', type };

                // 合理性校验（0.1%~20%）
                if (val < 0.1 || val > 20) return { value: '', type };

                return { value: val.toFixed(4) + '%', type };
            }
            
            extractBestYield(text) {
                // 提取最佳收益率（包含合理性检查）
                // 排除后随期限符号 Y/D
                // 放宽后瞻，允许后面紧跟数量标记如 1E、1kw，不将其排除
                const yieldPattern = /(\d+\.\d{2,4})(?:\s*%)?(?!\s*[YD])(?!\s*[\/]|\s*\d{1,2}[\.\-]\d{1,2})/g;
                
                const yields = [];
                let match;
                
                while ((match = yieldPattern.exec(text)) !== null) {
                    const yieldValue = match[1];
                    try {
                        const floatValue = parseFloat(yieldValue);
                        // 合理的收益率范围：0.5% - 20.0%
                        if (floatValue >= 0.5 && floatValue <= 20.0) {
                            // 排除日期格式 (如12.25)
                            if (!this.isDateFormat(yieldValue.replace('.', ''))) {
                                yields.push({
                                    value: yieldValue,
                                    position: match.index
                                });
                            }
                        }
                    } catch (error) {
                        continue;
                    }
                }
                
                if (yields.length > 0) {
                    // 返回带%符号的收益率字符串（按清洁版.py逻辑）
                    return parseFloat(yields[0].value).toFixed(4) + "%";
                }
                
                return null;
            }
            
            isDateFormat(dateStr) {
                // 检查是否为日期格式
                if (dateStr.length === 4) {
                    const month = parseInt(dateStr.substring(0, 2));
                    const day = parseInt(dateStr.substring(2, 4));
                    return (month >= 1 && month <= 12) && (day >= 1 && day <= 31);
                }
                return false;
            }
            parseDate(text) {
                const today = new Date();
                
                if (this.patterns.dateToday.test(text)) {
                    return '';
                }
                
                if (this.patterns.dateTomorrow.test(text)) {
                    const tomorrow = new Date(today);
                    tomorrow.setDate(tomorrow.getDate() + 1);
                    return tomorrow.toISOString().split('T')[0];
                }
                
                // 1. 复合日期格式 (+1/MM.DD+2)
                const compoundDate = this.extractCompoundDate(text);
                if (compoundDate) {
                    return compoundDate;
                }
                
                // 2. 带清算的日期格式 (MMDD+1)
                const dateWithSettlement = this.extractDateWithSettlement(text);
                if (dateWithSettlement) {
                    const { month, day } = dateWithSettlement;
                    const year = this.determineYear(month, today.getMonth() + 1, today.getFullYear());
                    const monthStr = String(month).padStart(2, '0');
                    const dayStr = String(day).padStart(2, '0');
                    return `${year}-${monthStr}-${dayStr}`;
                }
                
                // 3. 尝试多种日期格式
                const datePatterns = [
                    this.patterns.dateMD,     // MM.DD 或 MM/DD
                    this.patterns.dateDot,     // MM.DD
                    this.patterns.dateDash,    // MM-DD
                    this.patterns.date4digit   // MMDD
                ];
                
                for (let pattern of datePatterns) {
                    const match = text.match(pattern);
                    if (match && match[1] && match[2]) {
                        const year = today.getFullYear();
                        const month = String(match[1]).padStart(2, '0');
                        const day = String(match[2]).padStart(2, '0');
                        
                        // 验证日期合法性
                        const monthNum = parseInt(month);
                        const dayNum = parseInt(day);
                        if (monthNum >= 1 && monthNum <= 12 && dayNum >= 1 && dayNum <= 31) {
                            return `${year}-${month}-${day}`;
                        }
                    }
                }
                
                return '';
            }
            
            extractCompoundDate(text) {
                // 提取复合日期格式 (+1/MM.DD+2)
                const compoundPattern = /\+(\d+)\/(\d{2})\.(\d{2})\+(\d+)/;
                const match = text.match(compoundPattern);
                if (!match) return '';
                
                const firstOffset = parseInt(match[1]);
                const month = parseInt(match[2]);
                const day = parseInt(match[3]);
                const secondOffset = parseInt(match[4]);
                
                if (!this.isValidDate(month, day)) return '';
                
                const today = new Date();
                const currentYear = today.getFullYear();
                const currentMonth = today.getMonth() + 1;
                const year = this.determineYear(month, currentMonth, currentYear);
                
                try {
                    const baseDate = new Date(year, month - 1, day);
                    
                    // 根据"出给"和"平安理财"的位置确定结算天数
                    const giveToPos = text.indexOf('出给');
                    const pingianPos = text.indexOf('平安理财');
                    
                    let ourSettlementDays;
                    if (giveToPos !== -1 && pingianPos !== -1) {
                        ourSettlementDays = pingianPos < giveToPos ? firstOffset : secondOffset;
                    } else {
                        ourSettlementDays = firstOffset;
                    }
                    
                    const ourDate = new Date(baseDate.getTime() - ourSettlementDays * 24 * 60 * 60 * 1000);
                    return ourDate.toISOString().split('T')[0];
                } catch (error) {
                    return '';
                }
            }
            
            extractDateWithSettlement(text) {
                // 提取带清算信息的日期格式
                const patterns = [
                    /(\d{2})(\d{2})\+\d+/,       // MMDD+1
                    /(\d{2})\.(\d{2})\+\d+/,     // MM.DD+1
                    /(\d{1,2})\/(\d{2})\+\d+/    // M/DD+1
                ];
                
                for (let pattern of patterns) {
                    const match = text.match(pattern);
                    if (match) {
                        const month = parseInt(match[1]);
                        const day = parseInt(match[2]);
                        if (this.isValidDate(month, day)) {
                            return { month, day };
                        }
                    }
                }
                return null;
            }
            
            isValidDate(month, day) {
                return month >= 1 && month <= 12 && day >= 1 && day <= 31;
            }
            
            determineYear(month, currentMonth, currentYear) {
                // 简单的年份判断逻辑
                if (month < currentMonth - 6) {
                    return currentYear + 1;
                } else if (month > currentMonth + 6) {
                    return currentYear - 1;
                } else {
                    return currentYear;
                }
            }
            
            parseTerm(text) {
                // 提取期限信息
                let termInfo = '';
                
                // 检查复合期限 (如：2.98Y + 5Y)
                const complexMatch = text.match(this.patterns.termComplex);
                if (complexMatch) {
                    return complexMatch[0];
                }
                
                // 检查单一期限 (如：2.98Y, 93D)
                const singleMatch = text.match(this.patterns.termSingle);
                if (singleMatch) {
                    termInfo = singleMatch[0];
                    
                    // 检查是否有特殊标记 (+N)
                    const specialMatch = text.match(this.patterns.termSpecial);
                    if (specialMatch) {
                        termInfo += ' ' + specialMatch[0];
                    }
                    
                    return termInfo;
                }
                
                // 尝试从行首提取期限
                const lineStartMatch = text.match(/^(\d+(?:\.\d+)?[YD])/);
                if (lineStartMatch) {
                    return lineStartMatch[1];
                }
                
                return '';
            }
            
            parseSettlement(text) {
                // 提取清算速度信息
                if (!text) return 'T+0';
                
                const settlementInfo = this.extractSettlementInfo(text);
                return settlementInfo.speed || 'T+0';
            }
            
            extractSettlementInfo(text) {
                // 提取清算速度和交易场所（返回对象）
                if (!text) {
                    return { speed: '', venue: '' };
                }
                
                try {
                    // 先处理“+0/+1”双边清算写法（可带或不带日期，如“08.19+0/+1 平安理财 出给 招商银行”）
                    const dualSettle = text.match(/(?:\d{1,2}[.\-\/]\d{1,2})?\s*\+\s*(\d+)\s*\/\s*\+\s*(\d+)/);
                    if (dualSettle) {
                        const leftOffset  = parseInt(dualSettle[1]);
                        const rightOffset = parseInt(dualSettle[2]);
                        const giveToPos   = text.indexOf('出给');
                        const pinganPos   = text.indexOf('平安理财');
                        let ours = leftOffset;
                        if (giveToPos !== -1 && pinganPos !== -1) {
                            // 平安理财在“出给”左侧⇒取左边偏移；在右侧⇒取右边偏移
                            ours = (pinganPos < giveToPos) ? leftOffset : rightOffset;
                        }
                        return { speed: `T+${isFinite(ours)?ours:0}`, venue: '银行间' };
                    }
                    // 交易所优先判断
                    if (this.patterns.settlementExchange.test(text)) {
                        return { speed: 'T+0', venue: '交易所' };
                    }
                    
                    // 远期判断
                    if (this.patterns.settlementRemote.test(text)) {
                        return { speed: '远期', venue: '银行间' };
                    }
                    
                    // 检查T+0和T+1的位置
                    const t0Matches = Array.from(text.matchAll(this.patterns.settlementT0));
                    const t1Matches = Array.from(text.matchAll(this.patterns.settlementT1));
                    
                    const lastT0Pos = t0Matches.length > 0 ? t0Matches[t0Matches.length - 1].index : -1;
                    const lastT1Pos = t1Matches.length > 0 ? t1Matches[t1Matches.length - 1].index : -1;
                    
                    if (lastT0Pos >= 0 && lastT1Pos >= 0) {
                        // 取位置更靠后的
                        if (lastT1Pos > lastT0Pos) {
                            return { speed: 'T+1', venue: '银行间' };
                        } else {
                            return { speed: 'T+0', venue: '银行间' };
                        }
                    } else if (lastT1Pos >= 0) {
                        return { speed: 'T+1', venue: '银行间' };
                    } else if (lastT0Pos >= 0) {
                        return { speed: 'T+0', venue: '银行间' };
                    }
                    
                    return { speed: '', venue: '' };
                } catch (error) {
                    return { speed: '', venue: '' };
                }
            }
            
            extractPrices(text) {
                // 提取价格信息（净价、全价）
                if (!text) return { netPrice: '', fullPrice: '' };
                
                let netPrice = '';
                let fullPrice = '';
                
                const netMatch = text.match(/净价[：:]\s*(\d+(?:\.\d+)?)/);
                if (netMatch) {
                    netPrice = netMatch[1];
                }
                
                const fullMatch = text.match(/全价[：:]\s*(\d+(?:\.\d+)?)/);
                if (fullMatch) {
                    fullPrice = fullMatch[1];
                }
                
                return { netPrice, fullPrice };
            }
            
            // 机构名规范化，去除星号/尾缀干扰，并统一空白（保留括号内分支信息）
            normalizeInstitutionName(name) {
                if (!name) return '';
                let n = String(name).trim();
                // 去除星号（保留括号内容）
                n = n.replace(/[＊*]/g, '');
                // 去除结尾的无关词
                n = n.replace(/(?:部|总部|金市部|营业部)$/, '');
                // 合并空白
                n = n.replace(/\s+/g, '');
                // 简称标准化（在缺少常见后缀时进行）
                if (!/[银行证券基金理财信托资管保险]/.test(n)) {
                    const aliasMap = {
                        '交行': '交通银行',
                        '招行': '招商银行',
                        '中行': '中国银行',
                        '建行': '建设银行',
                        '工行': '工商银行',
                        '农行': '农业银行',
                        '兴业': '兴业银行',
                        '华泰': '华泰证券',
                        '中信': '中信证券',
                        '国都': '国都证券',
                        '东方': '东方证券',
                        '国信': '国信证券',
                        '华林': '华林证券',
                        '华创': '华创证券'
                    };
                    if (aliasMap[n]) n = aliasMap[n];
                }
                return n;
            }
            
            parseCounterparty(text) {
                // 重要：这个方法要精确解析交易结构
                const result = {
                    direction: '',          // 交易方向
                    counterparty: '',       // 对手方（兼容旧字段）
                    terminalInstitution: '', // 终端机构名称（新增）
                    marketMaker: '',        // 做市商机构名称（新增）
                    intermediary: '',       // 中介（如【国利】）
                    intermediarySeq: '',    // 原中介编号
                    counterpartyTrader: '', // 对手交易员（新增）
                    orderMethod: '',        // 发单方式（新增）
                    accountName: ''         // 户名（新增）
                };
                
                if (!text) return result;
                
                // 步骤1：提取中介标识和序号
                // 匹配【国利】、【国际】等
                const intMatch = text.match(/【([^】]+)】/);
                if (intMatch) {
                    const source = (intMatch[1] || '').trim();
                    const excluded = new Set(['请求', '备注', '注释', '说明', '补充', '提示']);
                    let mapped = source;
                    try {
                        if (typeof this._mapIntermediaryName === 'function') {
                            mapped = this._mapIntermediaryName(source) || '';
                        }
                    } catch (e) {
                        // ignore mapping errors
                    }
                    if (mapped && !excluded.has(mapped)) {
                        result.intermediary = mapped;
                    }
                }
                // 兼容无前导“【”的格式：如 "国利】1) ..."
                if (!result.intermediary) {
                    const looseMatch = text.match(/^\s*([^\s【】]{1,12})】/);
                    if (looseMatch) {
                        const source = (looseMatch[1] || '').trim();
                        const excluded = new Set(['请求', '备注', '注释', '说明', '补充', '提示']);
                        let mapped = source;
                        try {
                            if (typeof this._mapIntermediaryName === 'function') {
                                mapped = this._mapIntermediaryName(source) || '';
                            }
                        } catch (e) {}
                        if (mapped && !excluded.has(mapped)) {
                            result.intermediary = mapped;
                        }
                    }
                }
                
                // 提取原中介编号（支持多种格式）
                const seqPatterns = [
                    /【[^】]+】\s*(\d+)\s*[)）]/,  // 【国利】1)
                    /^\s*(\d+)\s*[)）]/,           // 行首的 1)
                    /^.*?(\d+)\s*[)）]/            // 任意位置的第一个 数字)
                ];
                
                for (const pattern of seqPatterns) {
                    const seqMatch = text.match(pattern);
                    if (seqMatch) {
                        result.intermediarySeq = seqMatch[1];
                        break;
                    }
                }
                
                // 步骤2：解析交易方向和机构（重构版）
                // 查找"出给"结构
                const giveToMatch = text.match(/(.+?)\s+出给\s+(.+?)(?:[,，]|【|$)/);
                
                if (giveToMatch) {
                    // 更稳健的机构提取：使用"出给"前后的专用提取器
                    const beforeText = giveToMatch[1] || '';
                    const afterText  = giveToMatch[2] || '';
                    let party1 = this._extractInstitutionNameBefore(beforeText) || this.normalizeInstitutionName(beforeText);
                    let party2 = this._extractInstitutionNameAfter(afterText)  || this.normalizeInstitutionName(afterText);
                    
                    // 特殊处理：若明确标注“机构待定/待确认”，优先作为终端机构占位
                    if (/(机构待定|待定|待确认|TBD|待通知)/.test(beforeText)) {
                        party1 = '机构待定';
                    }
                    
                    // 判断方向（站在平安理财角度）
                    if (party1.includes('平安理财')) {
                        result.direction = '卖出';
                        result.terminalInstitution = party2;  // party2是终端机构
                        result.counterparty = party2;  // 兼容旧字段
                    } else if (party2.includes('平安理财')) {
                        result.direction = '买入';
                        result.terminalInstitution = party1;  // party1是终端机构
                        result.counterparty = party1;  // 兼容旧字段
                    } else {
                        // 如果没有平安理财，根据上下文判断
                        const hasBuy = text.includes('买入');
                        const hasSell = text.includes('卖出');
                        result.direction = hasSell ? '卖出' : (hasBuy ? '买入' : '');
                        result.terminalInstitution = hasSell ? party2 : party1;
                        result.counterparty = result.terminalInstitution;
                    }
                    
                    // 步骤3：提取做市商机构和交易员
                    // 获取"出给"之后的内容
                    const afterGiveToIdx = text.indexOf('出给');
                    if (afterGiveToIdx > -1) {
                        const afterContent = text.substring(afterGiveToIdx + 2);
                        
                        // 提取做市商机构（从"发XXX"中）- 改进版
                        const marketMakerPatterns = [
                            /【请求】[^【】]*发\s*([^\s,，\*]+?(?:证券|银行|基金|理财|信托|资管|保险|公司|投顾)(?:[\(（][^\)）]*[\)）])?)/,  // 【请求】发XXX证券(分支)
                            /请求\s*发\s*([^\s,，\*]+?(?:证券|银行|基金|理财|信托|资管|保险|公司|投顾)(?:[\(（][^\)）]*[\)）])?)/,      // 请求发XXX（无方括号）
                            /【请求】[^【】]*发\s*([^\s,，\*]+)/,  // 【请求】发XXX
                            /请求\s*发\s*([^\s,，\*]+)/,          // 请求发XXX（无方括号）
                            /[,，]\s*发\s*([^\s,，\*]+?(?:证券|银行|基金|理财|信托|资管|保险|公司|投顾)(?:[\(（][^\)）]*[\)）])?)/,  // ,发XXX证券(分支)
                            /[,，]\s*发\s*([^\s,，\*]+)/,  // ,发XXX
                            /双方发\s*([^\s,，\*]+?(?:证券|银行|基金|理财|信托|资管|保险|公司|投顾)(?:[\(（][^\)）]*[\)）])?)/,       // 双方发XXX证券(分支)
                            /双方发\s*([^\s,，\*]+)/       // 双方发XXX
                        ];
                        
                        for (const pattern of marketMakerPatterns) {
                            const mmMatch = afterContent.match(pattern);
                            if (mmMatch) {
                                // 第一个捕获组是机构名
                                let makerName = this.normalizeInstitutionName(mmMatch[1]);
                                // 确保不是"请求"这样的词，且长度合理
                                if (makerName && makerName !== '请求' && makerName.length >= 2 && makerName.length <= 20) {
                                    const score = /证券/.test(makerName) ? 3 : (/银行|理财|基金/.test(makerName) ? 2 : 1);
                                    const currentScore = result.marketMaker ? (/证券/.test(result.marketMaker) ? 3 : (/银行|理财|基金/.test(result.marketMaker) ? 2 : 1)) : 0;
                                    if (score >= currentScore) {
                                        result.marketMaker = makerName;
                                    }
                                }
                                
                                // 判断发单方式
                                if (mmMatch[0].includes('【请求】')) {
                                    result.orderMethod = '请求';
                                } else if (mmMatch[0].includes('双方发')) {
                                    result.orderMethod = '双方发';
                                } else {
                                    result.orderMethod = '发';
                                }
                                
                                // 尝试在"发XXX"后面找到交易员姓名
                                const afterMaker = afterContent.substring(mmMatch.index + mmMatch[0].length);
                                const traderMatch = afterMaker.match(/^\s*([\u4e00-\u9fa5]{2,4})(?:\s|,|，|$)/);
                                if (traderMatch) {
                                    result.counterpartyTrader = traderMatch[1];
                                }
                                break;
                            }
                        }
                        
                        // 如果没有找到做市商，尝试"固收联系"模式
                        if (!result.marketMaker) {
                            const gushouPatterns = [
                                /固收联系([^\s,，]+(?:证券|银行|基金|信托|保险|资管|公司|投顾)(?:\([^)]*\))?)/,
                                /固收联系([^\s,，]+)/
                            ];
                            
                            for (const pattern of gushouPatterns) {
                                const gushouMatch = afterContent.match(pattern);
                                if (gushouMatch) {
                                    const makerName = this.normalizeInstitutionName(gushouMatch[1]);
                                    if (makerName && makerName.length >= 2 && makerName.length <= 20) {
                                        const score = /证券/.test(makerName) ? 3 : (/银行|理财|基金/.test(makerName) ? 2 : 1);
                                        const currentScore = result.marketMaker ? (/证券/.test(result.marketMaker) ? 3 : (/银行|理财|基金/.test(result.marketMaker) ? 2 : 1)) : 0;
                                        if (score >= currentScore) {
                                            result.marketMaker = makerName;
                                        }
                                        result.orderMethod = '固收联系';
                                break;
                                    }
                                }
                            }
                        }
                        
                        // 如果没有找到交易员，尝试其他模式
                        if (!result.counterpartyTrader) {
                            // 查找"发XXX 姓名"格式
                            const traderMatch = afterContent.match(/发\s*[^,，]+\s+([\u4e00-\u9fa5]{2,4})(?:\s|,|，|$)/);
                            if (traderMatch) {
                                result.counterpartyTrader = traderMatch[1];
                            }
                            
                            // 查找"固收联系XXX 姓名"格式
                            if (!result.counterpartyTrader) {
                                const gushouTraderMatch = afterContent.match(/固收联系[^\s,，]+\s+([\u4e00-\u9fa5]{2,4})(?:\s|,|，|$)/);
                                if (gushouTraderMatch) {
                                    result.counterpartyTrader = gushouTraderMatch[1];
                                }
                            }
                        }
                    }
                } else {
                    // 没有"出给"结构，尝试简单判断
                    if (text.includes('买入')) result.direction = '买入';
                    else if (text.includes('卖出')) result.direction = '卖出';
                }
                
                // 确保counterparty字段不为空
                if (!result.counterparty && result.terminalInstitution) {
                    result.counterparty = result.terminalInstitution;
                }
                
                // 提取户名（产品名称）
                result.accountName = this.extractAccountName(text);
                
                return result;
            }
            
            isInstitutionName(text) {
                // 判断是否为机构名称
                const institutionKeywords = [
                    '证券', '银行', '基金', '保险', '信托', '资管', '资产', 
                    '投资', '金融', '财富', '资本', '控股', '集团', '公司'
                ];
                
                return institutionKeywords.some(keyword => text.includes(keyword));
            }
            
            isValidInstitutionName(text) {
                // 验证是否为有效的机构名称（按清洁版.py逻辑）
                if (!text || text.length < 2) return false;
                
                const institutionSuffixes = [
                    '银行', '证券', '基金', '理财', '信托', '资管', '保险',
                    '农商', '农商行', '农信社', '农合行', '公司', '集团', '投资', '资产', '养老'
                ];
                
                return institutionSuffixes.some(suffix => text.includes(suffix));
            }
            
            extractInstitutionNameBefore(text) {
                // 从"出给"前的文本中提取机构名称（按清洁版.py逻辑）
                if (!text) return "";
                
                // 去掉开头的标记和序号
                text = text.replace(/^【[^】]+】\d+\)/, '').trim();
                text = text.replace(/^\d+[【。]/, '').trim();
                
                const words = [];
                for (let word of text.trim().split(/\s+/)) {
                    if (/^(明天|今天|后天|\d{2}\.\d{2})[+\-]\d+$/.test(word)) continue;
                    if (/^\d+\.?\d*$/.test(word)) continue;
                    if (['买入', '卖出'].includes(word)) continue;
                    words.push(word);
                }
                
                if (words.length === 0) return "";
                
                const institutionSuffixes = [
                    '银行', '证券', '基金', '理财', '信托', '资管', '保险',
                    '农商', '农商行', '农信社', '农合行', '公司', '集团', '投资', '资产', '养老'
                ];
                
                // 从后往前查找包含机构后缀的词
                for (let i = words.length - 1; i >= 0; i--) {
                    const word = words[i];
                    const cleanWord = word.replace(/\([^)]*\)/, '').trim();
                    if (!cleanWord) continue;
                    // 跳过疑似债券名称的词（如“25民生银行二级资本债01”等）
                    if (/^\d{2}/.test(cleanWord)) continue;
                    if (/(债|票据|MTN|SCP|PPN|CD)/i.test(cleanWord)) continue;
                    
                    for (let suffix of institutionSuffixes) {
                        if (cleanWord.endsWith(suffix) && cleanWord.length >= suffix.length + 1) {
                            return cleanWord;
                        }
                    }
                }
                
                // 查找有效候选词
                const validCandidates = [];
                for (let i = words.length - 1; i >= 0; i--) {
                    const word = words[i];
                    const cleanWord = word.replace(/\([^)]*\)/, '').trim();
                    if (cleanWord.length < 2) continue;
                    
                    if (/^(\d+[YD]|买入|卖出|行权|到期|\d+\.\d+|\d+\.\d+到期)$/.test(cleanWord)) continue;
                    if (cleanWord.length === 2 && this.isLikelyPersonName(cleanWord)) continue;
                    if (/^\d{2}/.test(cleanWord) && !/[\u4e00-\u9fa5]/.test(cleanWord.substring(2))) continue;
                    // 排除包含明显债券关键词/格式的候选
                    if (/^\d{2}/.test(cleanWord)) continue;
                    if (/(债|票据|MTN|SCP|PPN|CD)/i.test(cleanWord)) continue;
                    
                    validCandidates.push(cleanWord);
                }
                
                return validCandidates.length > 0 ? validCandidates[0] : "";
            }
            
            extractInstitutionNameAfter(text) {
                // 从"出给"后的文本中提取机构名称（按清洁版.py逻辑）
                if (!text) return "";
                
                // 去掉【请求】等标记内容
                const requestPos = text.indexOf("【请求】");
                if (requestPos !== -1) {
                    text = text.substring(0, requestPos).trim();
                }
                
                // 去掉逗号后面的内容
                text = text.replace(/[,，].*$/, '').trim();
                
                // 查找机构模式
                const institutionPattern = /([\u4e00-\u9fa5]+(?:银行|证券|基金|理财|信托|资管|保险|农商行|农商|农信社|农合行))/;
                let match = text.match(institutionPattern);
                if (match) {
                    return match[1].trim();
                }
                
                // 查找中文模式
                const chinesePattern = /^([^\d+\-/\s,，]{2,}?)/;
                match = text.match(chinesePattern);
                if (match) {
                    const candidate = match[1].trim();
                    if (!/^(\d+[YD]|买入|卖出|行权|到期|\d+\.\d+|\d+\.\d+到期)$/.test(candidate)) {
                        return candidate;
                    }
                }
                
                return "";
            }
            
            isLikelyPersonName(text) {
                // 判断是否可能是人名（按清洁版.py逻辑）
                if (text.length === 2) {
                    const commonSurnames = [
                        '李', '王', '张', '刘', '陈', '杨', '赵', '黄', '周', '吴',
                        '徐', '孙', '胡', '朱', '高', '林', '何', '郭', '马', '罗',
                        '梁', '宋', '郑', '谢', '韩', '唐', '冯', '于', '董', '萧'
                    ];
                    return commonSurnames.includes(text[0]);
                }
                return false;
            }
            
            parseYieldType(text) {
                // 提取收益率类型
                if (!text) return '';
                
                if (text.includes('行权')) {
                    return '行权收益率';
                }
                
                if (text.includes('到期')) {
                    return '到期收益率';
                }
                
                // 检查是否有双边报价
                const bidOfferMatch = text.match(this.patterns.bidOfferPair);
                if (bidOfferMatch) {
                    return '双边报价';
                }
                
                // 默认为到期收益率
                return this.parseYield(text).value ? '到期收益率' : '';
            }
            parseRemarks(text) {
                // 提取备注信息
                const remarks = [];
                
                // 确保text存在
                if (!text) return '';
                
                // 提取期限备注
                const termMatch = text.match(/\+\s*N\([^)]*\)/);
                if (termMatch) {
                    remarks.push(termMatch[0]);
                }
                
                
                // 提取双边报价信息
                const bidOfferMatch = text.match(this.patterns.bidOfferPair);
                if (bidOfferMatch) {
                    remarks.push(`双边报价：${bidOfferMatch[0]}`);
                }
                
                // 提取带星号的收益率
                const starYieldMatch = text.match(this.patterns.yieldWithStar);
                if (starYieldMatch) {
                    remarks.push(`参考收益率：${starYieldMatch[0]}`);
                }
                
                // 提取【请求】信息
                const requestMatch = text.match(/【请求】([^【】]+)(?=【|$)/);
                if (requestMatch) {
                    remarks.push(`请求：${requestMatch[1].trim()}`);
                }

                // 提取中债估值与成交价只读信息（不影响收益率）
                const valMatch = text.match(/中债估值[:：]\s*([\d\.]+)/);
                if (valMatch) {
                    remarks.push(`中债估值:${valMatch[1]}`);
                }
                const dealPxMatch = text.match(/成交价\s*[-:：]+\s*([\d\.]+)/);
                if (dealPxMatch) {
                    remarks.push(`成交价:${dealPxMatch[1]}`);
                }
                
                // 提取费用信息
                const feeInfo = this.parseFeeInfo(text);
                if (feeInfo) {
                    remarks.push(feeInfo);
                }
                
                // 提取产品信息
                const productInfo = this.parseProductInfo(text);
                if (productInfo) {
                    remarks.push(`产品：${productInfo}`);
                }
                
                // 提取括号内的备注
                const parenthesesMatch = text.match(/\([^)]+\)/g);
                if (parenthesesMatch) {
                    parenthesesMatch.forEach(match => {
                        if (!match.includes('+N') && !remarks.includes(match)) {
                            const content = match.substring(1, match.length - 1);
                            // 过滤已经提取的信息
                            if (!remarks.some(r => r.includes(content))) {
                                remarks.push(content);
                            }
                        }
                    });
                }
                
                return remarks.join('; ');
            }
            
            parseFeeInfo(text) {
                // 提取费用信息
                if (!text) return '';
                
                const feePatterns = [
                    /留\s*(\d*)\s*厘/,
                    /(\d+厘)/,
                    /几厘/,
                    /费用[：:]\s*(\d+(?:\.\d+)?%?)/
                ];
                
                for (let pattern of feePatterns) {
                    const match = text.match(pattern);
                    if (match) {
                        return `费用：${match[0]}`;
                    }
                }
                
                return '';
            }
            
            parseProductInfo(text) {
                // 提取产品信息（增强支持更多产品名称格式）
                if (!text) return '';
                
                const productPatterns = [
                    /([^,，\s]*信托[^,，\s]*)/,
                    /([^,，\s]*集合资产管理计划[^,，\s]*)/,
                    /([^,，\s]*资管[^,，\s]*)/,
                    /([^,，\s]*金穗\d+号?)/,
                    /([^,，\s]*理财产品[^,，\s]*)/,
                    // 新增：支持"XX安盛XX号"等格式
                    /([\u4e00-\u9fa5]+安盛[\u4e00-\u9fa5\d]*号)/,
                    // 新增：支持以"号"结尾的产品名称（至少4个字符）
                    /([\u4e00-\u9fa5]{4,}号)/,
                    // 新增：支持特定的基金/产品名称模式
                    /([\u4e00-\u9fa5]+合信[\u4e00-\u9fa5\d]*号?)/,
                    /([\u4e00-\u9fa5]+专项[\u4e00-\u9fa5\d]*)/,
                    /([\u4e00-\u9fa5]+计划[\u4e00-\u9fa5\d]*号?)/
                ];
                
                for (let pattern of productPatterns) {
                    const matches = text.match(pattern);
                    if (matches && matches[1]) {
                        const product = matches[1].trim();
                        if (product && product.length > 2) {
                            return product;
                        }
                    }
                }
                
                return '';
            }
            
            parseAccountName(text) {
                // 旧接口做别名，统一走增强版
                return this.extractAccountName(text);
            }
            
            _extractAccountFromSegment(segment) {
                // 从文本片段中精确提取账户名称
                if (!segment) return { name: '', confidence: 0 };
                
                // 处理逗号分隔的复杂结构
                const parts = segment.split(/[,，]/);
                let bestMatch = { name: '', confidence: 0 };
                
                // 从后往前搜索，优先选择包含产品关键词的部分
                for (let i = parts.length - 1; i >= 0; i--) {
                    const part = parts[i].trim();
                    if (!part) continue;
                    
                    const result = this._analyzeAccountNameCandidate(part);
                    if (result.confidence > bestMatch.confidence) {
                        bestMatch = result;
                    }
                }
                
                // 如果没有找到高质量匹配，尝试完整片段
                if (bestMatch.confidence < 8) {
                    const wholeResult = this._analyzeAccountNameCandidate(segment);
                    if (wholeResult.confidence > bestMatch.confidence) {
                        bestMatch = wholeResult;
                    }
                }
                
                return bestMatch;
            }
            
            _analyzeAccountNameCandidate(candidate) {
                // 分析候选账户名称的质量和可信度
                if (!candidate || candidate.length < 3) {
                    return { name: '', confidence: 0 };
                }
                
                let confidence = 0;
                let cleanName = candidate.trim();
                
                // 高质量模式：包含明确的产品标识符
                const highQualityPatterns = [
                    { pattern: /([^\s]+信托[^\s]*?\d+号)/i, points: 15 },  // "外贸信托臻今60号"
                    { pattern: /([^\s]+集合[^\s]*?计划)/i, points: 14 },   // "XX集合资产管理计划"
                    { pattern: /([^\s]+资管[^\s]*?计划)/i, points: 13 },   // "XX资管计划"
                    { pattern: /([^\s]*金穗\d+号?)/i, points: 12 },        // "金穗10号"
                    { pattern: /([^\s]+安盛[^\s]*?\d+号)/i, points: 12 },  // "创金合信安盛1号"
                    { pattern: /([^\s]+专项[^\s]*?债)/i, points: 11 },     // "XX专项债"
                    { pattern: /([^\s]+养老[^\s]*?\d+号?)/i, points: 11 }  // "XX养老金1号"
                ];
                
                for (const { pattern, points } of highQualityPatterns) {
                    const match = cleanName.match(pattern);
                    if (match) {
                        return { name: match[1], confidence: points };
                    }
                }
                
                // 中等质量模式：包含产品关键词但格式不够标准
                const mediumQualityPatterns = [
                    { keyword: '信托', minLength: 4, points: 9 },
                    { keyword: '资管', minLength: 4, points: 8 },
                    { keyword: '集合', minLength: 5, points: 8 },
                    { keyword: '计划', minLength: 4, points: 7 },
                    { keyword: '专户', minLength: 4, points: 7 }
                ];
                
                for (const { keyword, minLength, points } of mediumQualityPatterns) {
                    if (cleanName.includes(keyword) && cleanName.length >= minLength) {
                        // 检查是否以数字结尾（常见的产品编号格式）
                        if (/\d+号?$/.test(cleanName)) {
                            confidence = Math.max(confidence, points + 2);
                        } else {
                            confidence = Math.max(confidence, points);
                        }
                    }
                }
                
                // 低质量模式：仅包含"号"结尾，可能是产品
                if (confidence < 6 && /^[\u4e00-\u9fa5]{3,}[A-Za-z0-9]*\d+号$/.test(cleanName)) {
                    confidence = 6;
                }
                
                // 过滤明显的非产品名称
                const invalidPatterns = [
                    /^(证券|银行|基金|公司|集团)$/,
                    /^(买入|卖出|交易|报价)$/,
                    /^(今天|明天|T\+\d)$/,
                    /^\d+(\.\d+)?$/,  // 纯数字
                    /^[A-Z]+$/        // 纯字母
                ];
                
                for (const invalid of invalidPatterns) {
                    if (invalid.test(cleanName)) {
                        return { name: '', confidence: 0 };
                    }
                }
                
                return confidence > 0 ? { name: cleanName, confidence } : { name: '', confidence: 0 };
            }
            
            _searchProductPatternsInText(text) {
                // 在全文中搜索产品名称模式（低优先级备选方案）
                const globalPatterns = [
                    /([^\s,，]*信托[^\s,，]*\d+号)/i,
                    /([^\s,，]*集合[^\s,，]*计划)/i,
                    /([^\s,，]*资管[^\s,，]*\d*号?)/i,
                    /([^\s,，]*金穗\d+号?)/i,
                    /([\u4e00-\u9fa5]{4,}\d+号)/  // 通用"XX数字号"模式
                ];
                
                for (const pattern of globalPatterns) {
                    const match = text.match(pattern);
                    if (match && match[1].length >= 4) {
                        const result = this._analyzeAccountNameCandidate(match[1]);
                        if (result.confidence > 0) {
                            return result.name;
                        }
                    }
                }
                
                return '';
            }
            
            extractProductNameFromText(text) {
                // 从包含联系人信息的文本中精确提取产品户名
                if (!text) return '';
                
                // 匹配产品名称模式：X信托XX号、XX集合计划、XX资管等
                const productPatterns = [
                    /([^\s]+信托[^\s]*?号)/,  // 如"外贸信托臻今60号"
                    /([^\s]+集合[^\s]*?计划)/,  // 如"XX集合资产管理计划"
                    /([^\s]+资管[^\s]*?号?)/,   // 如"XX资管计划"
                    /([^\s]+金穗\d+号?)/,       // 如"金穗10号"
                    /([^\s]+安盛[^\s]*?号)/     // 如"创金合信安盛1号"
                ];
                
                for (const pattern of productPatterns) {
                    const match = text.match(pattern);
                    if (match) {
                        return match[1];
                    }
                }
                
                // 如果没有匹配到精确模式，返回第一个包含关键词的词汇
                const words = text.split(/\s+/);
                for (const word of words) {
                    if (/信托.*号|集合.*计划|资管|金穗\d+/.test(word)) {
                        return word;
                    }
                }
                
                return text;
            }
            
            parseOrderMethod(text) {
                // 统一分类：请求（银行间）/ 对话（银行间）/ 固收平台（交易所）；否则置空
                if (!text) return '';
                
                let orderMethod = '';
                let confidence = 0;
                const s = String(text);
                
                // 1) 请求（兼容无方括号写法）
                if (/(?:【\s*)?请求(?:\s*】)?/.test(s)) {
                    orderMethod = '请求';
                    confidence = 10;
                }
                
                // 2) 固收平台（关键词更全：固收平台/固收联系/【固收】联系/固收 联系/固收平台交易/裸“固收”）
                if ((!orderMethod || confidence < 9) && /(固收平台|固收联系|【固收】\s*联系|固收\s*联系|固收平台\s*交易|(?:^|[,，\s])固收(?:[,，\s]|$))/.test(s)) {
                    orderMethod = '固收平台';
                    confidence = 9;
                }
                
                // 3) 对话
                if ((!orderMethod || confidence < 8) && /对话/.test(s)) {
                    orderMethod = '对话';
                    confidence = 8;
                }
                
                return orderMethod;
            }
            
            _normalizeOrderMethod(methodStr) {
                // 规范化发单方式字符串
                if (!methodStr) return '';
                
                const normalized = methodStr.toLowerCase();
                if (/qq|q/.test(normalized)) return 'QQ';
                if (/微信|wx|wechat/.test(normalized)) return '微信';
                if (/电话|tel|phone/.test(normalized)) return '电话';
                if (/邮件|email|mail/.test(normalized)) return '邮件';
                
                return '';
            }
            
            parseCounterpartyTrader(text, orderMethod='') {
                if (!text) return '';
                // 仅在 对话/固收平台 场景提取交易员；为空则尝试从文本推断是否属于固收/对话
                const allowed = new Set(['对话', '固收平台']);
                let effectiveOrder = orderMethod || '';
                if (!effectiveOrder) {
                    const s = String(text);
                    if (/(固收平台|固收联系|【固收】\s*联系|固收\s*联系|固收平台\s*交易|(?:^|[,，\s])固收(?:[,，\s]|$))/.test(s)) effectiveOrder = '固收平台';
                    else if (/对话/.test(s)) effectiveOrder = '对话';
                }
                if (effectiveOrder && !allowed.has(effectiveOrder)) return '';

                const { main, request } = splitMainAndRequest(text);

                // 主句优先：机构 + 人名 + 出给
                const mainPat = /([^\s,，]+?(?:证券|银行|基金|理财|信托|资管|保险|公司)[^\s,，]*?)\s+([^\s,，]{2,4})\s+出给/;
                const m1 = main.match(mainPat);
                if (m1 && this._isValidTraderName(m1[2])) {
                    return m1[2].trim();
                }

                // 优先：斜杠分隔的人名（如 "/史乐"）
                const slash = (
                    request.match(/\/\s*([\u4e00-\u9fa5]{2,4})(?=(?:\s|[,，]|$))/)
                    || main.match(/\/\s*([\u4e00-\u9fa5]{2,4})(?=(?:\s|[,，]|$))/)
                );
                if (slash && this._isValidTraderName(slash[1])) {
                    return slash[1].trim();
                }

                // 【请求】兜底一：发 + 机构 + 人名
                const reqPat1 = /发\s*[^\s,，]*?(?:证券|银行|基金|理财|信托|资管|保险|公司|集团|农商|农商行|农信社)\s*([^\s,，]{2,4})(?=(?:\s|,|，|$))/;
                const r1 = request.match(reqPat1);
                if (r1 && this._isValidTraderName(r1[1])) {
                    return r1[1].trim();
                }

                // 兜底二：固收平台联系xxx 姓名（主句/请求），也兼容“【固收】 联系 xxx 姓名”与“固收 联系 xxx 姓名”
                const gs1 = (
                    request.match(/(?:固收平台|固收联系|【固收】\s*联系|固收\s*联系)[^\s,，]*?\s+([\u4e00-\u9fa5]{2,4})(?=(?:\s|,|，|$))/)
                    || main.match(/(?:固收平台|固收联系|【固收】\s*联系|固收\s*联系)[^\s,，]*?\s+([\u4e00-\u9fa5]{2,4})(?=(?:\s|,|，|$))/)
                );
                if (gs1 && this._isValidTraderName(gs1[1])) {
                    return gs1[1].trim();
                }

                // 兜底三：允许更宽松分隔符（空格/逗号/中文逗号/括号星号）
                const simple = (
                    request.match(/(?:联系|找)[\s*（(]*\s*([^\s,，)）*]{2,4})[)）*]*?(?=(?:\s|[,，]|$))/)
                    || main.match(/(?:联系|找)[\s*（(]*\s*([^\s,，)）*]{2,4})[)）*]*?(?=(?:\s|[,，]|$))/)
                );
                if (simple && this._isValidTraderName(simple[1])) {
                    return simple[1].trim();
                }

                // 兜底四：姓名-机构（如 "乔亮-平安证券资管...")
                const dash = (
                    request.match(/([\u4e00-\u9fa5]{2,4})\s*-(?=\s*[^\s,，]*(?:证券|银行|基金|理财|信托|资管|保险|公司))/)
                    || main.match(/([\u4e00-\u9fa5]{2,4})\s*-(?=\s*[^\s,，]*(?:证券|银行|基金|理财|信托|资管|保险|公司))/)
                );
                if (dash && this._isValidTraderName(dash[1])) {
                    return dash[1].trim();
                }

                // 兜底五：姓名紧邻 QQ/QT/微信
                const contact = (
                    request.match(/([\u4e00-\u9fa5]{2,4})\s*(?:QQ|QT|微信|WX|wx)\s*[:：]?\s*\d{5,}/)
                    || main.match(/([\u4e00-\u9fa5]{2,4})\s*(?:QQ|QT|微信|WX|wx)\s*[:：]?\s*\d{5,}/)
                );
                if (contact && this._isValidTraderName(contact[1])) {
                    return contact[1].trim();
                }

                return '';
            }
            
            _isInstitutionAlias(token) {
                const s = String(token || '').replace(/[（）()]/g,'').trim();
                const alias = new Set([
                    '交行','招行','中行','建行','工行','农行','兴业','浙商','光大','浦发','民生','中金','中信',
                    '国君','国泰','国信','国元','国金','华泰','华创','华林','广发','海通','东方','东海','申万',
                    '长江','银河','第一创业','东吴','华西','安信','中山','天风','开源','财通','方正','华宝',
                    '中邮','上银','上投','华安','华夏','易方达','嘉实','汇添富','南方','工银瑞信','建信',
                    '国寿','太保','平安','交银','招银','杭银','上银','渣打','恒丰','浙银'
                ]);
                return alias.has(s);
            }
            _isCityName(token) {
                const s = String(token || '').replace(/[（）()]/g,'').trim();
                const cities = new Set([
                    '上海','北京','深圳','广州','杭州','南京','天津','重庆','苏州','成都','西安','武汉','郑州',
                    '长沙','沈阳','青岛','宁波','合肥','济南','福州','厦门','大连','无锡','昆明','南昌','贵阳',
                    '南宁','石家庄','太原','呼和浩特','乌鲁木齐','兰州','海口','长春','哈尔滨','佛山','东莞'
                ]);
                return cities.has(s);
            }
            _isValidTraderName(name) {
                if (!name) return false;
                const n = String(name).replace(/[（）()]/g,'').trim();
                if (!/^[\u4e00-\u9fa5]{2,4}$/.test(n)) return false;

                const businessTerms = [
                    '证券','银行','基金','理财','信托','资管','保险','公司','集团','请求','报价','合单','出给',
                    '明天','今天','交易','买入','卖出','固收','投资','农商','农商行','农信社','股份','有限','合伙'
                ];
                if (businessTerms.some(t => n.includes(t))) return false;

                if (this._isInstitutionAlias(n) || this._isCityName(n)) return false;
                if (/[（）()]/.test(name) && this._isCityName(n)) return false;

                const commonSurnames = new Set([
                    '王','李','张','刘','陈','杨','赵','黄','周','吴','徐','孙','胡','朱','高','林','何','郭',
                    '马','罗','梁','宋','郑','谢','韩','唐','冯','于','董','萧','程','曹','袁','邓','许','傅',
                    '沈','曾','彭','吕','苏','卢','蒋','蔡','贾','丁','魏','薛','叶','余','潘','杜','戴','范',
                    '方','金','邹','熊','白','孟','秦','邱','江','阎','史','雷','侯','龙','万','钱','汤',
                    '任','乔','毛','康','顾','夏','柳','祝','赖','车','严','关','汪','柴','庞','邵'
                ]);

                if (n.length <= 3) {
                    return true;
                }

                const doubleSurnames = ['欧阳','上官','东方','西门','南宫','司马','司徒','司空'];
                return doubleSurnames.some(s => n.startsWith(s));
            }
            
            _extractIntermediaryInfo(text) {
                // 【阶段3新增】完善的中介信息提取（支持6个中介：国利/中诚/国际/信唐/上田/平安）
                const result = { intermediary: '', sequence: '' };
                let confidence = 0;
                
                // 1. 最高优先级：从【中介标记】中提取
                // 支持缺少左括号的场景：如 “国利】1)” 或 文首“【国利”遗漏右括号
                const intermediaryMatch = (text.match(/【([^】]+)】/) || text.match(/^(国利|中诚|国际|信唐|上田|平安)]/) || text.match(/^[【\[]\s*(国利|中诚|国际|信唐|上田|平安)/));
                if (intermediaryMatch && intermediaryMatch[1]) {
                    const source = intermediaryMatch[1];
                    const excludedSources = new Set(['请求', '备注', '注释', '说明', '补充', '提示']);
                    
                    if (source && !excludedSources.has(source)) {
                        const mappedIntermediary = this._mapIntermediaryName(source);
                        if (mappedIntermediary && confidence < 15) {
                            result.intermediary = mappedIntermediary;
                            confidence = 15;
                        }
                    }
                }
                
                // 2. 中级优先级：从文本中识别中介关键词
                if (!result.intermediary || confidence < 10) {
                    const intermediaryPatterns = [
                        { pattern: /(?:^|\s|,|，)(国利|TP)(?:\s|,|，|$)/, name: '国利', priority: 12 },
                        { pattern: /(?:^|\s|,|，)(中诚|BGC)(?:\s|,|，|$)/, name: '中诚', priority: 12 },
                        { pattern: /(?:^|\s|,|，)(国际|ICAP)(?:\s|,|，|$)/, name: '国际', priority: 12 },
                        { pattern: /(?:^|\s|,|，)(信唐|XT)(?:\s|,|，|$)/, name: '信唐', priority: 12 },
                        { pattern: /(?:^|\s|,|，)(上田|ST)(?:\s|,|，|$)/, name: '上田', priority: 12 },
                        { pattern: /(?:^|\s|,|，)(平安|PALS)(?:\s|,|，|$)/, name: '平安', priority: 12 }
                    ];
                    
                    for (const { pattern, name, priority } of intermediaryPatterns) {
                        if (pattern.test(text) && priority > confidence) {
                            result.intermediary = name;
                            confidence = priority;
                        }
                    }
                }
                
                // 3. 提取中介序号（支持多种格式）
                const seqPatterns = [
                    { pattern: /【[^】]+】\s*(\d+)\)/, confidence: 15 }, // "【国利】1)"
                    { pattern: /(国利|中诚|国际|信唐|上田|平安)]\s*(\d+)\)/, confidence: 13 }, // "国利】1)"
                    { pattern: /^\s*(\d+)\)\s*/, confidence: 12 },        // 行首"1)"
                    { pattern: /序号[：:]\s*(\d+)/, confidence: 10 },      // "序号：1"
                    { pattern: /编号[：:]\s*(\d+)/, confidence: 10 },      // "编号：1"
                    { pattern: /(?:^|\s)(\d+)(?:\s|$)/, confidence: 6 }   // 独立数字，最低优先级
                ];
                
                let seqConfidence = 0;
                for (const { pattern, confidence: patternConfidence } of seqPatterns) {
                    const match = text.match(pattern);
                    if (match && match[1]) {
                        const seq = match[1];
                        // 对独立数字进行额外验证
                        const actualConfidence = this._validateSequenceNumber(seq, text, patternConfidence);
                        if (actualConfidence > seqConfidence) {
                            result.sequence = seq;
                            seqConfidence = actualConfidence;
                        }
                    }
                }
                
                return result;
            }
            
            _mapIntermediaryName(source) {
                // 【阶段3新增】完整的中介名称映射表
                const intermediaryMap = new Map([
                    // 中文全称
                    ['国利', '国利'], ['中诚', '中诚'], ['国际', '国际'],
                    ['信唐', '信唐'], ['上田', '上田'], ['平安', '平安'],
                    
                    // 英文缩写
                    ['TP', '国利'], ['BGC', '中诚'], ['ICAP', '国际'],
                    ['XT', '信唐'], ['ST', '上田'], ['PALS', '平安'],
                    
                    // 变体和别名
                    ['国利宝', '国利'], ['TP宝', '国利'],
                    ['中诚信', '中诚'], ['BGC中诚', '中诚'],
                    ['国际资本', '国际'], ['ICAP国际', '国际'],
                    ['信唐证券', '信唐'], ['XT信唐', '信唐'],
                    ['上田八木', '上田'], ['ST上田', '上田'],
                    ['平安证券', '平安'], ['平安理财', '平安'], ['PALS平安', '平安']
                ]);
                
                // 精确匹配
                if (intermediaryMap.has(source)) {
                    return intermediaryMap.get(source);
                }
                
                // 模糊匹配（包含关系）
                for (const [key, value] of intermediaryMap) {
                    if (source.includes(key) || key.includes(source)) {
                        return value;
                    }
                }
                
                // 如果不是已知中介，但格式合理，保留原文
                if (/^[A-Z]{2,6}$/.test(source) || /^[\u4e00-\u9fa5]{2,4}$/.test(source)) {
                    return source;
                }
                
                return '';
            }
            
            _validateSequenceNumber(seq, text, baseConfidence) {
                // 【阶段3新增】验证序号的可信度
                if (baseConfidence < 8) {
                    // 对于低可信度的独立数字，进行额外检查
                    
                    // 如果文本中包含多个数字，降低可信度
                    const numberMatches = text.match(/\d+/g);
                    if (numberMatches && numberMatches.length > 3) {
                        baseConfidence -= 2;
                    }
                    
                    // 如果数字在收益率、交易量附近，进一步降低可信度
                    if (/\d+\.\d{2,4}/.test(text) || /\d{3,6}[万亿]/.test(text)) {
                        baseConfidence -= 2;
                    }
                    
                    // 序号一般在1-99范围内
                    const seqNum = parseInt(seq);
                    if (seqNum > 99 || seqNum < 1) {
                        baseConfidence = 0;
                    }
                }
                
                return Math.max(0, baseConfidence);
            }
            
            isValidChineseName(name) {
                // 验证是否为有效的中文姓名
                if (!name || name.length < 2 || name.length > 4) {
                    return false;
                }
                
                if (!/^[\u4e00-\u9fa5]{2,4}$/.test(name)) {
                    return false;
                }
                
                const invalidNames = [
                    '请求', '报价', '合单', '出给', '明天', '今天', '交易', '买入', '卖出',
                    '证券', '银行', '基金', '理财', '信托', '保险', '公司', '集团'
                ];
                
                return !invalidNames.includes(name);
            }
            parseLine(line) {
                // 先提取对手方信息
                const counterpartyInfo = this.parseCounterparty(line);
                
                // 提取发单方式
                const orderMethod = this.parseOrderMethod(line);
                
                // 提取结算信息
                const settlementInfo = this.extractSettlementInfo(line);
                
                // 提取价格信息
                const priceInfo = this.extractPrices(line);
                
                const result = {
                    原始文本: line,
                    原中介编号: counterpartyInfo.intermediarySeq || '',  // 修改：使用intermediarySeq
                    债券代码: this.parseBondCode(line),
                    债券名称: this.parseBondName(line),
                    期限: this.parseTerm(line),
                    方向: counterpartyInfo.direction || this.extractDirection(line),
                    对手方: counterpartyInfo.counterparty || '',
                    终端机构名称: counterpartyInfo.terminalInstitution || '',  // 新增
                    做市商机构名称: counterpartyInfo.marketMaker || '',       // 新增
                    中介: counterpartyInfo.intermediary || '',
                    户名: counterpartyInfo.accountName || this.extractAccountName(line),
                    发单方式: counterpartyInfo.orderMethod || this.parseOrderMethod(line),  // 修改
                    对手交易员: counterpartyInfo.counterpartyTrader || this.parseCounterpartyTrader(line, orderMethod),  // 修改
                    交易量: this.parseVolume(line),
                    收益率: '',
                    收益率类型: '',
                    净价: priceInfo.netPrice,
                    全价: priceInfo.fullPrice,
                    交易日期: this.parseDate(line),
                    清算速度: settlementInfo.speed || '',   // 去掉无脑T+0
                    // 优先取显式，推断在对象创建后进行
                    交易场所: settlementInfo.venue || '',
                    备注: this.parseRemarks(line),
                    状态: '待执行',
                    完成进度: 0,
                    交易员: ''
                };
                // 对象创建后再推断交易场所，避免引用未初始化的 result
                if (!result.交易场所) {
                    const inferredVenue = this._inferTradingVenue(result);
                    if (inferredVenue) result.交易场所 = inferredVenue;
                }
                
                // 解析收益率（传入方向）
                const yieldInfo = this.parseYield(line, result.方向);
                result.收益率 = yieldInfo.value;
                result.收益率类型 = yieldInfo.type;
                
                // 验证必要字段
                if (!result.债券代码 && !result.债券名称) {
                    result.解析状态 = '失败';
                    result.错误信息 = '无法识别债券信息';
                } else if (!result.方向) {
                    result.解析状态 = '警告';
                    result.错误信息 = '未识别到交易方向';
                } else {
                    result.解析状态 = '成功';
                }
                
                // 【阶段4优化】统一数据清理和字段验证
                const cleanedResult = this._cleanAndValidateResult(result);
                
                // 额外兜底：若中介仍为空，使用增强版规则再尝试一次
                if (!cleanedResult.中介) {
                    try {
                        const ii = this._extractIntermediaryInfo(line);
                        if (ii && ii.intermediary) {
                            cleanedResult.中介 = ii.intermediary;
                        }
                        if (!cleanedResult.原中介编号 && ii && ii.sequence) {
                            cleanedResult.原中介编号 = ii.sequence;
                        }
                    } catch (e) {
                        // ignore
                    }
                }
                
                // 业务规则：终端机构为“机构待定”时置空，并在备注中记录
                if (cleanedResult.终端机构名称 && /机构待定/.test(cleanedResult.终端机构名称)) {
                    cleanedResult.备注 = (cleanedResult.备注 ? cleanedResult.备注 + '; ' : '') + '终端机构：机构待定';
                    cleanedResult.终端机构名称 = '';
                    if (!cleanedResult.对手方) cleanedResult.对手方 = '';
                }
                
                return cleanedResult;
            }

            parseText(text) {
                const lines = text.split('\n').filter(line => line.trim());
                
                // 尝试使用块级解析
                if (this.shouldUseBlockParsing(text)) {
                    return this.parseByBlocks(lines);
                }
                
                // 默认逐行解析
                return lines.map(line => this.parseLine(line));
            }
            
            shouldUseBlockParsing(text) {
                // 检查是否适合块级解析
                const hasMultiLineStructure = text.includes('【bid】') || text.includes('【ofr】') || 
                                             text.includes('【BID】') || text.includes('【OFR】');
                // 仅当出现2个及以上的显式交易所/银行间代码时才启用块解析；否则逐行解析更安全
                const codeExchangeRegex = /\d{6,9}\.(?:SH|SZ|IB)/gi;
                const codeCount = (text.match(codeExchangeRegex) || []).length;
                return hasMultiLineStructure || codeCount >= 2;
            }
            
            parseByBlocks(lines) {
                // FSM块级解析系统
                const blocks = this.splitIntoBlocks(lines);
                const results = [];
                
                for (const block of blocks) {
                    const parsed = this.parseBlock(block);
                    if (parsed) {
                        results.push(parsed);
                    }
                }
                
                return results;
            }
            
            splitIntoBlocks(lines) {
                // 将文本分割成逻辑块
                const blocks = [];
                let currentBlock = [];
                let contextDirection = null;
                
                for (const line of lines) {
                    const lowerLine = line.toLowerCase();
                    
                    // 检测方向上下文标记
                    if (lowerLine.includes('【bid】')) {
                        contextDirection = '买入';
                        continue;
                    }
                    if (lowerLine.includes('【ofr】')) {
                        contextDirection = '卖出';
                        continue;
                    }
                    
                    // 检测新块的开始（包含债券代码）
                    const hasCode = this.parseBondCode(line);
                    if (hasCode && currentBlock.length > 0) {
                        // 保存当前块
                        blocks.push({
                            lines: currentBlock,
                            contextDirection: contextDirection
                        });
                        currentBlock = [];
                    }
                    
                    currentBlock.push(line);
                }
                
                // 保存最后一个块
                if (currentBlock.length > 0) {
                    blocks.push({
                        lines: currentBlock,
                        contextDirection: contextDirection
                    });
                }
                
                return blocks;
            }
            
            parseBlock(block) {
                // 解析一个逻辑块
                const { lines, contextDirection } = block;
                if (!lines || lines.length === 0) return null;
                
                // 合并所有行成一个完整文本
                const fullText = lines.join(' ');
                
                // 先提取对手方信息
                const counterpartyInfo = this.parseCounterparty(fullText);
                
                // 提取发单方式
                const orderMethod = this.parseOrderMethod(fullText);
                
                const result = {
                    原始文本: fullText,
                    债券代码: '',
                    债券名称: '',
                    期限: '',
                    方向: contextDirection || '',
                    对手方: counterpartyInfo.counterparty || '',
                    终端机构名称: counterpartyInfo.terminalInstitution || '',
                    做市商机构名称: counterpartyInfo.marketMaker || '',
                    中介: counterpartyInfo.intermediary || '',
                    中介序号: counterpartyInfo.intermediarySeq || '',
                    户名: '',
                    发单方式: orderMethod,
                    对手交易员: '',
                    交易量: 0,
                    收益率: null,
                    收益率类型: '',
                    交易日期: '',
                    清算速度: 'T+0',
                    备注: '',
                    状态: '待执行',
                    完成进度: 0,
                    交易员: ''
                };
                
                // 从第一行提取主要信息
                const firstLine = lines[0] || '';
                result.债券代码 = this.parseBondCode(firstLine);
                result.债券名称 = this.parseBondName(firstLine);
                result.期限 = this.parseTerm(fullText);
                result.交易日期 = this.parseDate(fullText);
                result.清算速度 = this.parseSettlement(fullText);
                result.户名 = this.extractAccountName(fullText);
                result.对手交易员 = this.parseCounterpartyTrader(fullText, orderMethod);
                result.备注 = this.parseRemarks(fullText);
                
                // 从所有行中查找交易信息
                for (const line of lines) {
                    // 更新方向（如果找到更具体的）
                    const direction = this.extractDirection(line);
                    if (direction) {
                        result.方向 = direction;
                    }
                    
                    // 查找交易量
                    const volume = this.parseVolume(line);
                    if (volume > 0) {
                        result.交易量 = volume;
                    }
                    
                    // 查找收益率
                    const yieldRate = this.parseYield(line).value;
                    if (yieldRate !== null) {
                        result.收益率 = yieldRate;
                    }

                    // 补全终端/做市商（逐行兜底）
                    if (!result.终端机构名称 || !result.做市商机构名称) {
                        const cpLine = this.parseCounterparty(line);
                        if (!result.终端机构名称 && cpLine.terminalInstitution) {
                            result.终端机构名称 = cpLine.terminalInstitution;
                            result.对手方 = result.终端机构名称;
                        }
                        if (!result.做市商机构名称 && cpLine.marketMaker) {
                            result.做市商机构名称 = cpLine.marketMaker;
                        }
                    }
                }
                
                // 设置收益率类型
                result.收益率类型 = this.parseYieldType(fullText);
                
                // 如果方向还是空的，使用counterpartyInfo的方向
                if (!result.方向 && counterpartyInfo.direction) {
                    result.方向 = counterpartyInfo.direction;
                }

                // 若终端仍为空，依据方向与"出给"结构再推断一次
                if (!result.终端机构名称) {
                    const m = fullText.match(/(.+?)\s+出给\s+(.+?)(?:[,，]|【|$)/);
                    if (m) {
                        const a = this.normalizeInstitutionName(m[1]);
                        const b = this.normalizeInstitutionName(m[2]);
                        // 避免把债券名称当机构：排除以年份开头或含债/MTN等关键词
                        const looksLikeBond = (s) => /^\d{2}/.test(s) || /(债|票据|MTN|SCP|PPN|CD)/i.test(s);
                        if (result.方向 === '买入' && !a.includes('平安理财') && !looksLikeBond(a)) result.终端机构名称 = a;
                        else if (result.方向 === '卖出' && !b.includes('平安理财') && !looksLikeBond(b)) result.终端机构名称 = b;
                        if (!result.对手方 && result.终端机构名称) result.对手方 = result.终端机构名称;
                    }
                }
                
                // 验证结果
                if (!result.债券代码 && !result.债券名称) {
                    result.解析状态 = '失败';
                    result.错误信息 = '无法识别债券信息';
                } else if (!result.方向) {
                    result.解析状态 = '警告';
                    result.错误信息 = '未识别到交易方向';
                } else {
                    result.解析状态 = '成功';
                }
                
                // 【阶段4优化】统一数据清理和字段验证
                const cleanedResult = this._cleanAndValidateResult(result);
                
                // 业务规则：终端机构为“机构待定”时置空，并在备注中记录（块解析路径同样处理）
                if (cleanedResult.终端机构名称 && /机构待定/.test(cleanedResult.终端机构名称)) {
                    cleanedResult.备注 = (cleanedResult.备注 ? cleanedResult.备注 + '; ' : '') + '终端机构：机构待定';
                    cleanedResult.终端机构名称 = '';
                    if (!cleanedResult.对手方) cleanedResult.对手方 = '';
                }

                return cleanedResult;
            }
            
            _cleanAndValidateResult(result) {
                // 【阶段4新增】统一数据清理和字段验证机制
                if (!result) return result;
                
                // 1. 数据清理
                const cleaned = this._cleanAllFields(result);

                // 1.1 户名质量纠错：若疑似脏值或过长，强制用增强版重算
                try {
                    const rawText = cleaned.原始文本 || '';
                    const badAcct = cleaned.户名 && (
                        /(\s|^)\d+(?:\.\d+)?\s*(?:k|kw|K|KW|万|亿|E)\+?/i.test(cleaned.户名) ||
                        /(证券|银行|基金|理财|做市|稍等|请求|发|出给)/.test(cleaned.户名) ||
                        cleaned.户名.length > 20
                    );
                    if (!cleaned.户名 || badAcct) {
                        cleaned.户名 = this.extractAccountName(rawText);
                    }
                } catch (e) {}
                
                // 2. 字段验证
                const validated = this._validateAllFields(cleaned);
                
                // 3. 数据完整性检查
                const finalResult = this._performIntegrityChecks(validated);
                
                return finalResult;
            }
            
            _cleanAllFields(result) {
                // 统一的字段清理
                const cleaned = { ...result };
                
                // 清理文本字段
                const textFields = ['债券代码', '债券名称', '对手方', '终端机构名称', '做市商机构名称', '中介', '户名', '发单方式', '对手交易员', '收益率类型', '清算速度', '交易场所', '备注'];
                for (const field of textFields) {
                    if (cleaned[field]) {
                        cleaned[field] = this._cleanTextField(cleaned[field]);
                    }
                }
                
                // 清理数值字段
                if (cleaned.交易量) {
                    cleaned.交易量 = this._cleanNumberField(cleaned.交易量, 'volume');
                }
                if (cleaned.收益率) {
                    cleaned.收益率 = this._cleanYieldField(cleaned.收益率);
                }
                if (cleaned.净价) {
                    cleaned.净价 = this._cleanNumberField(cleaned.净价, 'price');
                }
                if (cleaned.全价) {
                    cleaned.全价 = this._cleanNumberField(cleaned.全价, 'price');
                }
                
                // 清理日期字段
                if (cleaned.交易日期) {
                    cleaned.交易日期 = this._cleanDateField(cleaned.交易日期);
                }
                
                return cleaned;
            }
            
            _validateAllFields(result) {
                // 统一的字段验证
                const validated = { ...result };
                const validationErrors = [];
                const validationWarnings = [];
                
                // 1. 必填字段验证
                if (!validated.债券代码 && !validated.债券名称) {
                    validationErrors.push('缺少债券代码或债券名称');
                }
                if (!validated.方向) {
                    validationWarnings.push('未识别到交易方向');
                }
                
                // 2. 格式验证
                if (validated.债券代码 && !this._isValidBondCode(validated.债券代码)) {
                    validationWarnings.push('债券代码格式异常');
                }
                if (validated.收益率 && !this._isValidYield(validated.收益率)) {
                    validationWarnings.push('收益率格式异常');
                }
                if (validated.交易量 && !this._isValidVolume(validated.交易量)) {
                    validationWarnings.push('交易量数值异常');
                }
                
                // 3. 逻辑验证
                if (validated.净价 && validated.全价) {
                    if (parseFloat(validated.全价) < parseFloat(validated.净价)) {
                        validationWarnings.push('全价不应小于净价');
                    }
                }
                
                // 设置验证结果
                if (validationErrors.length > 0) {
                    validated.解析状态 = '失败';
                    validated.错误信息 = validationErrors.join('; ');
                } else if (validationWarnings.length > 0) {
                    if (!validated.解析状态 || validated.解析状态 === '成功') {
                        validated.解析状态 = '警告';
                        validated.错误信息 = (validated.错误信息 || '') + (validated.错误信息 ? '; ' : '') + validationWarnings.join('; ');
                    }
                } else if (!validated.解析状态) {
                    validated.解析状态 = '成功';
                }
                
                return validated;
            }
            
            _performIntegrityChecks(result) {
                // 数据完整性检查和智能补全
                const enhanced = { ...result };
                
                // 0. 若交易量缺失或为0，尝试从原始文本做一次稳健回补（不依赖上游解析路径）
                try {
                    const raw = enhanced.原始文本 || '';
                    const volNow = parseFloat(enhanced.交易量) || 0;
                    if (volNow === 0 && raw) {
                        const rescued = this._rescueVolumeFromText(raw);
                        if (rescued && rescued > 0) enhanced.交易量 = rescued;
                    }
                } catch (e) { /* ignore */ }

                // 1. 交易场所智能判断
                if (!enhanced.交易场所 || enhanced.交易场所 === '未知') {
                    enhanced.交易场所 = this._inferTradingVenue(enhanced);
                }
                
                // 2. 收益率类型智能判断
                if (!enhanced.收益率类型 && enhanced.收益率) {
                    enhanced.收益率类型 = this._inferYieldType(enhanced);
                }
                
                // 3. 机构角色一致性检查
                if (enhanced.中介 && enhanced.对手方) {
                    const roleCheck = this._checkInstitutionRoleConsistency(enhanced);
                    if (!roleCheck.consistent) {
                        if (!enhanced.错误信息) enhanced.错误信息 = '';
                        enhanced.错误信息 += (enhanced.错误信息 ? '; ' : '') + roleCheck.warning;
                    }
                }
                
                return enhanced;
            }
            
            // 通用回补：从原始文本中稳健提取交易量（单位统一为 万）
            _rescueVolumeFromText(text) {
                if (!text) return 0;
                let t = text;
                // 只取第一行或方向所在行，避免跨行串扰
                try {
                    const dirMatch = /(买入|卖出|BID|OFR|bid|ofr|offer)/.exec(t);
                    if (dirMatch) {
                        const idx = dirMatch.index;
                        const sNL = t.lastIndexOf('\n', idx), sCR = t.lastIndexOf('\r', idx);
                        let s = Math.max(sNL, sCR); s = s < 0 ? 0 : s + 1;
                        const eNL = t.indexOf('\n', idx), eCR = t.indexOf('\r', idx);
                        let e = Math.min(eNL === -1 ? Infinity : eNL, eCR === -1 ? Infinity : eCR);
                        e = e === Infinity ? t.length : e;
                        t = t.slice(s, e);
                    } else {
                        t = (t.match(/[^\r\n]+/g) || [t])[0];
                    }
                } catch(e){}

                // 1) 方向就近（容忍方向与数字之间存在任意空白或标点）
                let m = t.match(/(?:买入|卖出)\s*[:：,，\-\s]*\s*(\d+(?:\.\d+)?)(?:\s*(kw|KW|k(?!w)|K(?!W)|w|W|万|亿|[Ee]\b))?/);
                if (m) return this._convertVolumeUnit(parseFloat(m[1]), (m[2]||''));

                // 2) 收益率后邻近（容忍收益率与方向/数字之间的标点）
                m = t.match(/(\d+\.\d{2,4})(?:%|\s*行权|\s*到期)?\s*[:：,，\-\s]*\s*(?:买入|卖出)?\s*(\d+(?:\.\d+)?)(?:\s*(kw|KW|k(?!w)|K(?!W)|w|W|万|亿|[Ee]\b))?/i);
                if (m) return this._convertVolumeUnit(parseFloat(m[2]), (m[3]||''));

                // 3) 常见单位
                m = t.match(/(\d+(?:\.\d+)?)\s*(kw|KW|k(?!w)|K(?!W)|w|W|万|亿|[Ee]\b)/);
                if (m) return this._convertVolumeUnit(parseFloat(m[1]), (m[2]||''));

                // 4) 纯数字启发式：100~100000 认为是万
                m = t.match(/\b(\d{3,6})\b/);
                if (m) {
                    const num = parseFloat(m[1]);
                    if (num >= 100 && num <= 100000) return num;
                }
                return 0;
            }
            
            _convertVolumeUnit(num, unitRaw) {
                if (isNaN(num) || num <= 0) return 0;
                const unit = (unitRaw||'').toLowerCase();
                if (unit === 'kw' || unit === 'k') return num * 1000;      // 千万
                if (unit === 'w' || unit === '万' || unit === '') return num; // 万
                if (unit === '亿' || unit === 'e') return num * 10000;      // 亿 -> 万
                return num;
            }
            
            _cleanTextField(text) {
                // 统一的文本字段清理
                if (!text) return '';
                
                return text.toString()
                    .trim()
                    .replace(/\s+/g, ' ') // 多个空格合并为一个
                    .replace(/[，,]\s*$/, '') // 移除末尾的逗号
                    .replace(/^[,，\s]+/, '') // 移除开头的逗号和空格
                    .replace(/[\u200B-\u200D\uFEFF]/g, ''); // 移除零宽字符
            }
            
            _cleanNumberField(value, type) {
                // 统一的数值字段清理
                if (value === null || value === undefined || value === '') return null;
                
                let cleaned = parseFloat(value);
                if (isNaN(cleaned)) return null;
                
                // 根据类型进行范围检查
                if (type === 'volume') {
                    // 交易量合理范围：0.1万 - 100万
                    if (cleaned < 0.1 || cleaned > 1000000) {
                        return null;
                    }
                    return Math.round(cleaned * 100) / 100; // 保留2位小数
                } else if (type === 'price') {
                    // 价格合理范围：1 - 200
                    if (cleaned < 1 || cleaned > 200) {
                        return null;
                    }
                    return Math.round(cleaned * 10000) / 10000; // 保留4位小数
                }
                
                return cleaned;
            }
            
            _cleanYieldField(yieldValue) {
                // 收益率字段专门清理
                if (!yieldValue) return null;
                
                let yieldStr = yieldValue.toString().replace('%', '');
                let yieldNum = parseFloat(yieldStr);
                
                if (isNaN(yieldNum)) return null;
                
                // 收益率合理范围：0.1% - 20%
                if (yieldNum < 0.1 || yieldNum > 20) {
                    return null;
                }
                
                return yieldNum.toFixed(4) + '%';
            }
            
            _cleanDateField(date) {
                // 日期字段清理
                if (!date) return '';
                
                // 如果已经是标准格式，直接返回
                if (/^\d{4}-\d{2}-\d{2}$/.test(date)) {
                    return date;
                }
                
                // 尝试解析并标准化日期格式
                try {
                    const parsedDate = new Date(date);
                    if (!isNaN(parsedDate.getTime())) {
                        return parsedDate.toISOString().split('T')[0];
                    }
                } catch (error) {
                    // 解析失败，返回今天日期
                    return new Date().toISOString().split('T')[0];
                }
                
                return date;
            }
            
            _isValidBondCode(code) {
                // 债券代码格式验证
                if (!code) return false;
                
                const patterns = [
                    /^\d{6,9}\.(SH|SZ|IB)$/i,  // 标准格式
                    /^\d{6,9}$/                 // 纯数字
                ];
                
                return patterns.some(pattern => pattern.test(code));
            }
            
            _isValidYield(yieldValue) {
                // 收益率格式验证
                if (!yieldValue) return false;
                
                const yieldStr = yieldValue.toString().replace('%', '');
                const yieldNum = parseFloat(yieldStr);
                
                return !isNaN(yieldNum) && yieldNum >= 0.1 && yieldNum <= 20;
            }
            
            _isValidVolume(volume) {
                // 交易量验证
                if (!volume) return false;
                
                const volumeNum = parseFloat(volume);
                return !isNaN(volumeNum) && volumeNum > 0 && volumeNum <= 1000000;
            }
            
            _inferTradingVenue(result) {
                // 智能推断交易场所
                if (result.债券代码) {
                    if (/\.(SH|SZ)$/i.test(result.债券代码)) {
                        return '交易所';
                    } else if (/\.IB$/i.test(result.债券代码) || /^\d{9}$/.test(result.债券代码.replace(/\..*/, ''))) {
                        return '银行间';
                    }
                }
                
                // 根据清算速度推断
                if (result.清算速度 === 'T+0' && !result.原始文本.includes('银行间')) {
                    return '交易所';
                }
                
                return '银行间'; // 默认银行间
            }
            
            _inferYieldType(result) {
                // 智能推断收益率类型
                if (!result.收益率) return '';
                
                if (result.原始文本.includes('行权')) {
                    return '行权收益率';
                } else if (result.原始文本.includes('到期')) {
                    return '到期收益率';
                } else if (result.原始文本.includes('*')) {
                    return '参考收益率';
                } else if (result.原始文本.includes('/')) {
                    return '双边报价';
                }
                
                return '到期收益率'; // 默认到期收益率
            }
            
            _checkInstitutionRoleConsistency(result) {
                // 机构角色一致性检查
                const { 中介, 对手方 } = result;
                
                // 检查中介和对手方是否有角色混淆
                const knownIntermediaries = ['国利', '中诚', '国际', '信唐', '上田', '平安'];
                const knownInstitutionSuffixes = ['银行', '证券', '基金', '理财', '信托', '保险'];
                
                let warning = '';
                let consistent = true;
                
                // 如果对手方看起来像中介
                if (对手方 && knownIntermediaries.includes(对手方)) {
                    warning = '对手方可能被误识别为中介';
                    consistent = false;
                }
                
                // 如果中介看起来像终端机构
                if (中介 && knownInstitutionSuffixes.some(suffix => 中介.includes(suffix))) {
                    if (!knownIntermediaries.some(inter => 中介.includes(inter))) {
                        warning = (warning ? warning + '; ' : '') + '中介可能被误识别为终端机构';
                        consistent = false;
                    }
                }
                
                return { consistent, warning };
            }
            
            // ===== 阶段1重构：拆分方向和对手方提取逻辑为独立方法 =====
            
            /**
             * 提取交易方向 - 职责单一的方法
             * @param {string} line 原始文本
             * @returns {string} 交易方向
             */
            extractDirection(line) {
                if (!line) return '';

                // 1. 显式关键词（优先）
                if (line.includes('买入')) return '买入';
                if (line.includes('卖出')) return '卖出';

                // 2. 英文市话
                const t = line.toLowerCase();
                if (/\bbid\b/.test(t)) return '买入';
                if (/\b(ofr|offer|ask)\b/.test(t)) return '卖出';

                // 3. 俗语（拿=买入；给/出=卖出）
                if (/(帮忙拿|要拿|拿一下|收一下|收票|吃掉|扫货|要一下|求一口)/.test(line)) return '买入';
                if (/(?<!出)(给\s*\d+|给一下|报一口|挂一下|抛一下|让一下|放一下|出一下)/.test(line)) return '卖出';

                // 4. 结构推断（"A 出给 B"/"A to B" 以平安视角判断）
                const toMatch = line.match(/([\u4e00-\u9fa5a-zA-Z]+)\s+to\s+([\u4e00-\u9fa5a-zA-Z]+)/);
                if (toMatch) {
                    const A = toMatch[1], B = toMatch[2];
                    if (A.includes('平安理财')) return '卖出';
                    if (B.includes('平安理财')) return '买入';
                }
                const givePos = line.indexOf('出给');
                if (givePos !== -1) {
                    const before = line.substring(0, givePos);
                    const after  = line.substring(givePos + 2);
                    if (before.includes('平安理财')) return '卖出';
                    if (after.includes('平安理财'))  return '买入';
                }

                // 5. 无法判断 -> 返回空，禁止默认为卖出
                return '';
            }
            /**
             * 提取终端机构名称 - 基于"出给"结构和交易方向
             * @param {string} line 原始文本
             * @param {string} direction 交易方向
             * @returns {string} 终端机构名称
             */
            extractTerminalInstitution(line, direction) {
                if (!line || !direction) return '';
                
                // 1. 处理"to"结构
                const toMatch = line.match(/([\u4e00-\u9fa5]+[^\s]*?)\s+to\s+([\u4e00-\u9fa5]+[^\s]*?)/);
                if (toMatch) {
                    const partyA = this._cleanInstitutionName(toMatch[1]);
                    const partyB = this._cleanInstitutionName(toMatch[2]);
                    
                    // A to B结构中，B是买方
                    return direction === "买入" ? partyA : partyB;
                }
                
                // 2. 基于"出给"结构提取
                const giveToPos = line.indexOf('出给');
                if (giveToPos === -1) return '';
                
                const beforeGiveTo = line.substring(0, giveToPos).trim();
                const afterGiveTo = line.substring(giveToPos + 2).trim();
                
                const partyA = this._extractInstitutionNameBefore(beforeGiveTo);
                const partyB = this._extractInstitutionNameAfter(afterGiveTo);
                
                // 3. 根据交易方向确定终端机构（显式排除"平安理财"被当作终端）
                if (direction === "买入") {
                    const cand = this._cleanInstitutionName(partyA);
                    return cand.includes('平安理财') ? '' : cand;
                } else {
                    const cand = this._cleanInstitutionName(partyB);
                    return cand.includes('平安理财') ? '' : cand;
                }
            }
            
            /**
             * 机构名称清理
             * @param {string} name 机构名称
             * @returns {string} 清理后的名称
             */
            _cleanInstitutionName(name) {
                if (!name) return '';
                
                // 基础清理
                name = name.trim().replace(/\s+/g, ' ');
                
                // 移除可能的交易量等数字信息
                name = name.replace(/\s*\d+\s*,?\s*$/, '');
                
                // 移除多余的标点符号
                name = name.replace(/[,，。;；]+$/, '').replace(/^[,，。;；]+/, '');
                
                // 验证是否为有效机构名称
                if (!this._isValidInstitutionName(name)) return '';
                
                return name;
            }
            
            /**
             * 增强的机构名称验证
             * @param {string} name 机构名称
             * @returns {boolean} 是否有效
             */
            _isValidInstitutionName(name) {
                if (!name || name.length < 2 || name.length > 20) return false;
                
                // 必须包含中文字符
                if (!/[\u4e00-\u9fa5]/.test(name)) return false;
                
                // 不能是纯数字
                if (/^\d+$/.test(name)) return false;
                
                // 排除明显的非机构名词汇
                const invalidWords = [
                    '请求', '报价', '合单', '双方', '发请求', '明天', '今天', 
                    '交易', '买入', '卖出', '行权', '到期', '出给'
                ];
                if (invalidWords.includes(name)) return false;
                
                // 排除我方机构名称
                if (name.includes('平安理财')) return false;
                
                // 不能以明显的非机构名词汇结尾（允许机构名后带括号分支，如 东海证券(上海)）
                if (/(?:请求|报价|合单|发请求)$/.test(name)) return false;
                
                return true;
            }
            
            /**
             * 从"出给"前的文本提取机构名称
             * @param {string} text 出给前的文本
             * @returns {string} 机构名称
             */
            _extractInstitutionNameBefore(text) {
                if (!text) return '';
                
                // 移除序号和标记
                text = text.replace(/^【[^】]+】\d+\)/, '').replace(/^\d+[、。]/, '');
                
                // 分词处理
                const words = text.trim().split(/\s+/);
                if (!words.length) return '';
                
                // 从后往前查找机构名称（忽略显式"平安理财"）
                for (let i = words.length - 1; i >= 0; i--) {
                    const word = words[i];
                    const cleanWord = this._cleanInstitutionName(word);
                    
                    if (cleanWord && !cleanWord.includes('平安理财') && this._isLikelyInstitution(cleanWord)) {
                        return cleanWord;
                    }
                }
                
                return '';
            }
            
            /**
             * 从"出给"后的文本提取机构名称
             * @param {string} text 出给后的文本
             * @returns {string} 机构名称
             */
            _extractInstitutionNameAfter(text) {
                if (!text) return '';
                
                // 移除【请求】及其后面的内容
                const requestPos = text.indexOf('【请求】');
                if (requestPos !== -1) {
                    text = text.substring(0, requestPos);
                }
                
                // 移除逗号后的内容
                const commaPos = text.search(/[,，]/);
                if (commaPos !== -1) {
                    text = text.substring(0, commaPos);
                }
                
                text = text.trim();
                
                // 机构名称模式匹配（显式排除"平安理财"）
                const institutionMatch = text.match(/^((?!平安理财)[^\d+\-/\s]+(?:银行|理财|证券|基金|保险|信托|资管|金融|投资|集团|公司|农商行|农商|农信社|投顾))/);
                if (institutionMatch) {
                    const cleaned = this._cleanInstitutionName(institutionMatch[1]);
                    if (cleaned && this._isLikelyInstitution(cleaned)) return cleaned;
                }
                
                // 提取第一个中文词组
                const chineseMatch = text.match(/^((?!平安理财)[^\d+\-/\s,，]{2,})/);
                if (chineseMatch) {
                    const candidate = this._cleanInstitutionName(chineseMatch[1]);
                    if (this._isLikelyInstitution(candidate)) {
                        return candidate;
                    }
                }
                
                return '';
            }
            
            /**
             * 判断是否可能是机构名称
             * @param {string} name 名称
             * @returns {boolean} 是否可能是机构
             */
            _isLikelyInstitution(name) {
                if (!name || name.length < 2) return false;
                
                // 机构特征词
                const institutionFeatures = [
                    '证券', '银行', '基金', '理财', '信托', '保险', '资管', '金融',
                    '投资', '集团', '公司', '农商', '农信', '农合', '资产', '投顾'
                ];

                // 排除明显像债券名称的片段
                if (this._looksLikeBondLike(name)) return false;
                
                // 如果包含机构特征词，很可能是机构
                if (institutionFeatures.some(feature => name.includes(feature))) {
                    return true;
                }
                
                // 常见的券商简称
                const commonShortNames = [
                    '一创', '华创', '中金', '中信', '华泰', '招商', '广发', '海通',
                    '国泰', '申万', '东证', '光大', '兴业', '方正', '民生', '国信',
                    '长江', '银河', '东方', '太平', '平安', '华夏', '工银', '建信'
                ];
                
                return commonShortNames.includes(name);
            }

            // 判断是否像债券名称（用于过滤误判为机构）
            _looksLikeBondLike(name) {
                if (!name) return false;
                const bondKeywords = /(债券|债|票据|中票|短融|MTN|SCP|PPN|NCD|CD|可转债|永续|二级资本|次级)/i;
                if (bondKeywords.test(name)) return true;
                if (/^\d{2,}.*债/.test(name)) return true;
                return false;
            }
            
            /**
             * 优化的做市商机构提取 - 专门从【请求】和"发xxx"模式提取
             * @param {string} line 原始文本
             * @returns {string} 做市商机构名称
             */
            extractMakerInstitution(line) {
                if (!line) return '';

                // 【请求】发xxx 优先
                const req = line.match(/(?:【请求】|请求)([^【】]*?)(?=【|$)/);
                if (req) {
                    const fa = req[1].match(/发\s*([^\s,，]+?(?:证券|银行|基金|理财|信托|资管|保险|公司|投顾)(?:[\(（][^\)）]*[\)）])?)/);
                    if (fa && fa[1] && fa[1] !== '请求') return fa[1].trim();
                }
                
                // 尝试直接匹配"发XXX"格式
                const directMatch = line.match(/[,，]\s*发\s*([^\s,，]+?(?:证券|银行|基金|理财|信托|资管|保险|公司|投顾)(?:[\(（][^\)）]*[\)）])?)/);
                if (directMatch && directMatch[1] && directMatch[1] !== '请求') {
                    return directMatch[1].trim();
                }

                // "固收联系/联系/固收"xxx 兜底
                const mmPatterns = [
                    /固收联系([^\s,，]+(?:证券|银行|基金|信托|保险|资管|公司|投顾)(?:[\(（][^\)）]*[\)）])?)/,
                    /联系([^\s,，]+(?:证券|银行|基金|信托|保险|资管|公司|投顾)(?:[\(（][^\)）]*[\)）])?)/,
                    /固收([^\s,，]+(?:证券|银行|基金|信托|保险|资管|公司|投顾)(?:[\(（][^\)）]*[\)）])?)/
                ];
                for (const p of mmPatterns) {
                    const m = line.match(p);
                    if (m) return m[1].trim();
                }

                // "双方发" -> 留空（由操作侧再分配）
                if (/双方发/.test(line)) return '';

                return '';
            }
            
            extractDirectionAndCounterparties(line) {
                // 重构后的统一调用方法 - 职责分离，逻辑清晰
                const direction = this.extractDirection(line);
                const makerInstitution = this.extractMakerInstitution(line);
                const terminalInstitution = this.extractTerminalInstitution(line, direction);
                
                return {
                    direction: direction,
                    makerInstitution: makerInstitution,
                    terminalInstitution: terminalInstitution
                };
            }
            
            extractYieldInfo(line) {
                const result = {
                    yield: '',
                    yieldType: ''
                };
                
                // 检查行权收益率
                let match = line.match(this.patterns.yieldExercise);
                if (match) {
                    result.yield = match[1] + '%';
                    result.yieldType = '行权收益率';
                    return result;
                }
                
                // 检查到期收益率
                match = line.match(this.patterns.yieldMaturity);
                if (match) {
                    result.yield = match[1] + '%';
                    result.yieldType = '到期收益率';
                    return result;
                }
                
                // 检查双边报价
                match = line.match(this.patterns.bidOfferPair);
                if (match) {
                    // 获取交易方向
                    const direction = this.extractDirection(line);
                    const leftPrice = parseFloat(match[1]);
                    const rightPrice = parseFloat(match[2]);
                    
                    let selectedPrice;
                    if (direction === '买入') {
                        selectedPrice = rightPrice;  // 买入取对手卖价（右侧）
                    } else if (direction === '卖出') {
                        selectedPrice = leftPrice;   // 卖出取对手买价（左侧）
                    } else {
                        selectedPrice = leftPrice;   // 未知方向取左侧（保守）
                    }
                    
                    result.yield = selectedPrice.toFixed(4) + '%';
                    result.yieldType = '到期收益率';
                    return result;
                }
                
                // 检查带星号的收益率
                match = line.match(this.patterns.yieldWithStar);
                if (match) {
                    result.yield = match[1] + '%';
                    result.yieldType = '参考收益率';
                    return result;
                }
                
                // 普通收益率（优先就近“方向”同一行的收益率）
                let scopeLine = line;
                try {
                    const dir = this.extractDirection(line);
                    if (dir) {
                        const re = dir === '买入' ? /(买入)/ : /(卖出)/;
                        const m = re.exec(line);
                        if (m) {
                            const idx = m.index;
                            const startNL = line.lastIndexOf('\n', idx);
                            const startCR = line.lastIndexOf('\r', idx);
                            let start = Math.max(startNL, startCR);
                            start = start < 0 ? 0 : start + 1;
                            const endNL = line.indexOf('\n', idx);
                            const endCR = line.indexOf('\r', idx);
                            let end = Math.min(endNL === -1 ? Infinity : endNL, endCR === -1 ? Infinity : endCR);
                            end = end === Infinity ? line.length : end;
                            scopeLine = line.slice(start, end);
                        }
                    }
                } catch(e){}
                match = scopeLine.match(this.patterns.yieldGeneral);
                if (match) {
                    result.yield = match[1] + '%';
                    result.yieldType = '到期收益率';
                    return result;
                }
                
                return result;
            }
            
            extractCompleteRemarks(line, termInfo) {
                const remarks = [];
                
                if (termInfo) {
                    remarks.push(`期限: ${termInfo}`);
                }
                
                // 提取请求信息
                let match = line.match(this.patterns.remarksRequest);
                if (match) {
                    remarks.push(`请求: ${match[1].trim()}`);
                }
                
                // 提取费用信息
                match = line.match(this.patterns.remarksFee);
                if (match) {
                    remarks.push(`费用: ${match[1]}`);
                }
                
                // 提取产品信息
                match = line.match(this.patterns.remarksProduct);
                if (match) {
                    remarks.push(`产品: ${match[1]}`);
                }
                
                // 提取发/走信息
                match = line.match(this.patterns.remarksFaZou);
                if (match) {
                    remarks.push(`联系: ${match[1]}`);
                }
                
                return remarks.join('; ');
            }
            
            extractAccountName(line) {
                if (!line) return '';

                // 1) 取"出给"后的主干；若有【请求】，优先用其内容；否则在遇到下一个【前截断
                let tail = line;
                const giveIdx = tail.indexOf('出给');
                if (giveIdx >= 0) tail = tail.substring(giveIdx + 2);
                // 不再仅保留【请求】内文，避免丢失其后的户名片段（如括号内产品）
                // 保留完整尾段，由后续清理规则精准移除无关片段

                // 2) 噪声清理
                tail = tail
                    .replace(/固收联系[^,，；;]*|联系[^,，；;]*|找[^,，；;]*|双方发|发请求|请求发/g, '')
                    .replace(/发\s*[^\s,，；;*]*/g, '')
                    .replace(/做市稍等|做市.*?$/g, '')
                    .replace(/账户待确认|求具体账户|户名待确认|户名待定/g, '')
                    .replace(/[；;。]/g, ',')
                    .replace(/\s+/g, ' ')
                    .trim();

                // 2.5) 数量/配额出现即截断（2k/2k+/1k/1E/2万/…），仅当紧随单位时
                tail = tail.replace(/\s+\d+(?:\.\d+)?\s*(?:k|K|kw|KW|w|W|万|亿|e|E)\+?.*$/, '');

                // 2.6) 若仍出现"新机构名"，从该处起截断
                tail = tail.replace(/\s+[A-Za-z\u4e00-\u9fa5]{2,10}(?:证券|银行|基金|理财|资管|保险|公司)[\s\S]*$/, '');

                // 2.7) 更多停止词（遇到立即截断）
                const moreStops = /(做市|稍等|先|等会|一笔|明天|今天|报价|双发|双方发).*/;
                tail = tail.replace(moreStops, '');

                // 2.8) 紧凑无空格强匹配（在品牌/通用模式前快速命中）
                // 紧凑无空格快速命中：
                // - 对于“资管”类，要求结尾带“号”，避免误取“资管+员工号/工号”
                const tightProduct = tail.match(/([^\s,，]*?(?:信托|理财|集合|计划|基金)[^\s,，]*?\d+(?:号)?|[^\s,，]*?资管[^\s,，]*?\d+号)/);
                if (tightProduct) return tightProduct[1];

                // 3) 候选片段（按中文逗号/逗号切开，自右向左优先）
                const parts = tail.split(/[,，]/).map(s => s.trim()).filter(Boolean).reverse();

                // 4) 关键品牌词 + 数字（覆盖"无'号'后缀"的产品）
                const brandKeys = ['元启','安盛','和壹','磐石','金穗','沣盛','臻今','臻选','悦享','精选','稳健','睿选','臻惠'];
                const brandRegex = new RegExp(`([\\u4e00-\\u9fa5A-Za-z]{2,20}?(?:${brandKeys.join('|')})\\s*\\d+(?:号)?)`, 'g');

                // 5) 其他通用产品模式
                const genericRegexList = [
                    /[\u4e00-\u9fa5]{2,12}(?:信托|理财|资管|资产管理|集合|计划|基金)[\u4e00-\u9fa5A-Za-z]*?\d+(?:号)?/g,
                    /[\u4e00-\u9fa5]{2,10}\d+号/g
                ];

                // 6) 从右往左找最像产品名的候选，优先"品牌 + 数字"
                const candidates = [];
                for (const raw of parts) {
                    let s = raw.replace(/\s+\d+(?:\.\d+)?\s*(?:k|K|kw|KW|w|W|万|亿|e|E)\+?.*$/, '').trim();
                    // 解包括号但保留内容，便于匹配品牌/产品名
                    s = s.replace(/[（(]([^）)]+)[）)]/g, '$1');
                    if (!s) continue;

                    let m;
                    while ((m = brandRegex.exec(s)) !== null) candidates.push(m[1].trim());
                    if (candidates.length === 0) {
                        for (const re of genericRegexList) {
                            let mg;
                            while ((mg = re.exec(s)) !== null) candidates.push(mg[0].trim());
                        }
                    }
                    if (candidates.length > 0) break;
                }

                // 7) 过滤明显伪候选：如“资管+长串数字但不含‘号’”
                const filtered = candidates.filter(c => {
                    if (/资管/.test(c) && !/号/.test(c) && /\d{6,}/.test(c)) return false;
                    return true;
                });
                const usable = filtered.length ? filtered : candidates;

                // 8) 优先含"号"的条目；否则返回第一个
                const final = usable.sort((a, b) => {
                    const aHas = a.includes('号') ? 1 : 0;
                    const bHas = b.includes('号') ? 1 : 0;
                    return bHas - aHas;
                })[0];

                return final || '';
            }
        }

        // 债券解析器核心 - 增强版（基于html发送请求版）
        // 全局工具：机构名规范化（用于非类方法场景）
        function normalizeInstitutionName(name) {
            if (!name) return '';
            let n = String(name).trim();
            n = n.replace(/[＊*]/g, '');
            // 保留括号内容
            n = n.replace(/(?:部|总部|金市部|营业部)$/,'');
            n = n.replace(/\s+/g, '');
            // 简称标准化（与类方法保持一致）
            if (!/[银行证券基金理财信托资管保险]/.test(n)) {
                const aliasMap = {
                    '交行': '交通银行',
                    '招行': '招商银行',
                    '中行': '中国银行',
                    '建行': '建设银行',
                    '工行': '工商银行',
                    '农行': '农业银行',
                    '兴业': '兴业银行',
                    '华泰': '华泰证券',
                    '中信': '中信证券',
                    '国都': '国都证券',
                    '东方': '东方证券',
                    '国信': '国信证券',
                    '华林': '华林证券',
                    '华创': '华创证券'
                };
                if (aliasMap[n]) n = aliasMap[n];
            }
            return n;
        }
        
        // 机构名轻量清洗（终端/做市前置清洗）
        function cleanInstitutionName(s) {
            if (!s) return s;
            return String(s)
                .replace(/^发\s*/, '')
                .replace(/[,，。].*$/, '')
                .trim();
        }
        class EnhancedBondParser extends BondParser {
            constructor() {
                super(); // 调用父类构造函数
                this.current_year = new Date().getFullYear();
                this.setupEnhancedPatterns();
                this.parsed_records = [];
                // 预编译常用字符串集合
                this._excluded_sources = new Set(['请求', '备注', '注释', '说明']);
                this._date_prefixes = new Set(['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12']);
                
                // 将增强模式合并到基础模式中，以确保父类方法正常工作
                Object.assign(this.patterns, this.enhancedPatterns);
            }

            setupCaches() {
                // 性能优化：缓存
                this.codeCache = new Map();
                this.directionCache = new Map();
                this.nameCache = new Map();
                this.cachedResults = new Map();
            }

            setupEnhancedPatterns() {
                // 方向识别（扩展词汇 - 参考html发送请求版完整功能）
                this.buyVerbs = ['bid', 'BID', 'Bid', '买入', '买', '拿', '收', '要', '求', '询', 
                               '收购', '采购', '购买', '需要', '寻求', '帮忙拿', '接', '吃', '捡', 
                               'b', 'B', '收票', '吃掉', '扫货', '要拿', '拿一下', '收一下', 
                               '要一下', '求一口', '接货', '接盘', '承接', '看多', 'buy', 'BUY', 
                               '询价', '接收', '拿货', '收货', '找货', '买进', '增持'];
                this.sellVerbs = ['ofr', 'OFR', 'Ofr', 'offer', 'OFFER', 'Offer', '卖出', '卖', 
                                '给', '出', '售', '让', '转', '抛', '出售', '供应', '提供', 
                                '释放', '挂牌', '出给', '挂给', 'of', 'OF', '甩', '放', 
                                '报价', '给一下', '报一口', '挂一下', '抛一下', '让一下', 
                                '放一下', '出一下', '甩货', '抛售', '减持', 'sell', 'SELL', 
                                'ask', 'ASK', '供给', '供货', '派发', '分销', '看空', '售出'];
                
                // 编译正则表达式（基于html发送请求版的优化模式）
                this.enhancedPatterns = {
                    // 来源/交易员
                    source: /【([^】]+)】/g,
                    
                    // 债券代码（优先级顺序，支持更多格式）
                    bondCodeExchange: /(\d{6,9}\.(?:SH|SZ|IB))/gi,
                    bondCodeInterbank9: /(\d{9})(?!\d)/g,
                    bondCode8digit: /(\d{8})(?!\d)/g,
                    bondCode7digit: /(\d{7})(?!\d)/g,
                    bondCode6digit: /(\d{6})(?!\d)/g,
                    
                    // 期限信息提取（重点优化）
                    termSingle: /(\d+\.?\d*[YD])/g,
                    termComplex: /(\d+\.?\d*[YD]\s*\+\s*\d+\.?\d*[YD])/g,
                    termSpecial: /(\+\s*N(?:Y)?(?:\([^)]*\))?)/g,
                    termFullPattern: /(\d+\.?\d*[YD](?:\s*\+\s*\d+\.?\d*[YD]|\s*\+\s*N(?:Y)?(?:\([^)]*\))?)?)/g,
                    
                    // 债券名称模式 - 优化版，支持更多格式
                    bondNamePatternNew: [
                        /([A-Z]{2,6}[\u4e00-\u9fa5]+\d{2,4})/g,
                        /(\d{2}[\u4e00-\u9fa5]+(?:银行|证券|金融|集团|公司|国际|投资|控股|发展|建设|交通|城投|地产|能源|煤业|钢铁|化工|电力|水务|环保|科技)?(?:永续债|二级资本债|专项债|企业债|公司债|中期票据|MTN|可转债)?\d*)/g,
                        /(\d{2}[\u4e00-\u9fa5]+\d{2,3})/g,
                        /([\u4e00-\u9fa5]+(?:银行|证券|金融|集团|公司|国际|投资|控股|发展|建设|交通|城投|地产|能源|煤业|钢铁|化工|电力|水务|环保|科技)+(?:永续债|二级资本债|专项债|企业债|公司债|中期票据|MTN|可转债)?\d*)/g,
                        /([\u4e00-\u9fa5]+(?:永续债|二级资本债|专项债|企业债|公司债|中期票据|MTN|可转债)\d*)/g,
                        /([A-Z]{2,6}\d{2,4})/g,
                        // 增强的债券名称模式，支持PPN/SCP/CP等后缀
                        /(\d{2}[\u4e00-\u9fa5]{2,8}(?:PPN|SCP|CP|MTN)\d*)/g,  // 如"24豫航空港PPN004"
                        /([\u4e00-\u9fa5]{2,8}\d{2,4}(?:PPN|SCP|CP|MTN)\d*)/g,  // 中文+数字+后缀
                        // 新增：支持通用字母后缀格式，如"23河钢集GN002"
                        /(\d{2}[\u4e00-\u9fa5]{1,8}[A-Z]{1,4}\d{1,4})/g,
                        /([\u4e00-\u9fa5]{2,8}\d{2,4})/g  // 原模式，保持兼容性
                    ],
                    bondNamePattern: /([A-Z]{0,3}[\u4e00-\u9fa5]+(?:\d{2,3}|永续债|MTN\d*|资本债\d*|债券?\d*|专项债\d*|企业债\d*|公司债\d*|中期票据\d*)|[A-Z]+[\u4e00-\u9fa5]+\d+)/g,
                    
                    // 交易方向和对手（修复版）
                    directionPattern: /(\S+(?:\s+\S+)*?)\s*出给\s*(\S+(?:\s+\S+)*?)(?:\s*[,，]|【请求】|$)/g,
                    buySellPattern: /(买入|卖出)/g,
                    counterpartyPattern: /(?:\s+|^)([^\d\s,，]+(?:[^\d,，]*[^\d\s,，]+)?)\s*出给\s*([^\d\s,，]+(?:[^\d,，]*[^\d\s,，]+)?)(?:\s*[,，]|【请求】|$)/g,
                    
                    // 交易量（支持科学记数法）
                    volumePattern: /(\d{3,6})(?=\s*(?:\+|\s+\+|T\+|\s+T\+|\s+交易所|\s+远|\s+出给|$))/g,
                    volumeScientific: /(\d+(?:\.\d+)?)[Ee](?:\s*万?)?/g,
                    volumeKPattern: /(\d+(?:\.\d+)?)\s*[kK](?!\w)/g,
                    volumeKwPattern: /(\d+(?:\.\d+)?)\s*[kK][wW]/g,
                    volumeWanPattern: /(\d+(?:\.\d+)?)\s*[万Ww](?![\u4e00-\u9fa5])/g,
                    
                    // 收益率
                    yieldExercise: /(\d+\.?\d*)\s*行权/g,
                    yieldMaturity: /(\d+\.?\d*)\s*(?:到期)/g,
                    yieldGeneral: /(\d+\.\d{2,4})(?=\s+(?:\d{4,6}|\+|T\+|交易所|远|出给)|$)/g,
                    
                    // 双边报价识别（新增）
                    bidOfferPair: /(\d+\.\d{2,4})(?:\([^)]*\))?\/(\d+\.\d{2,4})(?:\([^)]*\))?/g,
                    yieldWithStar: /(\d+\.\d{2,4})\*/g,
                    yieldWithBracket: /(\d+\.\d{2,4})\([^)]*\)/g,
                    
                    // 价格
                    netPrice: /净价\s*(\d+\.?\d*)/g,
                    fullPrice: /全价\s*(\d+\.?\d*)/g,
                    
                    // 交易日期（增强格式支持）
                    tradeDateDot: /(\d{1,2})\.(\d{2})(?!\d)/g,
                    tradeDateDash: /(\d{1,2})\-(\d{2})(?!\d)/g,
                    tradeDate4digit: /(\d{2})(\d{2})(?=\+|\s+\+|$)/g,
                    tradeDateSlash: /(\d{1,2})\/(\d{2})\.(\d{2})/g,
                    tradeDateSlashSettlement: /(\d{1,2})\/(\d{1,2})\+(\d+)/g,
                    tradeDateTodayTomorrow: /(明天|今天)(?:\s*\+\s*(\d+))?/g,
                    tradeDateExchange: /(\d{2})\.(\d{2})交易所/g,
                    
                    // 清算速度
                    settlementT0: /(?:\+\s*0|T\+?\s*0)/g,
                    settlementT1: /(?:\+\s*1|T\+?\s*1)/g,
                    settlementExchange: /交易所/g,
                    settlementRemote: /远期|(?<!\S)远(?!\S)/g,
                    
                    // 备注信息（完整性保证）
                    remarksRequest: /【请求】([^【]*?)(?=【|$)/g,
                    remarksParentheses: /\([^)]+\)/g,
                    remarksSpecial: /(休\d+|金穗\d+|厘)/g,
                    
                    // 增强备注识别（新增）
                    remarksFaZou: /(发\s*[^\s,，]+|走\s*[^\s,，]+\s*发)/g,
                    remarksFee: /(留\s*\d*\s*厘|几厘|\d+厘)/g,
                    remarksProduct: /([^\s,，]*(?:信托|集合计划|金穗\d+号))/g,
                    
                    // 中介和对手方
                    intermediary: /【([^】]+)】/g,
                    counterparty: /([^\s]+(?:\s+[^\s]+)*)\s+出给\s+([^\s]+(?:\s+[^\s]+)*)/g
                };
            }


            parseBondCode(text) {
                // 使用缓存
                if (this.codeCache.has(text)) {
                    return this.codeCache.get(text);
                }
                
                let result = '';
                let match;
                
                // 带交易所后缀的代码
                match = text.match(this.patterns.codeExchange);
                if (match) {
                    result = match[0].toUpperCase();
                    this.codeCache.set(text, result);
                    return result;
                }
                
                // 9位银行间代码
                match = text.match(this.patterns.codeInterbank);
                if (match) {
                    result = match[0] + '.IB';
                    this.codeCache.set(text, result);
                    return result;
                }
                
                // 8位代码
                match = text.match(this.patterns.code8digit);
                if (match) {
                    const code = match[0];
                    // 如果没有后缀，默认银行间
                    result = code.includes('.') ? code : code + '.IB';
                    this.codeCache.set(text, result);
                    return result;
                }
                
                // 7位代码
                match = text.match(this.patterns.code7digit);
                if (match) {
                    const code = match[0];
                    // 如果没有后缀，默认银行间
                    result = code.includes('.') ? code : code + '.IB';
                    this.codeCache.set(text, result);
                    return result;
                }
                
                // 6位代码
                match = text.match(this.patterns.code6digit);
                if (match) {
                    const code = match[0];
                    if (code.startsWith('1') || code.startsWith('5')) {
                        result = code + '.SH';
                    } else if (code.startsWith('3')) {
                        result = code + '.SZ';
                    } else {
                        // 其他6位代码默认银行间
                        result = code + '.IB';
                    }
                    this.codeCache.set(text, result);
                    return result;
                }
                
                this.codeCache.set(text, result);
                return result;
            }

            parseBondName(text) {
                // 使用缓存
                if (this.nameCache.has(text)) {
                    return this.nameCache.get(text);
                }
                
                let result = '';
                
                // 重构：收集所有匹配，选择最佳匹配（优先级 > 长度）
                let allMatches = [];
                
                for (let pattern of this.patterns.bondName) {
                    const matches = text.matchAll(new RegExp(pattern.source, pattern.flags));
                    for (const match of matches) {
                        if (this.isValidBondNameMatch(match[0], text)) {
                            let priority = 5; // 默认优先级
                            const matchText = match[0];
                            
                            // 精确的优先级分配
                            if (/^[A-Z]{2,6}[\u4e00-\u9fa5]+\d{2,4}$/.test(matchText)) {
                                // 字母+中文+数字（如"GC核融03"）
                                priority = 15;
                            } else if (/^\d{2}[\u4e00-\u9fa5]{1,8}[A-Z]{1,4}\d{2,4}$/.test(matchText)) {
                                // 年份+中文+字母+数字（如"23河钢集GN002"）
                                priority = 15;
                            } else if (/^\d{2}[\u4e00-\u9fa5]{2,6}\d{2,4}$/.test(matchText)) {
                                // 年份+中文+数字（如"21株国04"），高优先级
                                priority = 16;
                            } else if (/^[\u4e00-\u9fa5]{3,8}\d{2,4}$/.test(matchText)) {
                                // 简洁的中文+数字（如"衡阳03"，长度<10）
                                priority = matchText.length <= 10 ? 15 : 8;
                            } else if (/(?:PPN|MTN|SCP|CP)\d*$/.test(matchText)) {
                                // 标准后缀格式
                                priority = 12;
                            } else if (/(?:永续债|二级资本债|专项债|企业债|公司债|中期票据|可转债)\d*$/.test(matchText)) {
                                // 债券类型后缀
                                priority = 8;
                            } else if (matchText.length > 15) {
                                // 过长的匹配，可能是误匹配
                                priority = 3;
                            }
                            
                            allMatches.push({
                                text: matchText,
                                length: matchText.length,
                                index: match.index,
                                priority: priority
                            });
                        }
                    }
                }
                
                // 选择最佳匹配：首先按优先级，然后按长度（短的优先）
                if (allMatches.length > 0) {
                    allMatches.sort((a, b) => {
                        if (a.priority !== b.priority) {
                            return b.priority - a.priority; // 优先级高的在前
                        }
                        // 相同优先级下，短的在前（对于债券名称，短的通常更准确）
                        return a.length - b.length;
                    });
                    result = allMatches[0].text;
                }
                
                // 如果没有找到且没有债券代码，尝试无代码提取
                if (!result && !this.parseBondCode(text)) {
                    result = this.extractBondNameWithoutCode(text);
                }
                
                this.nameCache.set(text, result);
                return result;
            }
            
            extractBondNameWithoutCode(line) {
                // 代码缺失时的债券名称提取
                if (!line) return '';
                
                let cleanedLine = line;
                
                // 去掉开头的标记和序号
                cleanedLine = cleanedLine.replace(/^[^【\[]*[\[【][^】\]]*[】\]]?\s*/, '');
                cleanedLine = cleanedLine.replace(/^\d+\)\s*/, '');
                cleanedLine = cleanedLine.replace(/^(买入|卖出)\s+/i, '');
                
                let text = cleanedLine.trim();
                
                // 去掉期限信息
                text = text.replace(/\d+\.?\d*[YD]\s*(?:\+\s*\d+\.?\d*[YD])?/g, '');
                text = text.replace(/\+\s*N(?:\([^)]*\))?/g, '');
                text = text.trim();
                
                if (!text) return '';
                
                // 跳过以收益率开头的行
                if (/^\d+\.\d{2,4}%?\s/.test(text)) {
                    return '';
                }
                
                // 跳过以代码开头的行
                if (/^\d{4,6}\s/.test(text)) {
                    return '';
                }
                
                // 查找结束标记
                const endMarkers = [
                    /\s+\d+\.\d{2,4}(?:%|行权|到期)?/,
                    /\s+\d{3,6}(?:\s|$)/,
                    /\s+出给/,
                    /【请求】/,
                    /\s+T\+\d/,
                    /\s+交易所/,
                    /\s+远/,
                    /\s+(?:私募债|公募债)(?=\s|$)/
                ];
                
                let minPos = text.length;
                for (let pattern of endMarkers) {
                    const match = text.match(pattern);
                    if (match) {
                        minPos = Math.min(minPos, match.index);
                    }
                }
                
                let bondName = text.substring(0, minPos).trim();
                bondName = bondName.replace(/[,，。、\s]+$/, '');
                bondName = bondName.replace(/\s*(?:私募债|公募债)\s*$/, '');
                
                if (this.isValidExtractedBondName(bondName)) {
                    return bondName;
                }
                
                return '';
            }
            
            // 验证标准模式匹配的债券名称是否有效
            isValidBondNameMatch(match, fullText) {
                if (!this.isValidExtractedBondName(match)) return false;
                
                // 额外检查：确保匹配的内容不是收益率的一部分
                const matchIndex = fullText.indexOf(match);
                if (matchIndex === -1) return false;
                
                // 检查匹配文本前面是否有收益率数字
                const beforeMatch = fullText.substring(0, matchIndex);
                if (/\d+\.\d+\s*$/.test(beforeMatch)) {
                    // 如果前面紧跟数字，很可能是收益率的一部分，如"1.88行权"
                    return false;
                }
                
                // 检查是否在收益率语境中
                const aroundMatch = fullText.substring(Math.max(0, matchIndex - 10), matchIndex + match.length + 10);
                if (/\d+\.\d+\s*行权|\d+\.\d+\s*到期/.test(aroundMatch)) {
                    return false;
                }
                
                return true;
            }
            
            isValidExtractedBondName(bondName) {
                // 验证提取的债券名称是否有效
                if (!bondName || bondName.length < 2) {
                    return false;
                }
                
                if (/^\d+$/.test(bondName)) {
                    return false;
                }
                
                const hasEnglish = /[A-Z]/.test(bondName);
                if (hasEnglish) {
                    const chineseChars = bondName.match(/[\u4e00-\u9fa5]/g);
                    if (!chineseChars || chineseChars.length < 1) {
                        return false;
                    }
                } else {
                    const chineseChars = bondName.match(/[\u4e00-\u9fa5]/g);
                    if (!chineseChars || chineseChars.length < 2) {
                        return false;
                    }
                }
                
                // 无效的开头模式
                const invalidPatterns = [
                    /^行权/, /^到期/, /^出给/,
                    /^\d+\.\d+$/, /^\d+$/,
                    /^\d+行权$/, /^\d+到期$/, // 排除"88行权"、"90到期"等收益率相关文本
                    /^AAA?[+-]?(?:spc)?$/, // 排除评级如"AAAspc"
                ];
                
                for (let pattern of invalidPatterns) {
                    if (pattern.test(bondName)) {
                        return false;
                    }
                }
                
                // 金融机构名称不是债券名称
                const financialInstitutions = [
                    '华夏基金', '华夏银行', '华福证券', '申港证券', '平安理财', '中银理财',
                    '长城证券', '国泰君安', '中信证券', '海通证券', '招商证券', '广发证券'
                ];
                
                if (financialInstitutions.includes(bondName)) {
                    return false;
                }

                // 进一步排除：交易场所关键词不应出现在债券名称中
                const invalidKeywords = ['交易所'];
                for (const kw of invalidKeywords) {
                    if (bondName.includes(kw)) {
                        return false;
                    }
                }
                
                // 排除信托产品和资管产品名称（关键修复）
                const trustProductPatterns = [
                    /.*信托.*\d+号/,              // 如"外贸信托臻今60号"
                    /.*信托.*计划/,               // 信托计划
                    /.*集合.*计划/,               // 集合计划
                    /.*资管.*计划/,               // 资管计划
                    /.*金穗\d+号?/,               // 金穗系列
                    /.*专户.*\d+号/,              // 专户产品
                    /.*基金.*\d+号/,              // 基金产品编号
                    /.*理财.*\d+号/               // 理财产品编号
                ];
                
                for (const pattern of trustProductPatterns) {
                    if (pattern.test(bondName)) {
                        return false;
                    }
                }
                
                return true;
            }

            parseVolume(text) {
                // 将解析范围收敛到当前行，避免跨行把其他指令的数量误判进来
                if (text && (text.includes('\n') || text.includes('\r'))) {
                    try {
                        let narrowed = '';
                        const dirRe = /(买入|卖出|BID|OFR|Bid|Ofr|offer|Offer)/;
                        const m = dirRe.exec(text);
                        if (m) {
                            const idx = m.index;
                            const startNL = text.lastIndexOf('\n', idx);
                            const startCR = text.lastIndexOf('\r', idx);
                            let start = Math.max(startNL, startCR);
                            start = start < 0 ? 0 : start + 1;
                            const endNL = text.indexOf('\n', idx);
                            const endCR = text.indexOf('\r', idx);
                            let end = Math.min(endNL === -1 ? Infinity : endNL, endCR === -1 ? Infinity : endCR);
                            end = end === Infinity ? text.length : end;
                            narrowed = text.slice(start, end);
                        } else {
                            const firstLine = (text.match(/[^\r\n]+/g) || [text])[0];
                            narrowed = firstLine;
                        }
                        text = narrowed;
                    } catch (e) {}
                }

                let match;
                let volume = 0;
                
                // 最高优先级：收益率后的数字（新增逻辑）
                // 匹配收益率后紧跟的数字，这通常是真正的交易量
                const yieldVolumeMatch = text.match(/(\d+\.\d{2,4})(?:%|\s*行权|\s*到期)?\s*[:：,，\-\s]*\s*(?:买入|卖出)?\s*(\d+(?:\.\d+)?)(?:\s*(kw|KW|k(?!w)|K(?!W)|w|W|万|亿|[Ee]\b))?/i);
                if (yieldVolumeMatch) {
                    const num = parseFloat(yieldVolumeMatch[2]);
                    const unit = (yieldVolumeMatch[3] || '').toLowerCase();
                    if (unit === 'kw' || unit === 'k') return num * 1000;
                    if (unit === 'w' || unit === '万' || unit === '') return num;
                    if (unit === '亿' || unit === 'e') return num * 10000;
                    if (!unit && num >= 100 && num <= 100000) return num;
                }
                
                
                // 亿格式 (需要优先于其他格式)
                match = text.match(this.patterns.volumeYi);
                if (match) {
                    volume = parseFloat(match[1]) * 10000;
                    return volume;
                }
                
                // kw格式 (千万)
                match = text.match(this.patterns.volumeKw);
                if (match) {
                    volume = parseFloat(match[1]) * 1000;
                    return volume;
                }
                
                // k格式 (千万)
                match = text.match(this.patterns.volumeK);
                if (match) {
                    volume = parseFloat(match[1]) * 1000;
                    return volume;
                }
                
                // 万格式
                match = text.match(this.patterns.volumeWan);
                if (match) {
                    volume = parseFloat(match[1]);
                    return volume;
                }
                
                // 科学计数法 E/e (如：1E = 1000万, 5e = 5000万)
                match = text.match(this.patterns.volumeScientific);
                if (match) {
                    const baseValue = parseFloat(match[1]);
                    // E通常表示万万（亿）
                    volume = baseValue * 10000;
                    // 如果后面有"万"，则是E万
                    if (match[2] && match[2].includes('万')) {
                        volume = baseValue * 10000;
                    }
                    return volume;
                }
                
                // 特殊格式：数字+单位组合 (如：5千万、3百万)
                const specialMatch = text.match(/(\d+(?:\.\d+)?)\s*(千万|百万|十万)/);
                if (specialMatch) {
                    const num = parseFloat(specialMatch[1]);
                    const unit = specialMatch[2];
                    if (unit === '千万') {
                        return num * 1000;
                    } else if (unit === '百万') {
                        return num * 100;
                    } else if (unit === '十万') {
                        return num * 10;
                    }
                }
                
                // 纯数字（根据大小和上下文判断单位）
                // 先排除债券代码区域，避免误匹配债券代码中的数字
                let volumeMatches = [];
                const volumeRegex = new RegExp(this.patterns.volumeNumber.source, 'g');
                let volumeMatch;
                while ((volumeMatch = volumeRegex.exec(text)) !== null) {
                    volumeMatches.push({
                        value: volumeMatch[0],
                        index: volumeMatch.index
                    });
                }
                
                // 获取所有债券代码位置，排除这些区域
                const bondCodePatterns = [
                    this.patterns.codeExchange,
                    this.patterns.codeInterbank,
                    this.patterns.code8digit,
                    this.patterns.code7digit,
                    this.patterns.code6digit
                ];
                
                let bondCodeRanges = [];
                for (const pattern of bondCodePatterns) {
                    const regex = new RegExp(pattern.source, 'g');
                    let codeMatch;
                    while ((codeMatch = regex.exec(text)) !== null) {
                        bondCodeRanges.push({
                            start: codeMatch.index,
                            end: codeMatch.index + codeMatch[0].length
                        });
                    }
                }
                
                // 找到不在债券代码区域内的数字
                for (const volMatch of volumeMatches) {
                    const volStart = volMatch.index;
                    const volEnd = volStart + volMatch.value.length;
                    
                    // 检查是否与债券代码区域重叠
                    let isInBondCode = false;
                    for (const codeRange of bondCodeRanges) {
                        if ((volStart >= codeRange.start && volStart < codeRange.end) ||
                            (volEnd > codeRange.start && volEnd <= codeRange.end) ||
                            (volStart < codeRange.start && volEnd > codeRange.end)) {
                            isInBondCode = true;
                            break;
                        }
                    }
                    
                    if (!isInBondCode) {
                        const num = parseFloat(volMatch.value);
                        // 100-9999通常是万元
                        if (num >= 100 && num < 10000) {
                            return num;
                        }
                        // 10000-99999可能是十万或万
                        else if (num >= 10000 && num <= 99999) {
                            // 如果前后有价格信息，更可能是万
                            if (/\d+\.\d{2,4}/.test(text)) {
                                return num / 10000;  // 作为绝对金额处理
                            }
                            return num / 10;  // 作为十万处理
                        }
                        // 100000以上作为绝对金额（元）转换为万
                        else if (num >= 100000) {
                            return num / 10000;
                        }
                    }
                }
                
                return 0;
            }

            parseYield(text, direction='') {
                // 先识别"行权/到期"并优先取其数值
                let type = '到期收益率';
                let val = null;
                const exerciseMatch = text.match(/(\d+\.\d{2,4})\s*行权/);
                const maturityMatch = text.match(/(\d+\.\d{2,4})\s*到期/);
                if (exerciseMatch) {
                    type = '行权收益率';
                    val = parseFloat(exerciseMatch[1]);
                } else if (maturityMatch) {
                    type = '到期收益率';
                    val = parseFloat(maturityMatch[1]);
                }

                // 双边价：x/y 或 bid x / ofr y
                const pair = text.match(/(\d+\.\d{2,4})\s*\/\s*(\d+\.\d{2,4})/);
                const bidOfr = text.match(/bid\s*(\d+\.\d{2,4}).*?(?:ofr|offer|ask)\s*(\d+\.\d{2,4})/i);
                if (pair || bidOfr) {
                    const a = parseFloat(pair ? pair[1] : bidOfr[1]);
                    const b = parseFloat(pair ? pair[2] : bidOfr[2]);
                    if (direction === '买入') val = b;        // 取对手卖价
                    else if (direction === '卖出') val = a;   // 取对手买价
                    else val = a; // 未知方向，先取bid（更保守）
                }

                // 单价兜底（排除日期/净价/全价）
                if (val == null) {
                    const best = this.extractBestYield(text); // 该函数已有合理范围与排除逻辑
                    if (best) {
                        val = parseFloat(best.replace('%',''));
                        try { result.备注 = (result.备注?result.备注+'; ':'') + '收益率来源:兜底'; } catch(e){}
                    }
                }

                if (val == null) return { value: '', type };

                // 合理性校验（0.1%~20%）
                if (val < 0.1 || val > 20) return { value: '', type };

                return { value: val.toFixed(4) + '%', type };
            }
            
            extractBestYield(text) {
                // 提取最佳收益率（包含合理性检查）
                // 排除后随期限符号 Y/D，及日期、清算等噪声
                const yieldPattern = /(\d+\.\d{2,4})(?:\s*%)?(?!\s*[YD])(?!\s*\+|\s*T\+|\s*\/|\s*\d{1,2}[\.\-]\d{1,2})/g;
                
                const yields = [];
                let match;
                
                while ((match = yieldPattern.exec(text)) !== null) {
                    const yieldValue = match[1];
                    try {
                        const floatValue = parseFloat(yieldValue);
                        // 合理的收益率范围：0.5% - 20.0%
                        if (floatValue >= 0.5 && floatValue <= 20.0) {
                            // 排除日期格式 (如12.25)
                            if (!this.isDateFormat(yieldValue.replace('.', ''))) {
                                yields.push({
                                    value: yieldValue,
                                    position: match.index
                                });
                            }
                        }
                    } catch (error) {
                        continue;
                    }
                }
                
                if (yields.length > 0) {
                    // 返回带%符号的收益率字符串（按清洁版.py逻辑）
                    return parseFloat(yields[0].value).toFixed(4) + "%";
                }
                
                return null;
            }
            
            isDateFormat(dateStr) {
                // 检查是否为日期格式
                if (dateStr.length === 4) {
                    const month = parseInt(dateStr.substring(0, 2));
                    const day = parseInt(dateStr.substring(2, 4));
                    return (month >= 1 && month <= 12) && (day >= 1 && day <= 31);
                }
                return false;
            }
            parseDate(text) {
                const today = new Date();
                
                if (this.patterns.dateToday.test(text)) {
                    return '';
                }
                
                if (this.patterns.dateTomorrow.test(text)) {
                    const tomorrow = new Date(today);
                    tomorrow.setDate(tomorrow.getDate() + 1);
                    return tomorrow.toISOString().split('T')[0];
                }
                
                // 1. 复合日期格式 (+1/MM.DD+2)
                const compoundDate = this.extractCompoundDate(text);
                if (compoundDate) {
                    return compoundDate;
                }
                
                // 2. 带清算的日期格式 (MMDD+1)
                const dateWithSettlement = this.extractDateWithSettlement(text);
                if (dateWithSettlement) {
                    const { month, day } = dateWithSettlement;
                    const year = this.determineYear(month, today.getMonth() + 1, today.getFullYear());
                    const monthStr = String(month).padStart(2, '0');
                    const dayStr = String(day).padStart(2, '0');
                    return `${year}-${monthStr}-${dayStr}`;
                }
                
                // 3. 尝试多种日期格式
                const datePatterns = [
                    this.patterns.dateMD,     // MM.DD 或 MM/DD
                    this.patterns.dateDot,     // MM.DD
                    this.patterns.dateDash,    // MM-DD
                    this.patterns.date4digit   // MMDD
                ];
                
                for (let pattern of datePatterns) {
                    const match = text.match(pattern);
                    if (match && match[1] && match[2]) {
                        const year = today.getFullYear();
                        const month = String(match[1]).padStart(2, '0');
                        const day = String(match[2]).padStart(2, '0');
                        
                        // 验证日期合法性
                        const monthNum = parseInt(month);
                        const dayNum = parseInt(day);
                        if (monthNum >= 1 && monthNum <= 12 && dayNum >= 1 && dayNum <= 31) {
                            return `${year}-${month}-${day}`;
                        }
                    }
                }
                
                return '';
            }
            
            extractCompoundDate(text) {
                // 提取复合日期格式 (+1/MM.DD+2)
                const compoundPattern = /\+(\d+)\/(\d{2})\.(\d{2})\+(\d+)/;
                const match = text.match(compoundPattern);
                if (!match) return '';
                
                const firstOffset = parseInt(match[1]);
                const month = parseInt(match[2]);
                const day = parseInt(match[3]);
                const secondOffset = parseInt(match[4]);
                
                if (!this.isValidDate(month, day)) return '';
                
                const today = new Date();
                const currentYear = today.getFullYear();
                const currentMonth = today.getMonth() + 1;
                const year = this.determineYear(month, currentMonth, currentYear);
                
                try {
                    const baseDate = new Date(year, month - 1, day);
                    
                    // 根据"出给"和"平安理财"的位置确定结算天数
                    const giveToPos = text.indexOf('出给');
                    const pingianPos = text.indexOf('平安理财');
                    
                    let ourSettlementDays;
                    if (giveToPos !== -1 && pingianPos !== -1) {
                        ourSettlementDays = pingianPos < giveToPos ? firstOffset : secondOffset;
                    } else {
                        ourSettlementDays = firstOffset;
                    }
                    
                    const ourDate = new Date(baseDate.getTime() - ourSettlementDays * 24 * 60 * 60 * 1000);
                    return ourDate.toISOString().split('T')[0];
                } catch (error) {
                    return '';
                }
            }
            
            extractDateWithSettlement(text) {
                // 提取带清算信息的日期格式
                const patterns = [
                    /(\d{2})(\d{2})\+\d+/,       // MMDD+1
                    /(\d{2})\.(\d{2})\+\d+/,     // MM.DD+1
                    /(\d{1,2})\/(\d{2})\+\d+/    // M/DD+1
                ];
                
                for (let pattern of patterns) {
                    const match = text.match(pattern);
                    if (match) {
                        const month = parseInt(match[1]);
                        const day = parseInt(match[2]);
                        if (this.isValidDate(month, day)) {
                            return { month, day };
                        }
                    }
                }
                return null;
            }
            
            isValidDate(month, day) {
                return month >= 1 && month <= 12 && day >= 1 && day <= 31;
            }
            
            determineYear(month, currentMonth, currentYear) {
                // 简单的年份判断逻辑
                if (month < currentMonth - 6) {
                    return currentYear + 1;
                } else if (month > currentMonth + 6) {
                    return currentYear - 1;
                } else {
                    return currentYear;
                }
            }
            
            parseTerm(text) {
                // 提取期限信息
                let termInfo = '';
                
                // 检查复合期限 (如：2.98Y + 5Y)
                const complexMatch = text.match(this.patterns.termComplex);
                if (complexMatch) {
                    return complexMatch[0];
                }
                
                // 检查单一期限 (如：2.98Y, 93D)
                const singleMatch = text.match(this.patterns.termSingle);
                if (singleMatch) {
                    termInfo = singleMatch[0];
                    
                    // 检查是否有特殊标记 (+N)
                    const specialMatch = text.match(this.patterns.termSpecial);
                    if (specialMatch) {
                        termInfo += ' ' + specialMatch[0];
                    }
                    
                    return termInfo;
                }
                
                // 尝试从行首提取期限
                const lineStartMatch = text.match(/^(\d+(?:\.\d+)?[YD])/);
                if (lineStartMatch) {
                    return lineStartMatch[1];
                }
                
                return '';
            }
            
            parseSettlement(text) {
                // 提取清算速度信息
                if (!text) return 'T+0';
                
                const settlementInfo = this.extractSettlementInfo(text);
                return settlementInfo.speed || 'T+0';
            }
            
            extractSettlementInfo(text) {
                // 提取清算速度和交易场所（返回对象）
                if (!text) {
                    return { speed: '', venue: '' };
                }
                
                try {
                    // 显式“+N”在“出给”之前：直接取该 N 作为我方清算
                    const explicitPlusBeforeGive = text.match(/(?:\b|\s)(\d{1,2}[.\-\/]\d{1,2})?\s*\+\s*(\d+)\b(?=[^\n]*出给)/);
                    if (explicitPlusBeforeGive) {
                        const n = parseInt(explicitPlusBeforeGive[2]);
                        if (!isNaN(n)) return { speed: `T+${n}`, venue: '银行间' };
                    }

                    // 交易所优先判断
                    if (this.patterns.settlementExchange.test(text)) {
                        return { speed: 'T+0', venue: '交易所' };
                    }
                    
                    // 远期判断
                    if (this.patterns.settlementRemote.test(text)) {
                        return { speed: '远期', venue: '银行间' };
                    }
                    
                    // 检查T+0和T+1的位置
                    const t0Matches = Array.from(text.matchAll(this.patterns.settlementT0));
                    const t1Matches = Array.from(text.matchAll(this.patterns.settlementT1));
                    
                    const lastT0Pos = t0Matches.length > 0 ? t0Matches[t0Matches.length - 1].index : -1;
                    const lastT1Pos = t1Matches.length > 0 ? t1Matches[t1Matches.length - 1].index : -1;
                    
                    if (lastT0Pos >= 0 && lastT1Pos >= 0) {
                        // 取位置更靠后的
                        if (lastT1Pos > lastT0Pos) {
                            return { speed: 'T+1', venue: '银行间' };
                        } else {
                            return { speed: 'T+0', venue: '银行间' };
                        }
                    } else if (lastT1Pos >= 0) {
                        return { speed: 'T+1', venue: '银行间' };
                    } else if (lastT0Pos >= 0) {
                        return { speed: 'T+0', venue: '银行间' };
                    }
                    
                    return { speed: '', venue: '' };
                } catch (error) {
                    return { speed: '', venue: '' };
                }
            }
            
            extractPrices(text) {
                // 提取价格信息（净价、全价）
                if (!text) return { netPrice: '', fullPrice: '' };
                
                let netPrice = '';
                let fullPrice = '';
                
                const netMatch = text.match(/净价[：:]\s*(\d+(?:\.\d+)?)/);
                if (netMatch) {
                    netPrice = netMatch[1];
                }
                
                const fullMatch = text.match(/全价[：:]\s*(\d+(?:\.\d+)?)/);
                if (fullMatch) {
                    fullPrice = fullMatch[1];
                }
                
                return { netPrice, fullPrice };
            }
            
            
            
            isInstitutionName(text) {
                // 判断是否为机构名称
                const institutionKeywords = [
                    '证券', '银行', '基金', '保险', '信托', '资管', '资产', 
                    '投资', '金融', '财富', '资本', '控股', '集团', '公司'
                ];
                
                return institutionKeywords.some(keyword => text.includes(keyword));
            }
            
            isValidInstitutionName(text) {
                // 验证是否为有效的机构名称（按清洁版.py逻辑）
                if (!text || text.length < 2) return false;
                
                const institutionSuffixes = [
                    '银行', '证券', '基金', '理财', '信托', '资管', '保险',
                    '农商', '农商行', '农信社', '农合行', '公司', '集团', '投资', '资产', '养老'
                ];
                
                return institutionSuffixes.some(suffix => text.includes(suffix));
            }
            
            extractInstitutionNameBefore(text) {
                // 从"出给"前的文本中提取机构名称（按清洁版.py逻辑）
                if (!text) return "";
                
                // 去掉开头的标记和序号
                text = text.replace(/^【[^】]+】\d+\)/, '').trim();
                text = text.replace(/^\d+[【。]/, '').trim();
                
                const words = [];
                for (let word of text.trim().split(/\s+/)) {
                    if (/^(明天|今天|后天|\d{2}\.\d{2})[+\-]\d+$/.test(word)) continue;
                    if (/^\d+\.?\d*$/.test(word)) continue;
                    if (['买入', '卖出'].includes(word)) continue;
                    words.push(word);
                }
                
                if (words.length === 0) return "";
                
                const institutionSuffixes = [
                    '银行', '证券', '基金', '理财', '信托', '资管', '保险',
                    '农商', '农商行', '农信社', '农合行', '公司', '集团', '投资', '资产', '养老'
                ];
                
                // 从后往前查找包含机构后缀的词
                for (let i = words.length - 1; i >= 0; i--) {
                    const word = words[i];
                    const cleanWord = word.replace(/\([^)]*\)/, '').trim();
                    if (!cleanWord) continue;
                    
                    for (let suffix of institutionSuffixes) {
                        if (cleanWord.endsWith(suffix) && cleanWord.length >= suffix.length + 1) {
                            return cleanWord;
                        }
                    }
                }
                
                // 查找有效候选词
                const validCandidates = [];
                for (let i = words.length - 1; i >= 0; i--) {
                    const word = words[i];
                    const cleanWord = word.replace(/\([^)]*\)/, '').trim();
                    if (cleanWord.length < 2) continue;
                    
                    if (/^(\d+[YD]|买入|卖出|行权|到期|\d+\.\d+|\d+\.\d+到期)$/.test(cleanWord)) continue;
                    if (cleanWord.length === 2 && this.isLikelyPersonName(cleanWord)) continue;
                    if (/^\d{2}/.test(cleanWord) && !/[\u4e00-\u9fa5]/.test(cleanWord.substring(2))) continue;
                    
                    validCandidates.push(cleanWord);
                }
                
                return validCandidates.length > 0 ? validCandidates[0] : "";
            }
            
            extractInstitutionNameAfter(text) {
                // 从"出给"后的文本中提取机构名称（按清洁版.py逻辑）
                if (!text) return "";
                
                // 去掉【请求】等标记内容
                const requestPos = text.indexOf("【请求】");
                if (requestPos !== -1) {
                    text = text.substring(0, requestPos).trim();
                }
                
                // 去掉逗号后面的内容
                text = text.replace(/[,，].*$/, '').trim();
                
                // 查找机构模式
                const institutionPattern = /([\u4e00-\u9fa5]+(?:银行|证券|基金|理财|信托|资管|保险|农商行|农商|农信社|农合行))/;
                let match = text.match(institutionPattern);
                if (match) {
                    return match[1].trim();
                }
                
                // 查找中文模式
                const chinesePattern = /^([^\d+\-/\s,，]{2,}?)/;
                match = text.match(chinesePattern);
                if (match) {
                    const candidate = match[1].trim();
                    if (!/^(\d+[YD]|买入|卖出|行权|到期|\d+\.\d+|\d+\.\d+到期)$/.test(candidate)) {
                        return candidate;
                    }
                }
                
                return "";
            }
            
            isLikelyPersonName(text) {
                // 判断是否可能是人名（按清洁版.py逻辑）
                if (text.length === 2) {
                    const commonSurnames = [
                        '李', '王', '张', '刘', '陈', '杨', '赵', '黄', '周', '吴',
                        '徐', '孙', '胡', '朱', '高', '林', '何', '郭', '马', '罗',
                        '梁', '宋', '郑', '谢', '韩', '唐', '冯', '于', '董', '萧'
                    ];
                    return commonSurnames.includes(text[0]);
                }
                return false;
            }
            
            parseYieldType(text) {
                // 提取收益率类型
                if (text.includes('行权')) {
                    return '行权收益率';
                }
                
                if (text.includes('到期')) {
                    return '到期收益率';
                }
                
                // 检查是否有双边报价
                const bidOfferMatch = text.match(this.patterns.bidOfferPair);
                if (bidOfferMatch) {
                    return '双边报价';
                }
                
                // 默认为到期收益率
                return this.parseYield(text).value ? '到期收益率' : '';
            }
            
            parseRemarks(text) {
                // 提取备注信息
                const remarks = [];
                
                // 确保text存在
                if (!text) return '';
                
                // 提取期限备注
                const termMatch = text.match(/\+\s*N\([^)]*\)/);
                if (termMatch) {
                    remarks.push(termMatch[0]);
                }
                
                
                // 提取双边报价信息
                const bidOfferMatch = text.match(this.patterns.bidOfferPair);
                if (bidOfferMatch) {
                    remarks.push(`双边报价：${bidOfferMatch[0]}`);
                }
                
                // 提取带星号的收益率
                const starYieldMatch = text.match(this.patterns.yieldWithStar);
                if (starYieldMatch) {
                    remarks.push(`参考收益率：${starYieldMatch[0]}`);
                }
                
                // 提取【请求】信息
                const requestMatch = text.match(/【请求】([^【】]+)(?=【|$)/);
                if (requestMatch) {
                    remarks.push(`请求：${requestMatch[1].trim()}`);
                }
                
                // 提取费用信息
                const feeInfo = this.parseFeeInfo(text);
                if (feeInfo) {
                    remarks.push(feeInfo);
                }
                
                // 提取产品信息
                const productInfo = this.parseProductInfo(text);
                if (productInfo) {
                    remarks.push(`产品：${productInfo}`);
                }
                
                // 提取括号内的备注
                const parenthesesMatch = text.match(/\([^)]+\)/g);
                if (parenthesesMatch) {
                    parenthesesMatch.forEach(match => {
                        if (!match.includes('+N') && !remarks.includes(match)) {
                            const content = match.substring(1, match.length - 1);
                            // 过滤已经提取的信息
                            if (!remarks.some(r => r.includes(content))) {
                                remarks.push(content);
                            }
                        }
                    });
                }
                
                return remarks.join('; ');
            }
            
            parseFeeInfo(text) {
                // 提取费用信息
                if (!text) return '';
                
                const feePatterns = [
                    /留\s*(\d*)\s*厘/,
                    /(\d+厘)/,
                    /几厘/,
                    /费用[：:]\s*(\d+(?:\.\d+)?%?)/
                ];
                
                for (let pattern of feePatterns) {
                    const match = text.match(pattern);
                    if (match) {
                        return `费用：${match[0]}`;
                    }
                }
                
                return '';
            }
            
            parseProductInfo(text) {
                // 提取产品信息（增强支持更多产品名称格式）
                if (!text) return '';
                
                const productPatterns = [
                    /([^,，\s]*信托[^,，\s]*)/,
                    /([^,，\s]*集合资产管理计划[^,，\s]*)/,
                    /([^,，\s]*资管[^,，\s]*)/,
                    /([^,，\s]*金穗\d+号?)/,
                    /([^,，\s]*理财产品[^,，\s]*)/,
                    // 新增：支持"XX安盛XX号"等格式
                    /([\u4e00-\u9fa5]+安盛[\u4e00-\u9fa5\d]*号)/,
                    // 新增：支持以"号"结尾的产品名称（至少4个字符）
                    /([\u4e00-\u9fa5]{4,}号)/,
                    // 新增：支持特定的基金/产品名称模式
                    /([\u4e00-\u9fa5]+合信[\u4e00-\u9fa5\d]*号?)/,
                    /([\u4e00-\u9fa5]+专项[\u4e00-\u9fa5\d]*)/,
                    /([\u4e00-\u9fa5]+计划[\u4e00-\u9fa5\d]*号?)/
                ];
                
                for (let pattern of productPatterns) {
                    const matches = text.match(pattern);
                    if (matches && matches[1]) {
                        const product = matches[1].trim();
                        if (product && product.length > 2) {
                            return product;
                        }
                    }
                }
                
                return '';
            }
            
            parseAccountName(text) {
                // 旧接口做别名，统一走增强版
                return this.extractAccountName(text);
            }
            
            _extractAccountFromSegment(segment) {
                // 从文本片段中精确提取账户名称
                if (!segment) return { name: '', confidence: 0 };
                
                // 处理逗号分隔的复杂结构
                const parts = segment.split(/[,，]/);
                let bestMatch = { name: '', confidence: 0 };
                
                // 从后往前搜索，优先选择包含产品关键词的部分
                for (let i = parts.length - 1; i >= 0; i--) {
                    const part = parts[i].trim();
                    if (!part) continue;
                    
                    const result = this._analyzeAccountNameCandidate(part);
                    if (result.confidence > bestMatch.confidence) {
                        bestMatch = result;
                    }
                }
                
                // 如果没有找到高质量匹配，尝试完整片段
                if (bestMatch.confidence < 8) {
                    const wholeResult = this._analyzeAccountNameCandidate(segment);
                    if (wholeResult.confidence > bestMatch.confidence) {
                        bestMatch = wholeResult;
                    }
                }
                
                return bestMatch;
            }
            
            _analyzeAccountNameCandidate(candidate) {
                // 分析候选账户名称的质量和可信度
                if (!candidate || candidate.length < 3) {
                    return { name: '', confidence: 0 };
                }
                
                let confidence = 0;
                let cleanName = candidate.trim();
                
                // 高质量模式：包含明确的产品标识符
                const highQualityPatterns = [
                    { pattern: /([^\s]+信托[^\s]*?\d+号)/i, points: 15 },  // "外贸信托臻今60号"
                    { pattern: /([^\s]+集合[^\s]*?计划)/i, points: 14 },   // "XX集合资产管理计划"
                    { pattern: /([^\s]+资管[^\s]*?计划)/i, points: 13 },   // "XX资管计划"
                    { pattern: /([^\s]*金穗\d+号?)/i, points: 12 },        // "金穗10号"
                    { pattern: /([^\s]+安盛[^\s]*?\d+号)/i, points: 12 },  // "创金合信安盛1号"
                    { pattern: /([^\s]+专项[^\s]*?债)/i, points: 11 },     // "XX专项债"
                    { pattern: /([^\s]+养老[^\s]*?\d+号?)/i, points: 11 }  // "XX养老金1号"
                ];
                
                for (const { pattern, points } of highQualityPatterns) {
                    const match = cleanName.match(pattern);
                    if (match) {
                        return { name: match[1], confidence: points };
                    }
                }
                
                // 中等质量模式：包含产品关键词但格式不够标准
                const mediumQualityPatterns = [
                    { keyword: '信托', minLength: 4, points: 9 },
                    { keyword: '资管', minLength: 4, points: 8 },
                    { keyword: '集合', minLength: 5, points: 8 },
                    { keyword: '计划', minLength: 4, points: 7 },
                    { keyword: '专户', minLength: 4, points: 7 }
                ];
                
                for (const { keyword, minLength, points } of mediumQualityPatterns) {
                    if (cleanName.includes(keyword) && cleanName.length >= minLength) {
                        // 检查是否以数字结尾（常见的产品编号格式）
                        if (/\d+号?$/.test(cleanName)) {
                            confidence = Math.max(confidence, points + 2);
                        } else {
                            confidence = Math.max(confidence, points);
                        }
                    }
                }
                
                // 低质量模式：仅包含"号"结尾，可能是产品
                if (confidence < 6 && /^[\u4e00-\u9fa5]{3,}[A-Za-z0-9]*\d+号$/.test(cleanName)) {
                    confidence = 6;
                }
                
                // 过滤明显的非产品名称
                const invalidPatterns = [
                    /^(证券|银行|基金|公司|集团)$/,
                    /^(买入|卖出|交易|报价)$/,
                    /^(今天|明天|T\+\d)$/,
                    /^\d+(\.\d+)?$/,  // 纯数字
                    /^[A-Z]+$/        // 纯字母
                ];
                
                for (const invalid of invalidPatterns) {
                    if (invalid.test(cleanName)) {
                        return { name: '', confidence: 0 };
                    }
                }
                
                return confidence > 0 ? { name: cleanName, confidence } : { name: '', confidence: 0 };
            }
            
            _searchProductPatternsInText(text) {
                // 在全文中搜索产品名称模式（低优先级备选方案）
                const globalPatterns = [
                    /([^\s,，]*信托[^\s,，]*\d+号)/i,
                    /([^\s,，]*集合[^\s,，]*计划)/i,
                    /([^\s,，]*资管[^\s,，]*\d*号?)/i,
                    /([^\s,，]*金穗\d+号?)/i,
                    /([\u4e00-\u9fa5]{4,}\d+号)/  // 通用"XX数字号"模式
                ];
                
                for (const pattern of globalPatterns) {
                    const match = text.match(pattern);
                    if (match && match[1].length >= 4) {
                        const result = this._analyzeAccountNameCandidate(match[1]);
                        if (result.confidence > 0) {
                            return result.name;
                        }
                    }
                }
                
                return '';
            }
            extractProductNameFromText(text) {
                // 从包含联系人信息的文本中精确提取产品户名
                if (!text) return '';
                
                // 匹配产品名称模式：X信托XX号、XX集合计划、XX资管等
                const productPatterns = [
                    /([^\s]+信托[^\s]*?号)/,  // 如"外贸信托臻今60号"
                    /([^\s]+集合[^\s]*?计划)/,  // 如"XX集合资产管理计划"
                    /([^\s]+资管[^\s]*?号?)/,   // 如"XX资管计划"
                    /([^\s]+金穗\d+号?)/,       // 如"金穗10号"
                    /([^\s]+安盛[^\s]*?号)/     // 如"创金合信安盛1号"
                ];
                
                for (const pattern of productPatterns) {
                    const match = text.match(pattern);
                    if (match) {
                        return match[1];
                    }
                }
                
                // 如果没有匹配到精确模式，返回第一个包含关键词的词汇
                const words = text.split(/\s+/);
                for (const word of words) {
                    if (/信托.*号|集合.*计划|资管|金穗\d+/.test(word)) {
                        return word;
                    }
                }
                
                return text;
            }
            
            parseOrderMethod(text) {
                // 统一输出：请求 / 对话 / 固收平台；没有则置空
                if (!text) return '';
                
                let orderMethod = '';
                let confidence = 0;
                const s = String(text);
                
                // 1) 请求（兼容无方括号写法）
                if ((!orderMethod || confidence < 10) && /(?:【\s*)?请求(?:\s*】)?/.test(s)) {
                    orderMethod = '请求';
                    confidence = 10;
                }
                
                // 2) 固收平台（关键词更全：固收平台/固收联系/【固收】联系/固收 联系/固收平台 交易）
                if ((!orderMethod || confidence < 9) && /(固收平台|固收联系|【固收】\s*联系|固收\s*联系|固收平台\s*交易)/.test(s)) {
                    orderMethod = '固收平台';
                    confidence = 9;
                }
                
                // 3) 对话（仅当文本包含“对话”字样时认定）
                if ((!orderMethod || confidence < 8) && /对话/.test(s)) {
                    orderMethod = '对话';
                    confidence = 8;
                }
                
                return orderMethod;
            }
            
            _normalizeOrderMethod(methodStr) {
                // 规范化发单方式字符串
                if (!methodStr) return '';
                
                const normalized = methodStr.toLowerCase();
                if (/qq|q/.test(normalized)) return 'QQ';
                if (/微信|wx|wechat/.test(normalized)) return '微信';
                if (/电话|tel|phone/.test(normalized)) return '电话';
                if (/邮件|email|mail/.test(normalized)) return '邮件';
                
                return '';
            }
            
            parseCounterpartyTrader(text, orderMethod) {
                // 仅在“对话/固收平台”场景下提取交易员；其他场景置空
                if (!text) return '';
                const allowed = new Set(['对话', '固收平台']);
                if (orderMethod && !allowed.has(orderMethod)) return '';

                let traderName = '';
                let confidence = 0;

                // 分割主句/请求段，便于分别匹配
                const parts = (typeof splitMainAndRequest === 'function') ? splitMainAndRequest(text) : { main: String(text), request: '' };
                const main = parts.main || '';
                const request = parts.request || '';

                const normalizeCandidate = (name) => String(name || '').replace(/[\*\u00D7×（）()]/g, '').trim();
                const accept = (name, score) => {
                    const n = normalizeCandidate(name);
                    if (this._isValidTraderName(n) && score > confidence) {
                        traderName = n;
                        confidence = score;
                    }
                };

                // A. 对话：支持“发 机构 * 姓名（…）”
                const dialogPat = /发\s*[^\s,，]*?(?:证券|银行|基金|理财|信托|资管|保险|公司|集团|投顾|经纪|投行|券商)[^\s,，]*?\s*[\*\u00D7×]?\s*([^\s,，()（）]{2,4})/;
                const dm = main.match(dialogPat);
                if (dm) accept(dm[1], 12);
                if (!traderName) {
                    const dr = request.match(dialogPat);
                    if (dr) accept(dr[1], 12);
                }

                // B. 固收平台：固收联系xxx 姓名 / 【固收】 联系 xxx 姓名
                if (!traderName) {
                    const gs = request.match(/(?:固收平台|固收联系|【固收】\s*联系|固收\s*联系)[^\s,，]*?\s+([\u4e00-\u9fa5]{2,4})(?=(?:\s|,|，|$))/)
                           || main.match(/(?:固收平台|固收联系|【固收】\s*联系|固收\s*联系)[^\s,，]*?\s+([\u4e00-\u9fa5]{2,4})(?=(?:\s|,|，|$))/);
                    if (gs) accept(gs[1], 10);
                }

                // C. 联系人/联系 + 姓名 (+ 可选联系方式)
                if (!traderName) {
                    const c1 = request.match(/(?:联系人|联系)\s*([^\s,，]{2,4})\s*(?:QQ|qq|QT|qt|微信|WX|wx)?/)
                           || main.match(/(?:联系人|联系)\s*([^\s,，]{2,4})\s*(?:QQ|qq|QT|qt|微信|WX|wx)?/);
                    if (c1) accept(c1[1], 9);
                }

                // D. 姓名紧邻 QQ/QT/微信 号码
                if (!traderName) {
                    const c2 = request.match(/([\u4e00-\u9fa5]{2,4})\s*(?:QQ|qq|QT|qt|微信|WX|wx)\s*[:：]?\s*\d{5,}/)
                           || main.match(/([\u4e00-\u9fa5]{2,4})\s*(?:QQ|qq|QT|qt|微信|WX|wx)\s*[:：]?\s*\d{5,}/);
                    if (c2) accept(c2[1], 9);
                }

                // E. 兜底：找/联系 + 姓名
                if (!traderName) {
                    const simple = request.match(/(?:联系|找)\s*([^\s,，)）*]{2,4})/)
                                 || main.match(/(?:联系|找)\s*([^\s,，)）*]{2,4})/);
                    if (simple) accept(simple[1], 7);
                }

                return traderName;
            }
            
            _isValidTraderName(name) {
                // 强化的交易员姓名验证
                if (!this.isValidChineseName(name)) return false;
                
                // 额外检查：排除特定的业务术语
                const businessTerms = [
                    '证券', '银行', '基金', '理财', '信托', '保险', '公司', '集团',
                    '请求', '报价', '合单', '出给', '明天', '今天', '交易', '买入', '卖出',
                    '国利', '中诚', '国际', '信唐', '上田', '平安', '固收', '投资'
                ];
                
                if (businessTerms.includes(name)) return false;
                
                // 检查是否为常见中文姓氏开头
                const commonSurnames = [
                    '王', '李', '张', '刘', '陈', '杨', '赵', '黄', '周', '吴',
                    '徐', '孙', '胡', '朱', '高', '林', '何', '郭', '马', '罗',
                    '梁', '宋', '郑', '谢', '韩', '唐', '冯', '于', '董', '萧',
                    '程', '曹', '袁', '邓', '许', '傅', '沈', '曾', '彭', '吕'
                ];
                
                // 如果是2-3字姓名且以常见姓氏开头，增加可信度
                if (name.length >= 2 && name.length <= 3 && commonSurnames.includes(name[0])) {
                    return true;
                }
                
                // 4字姓名可能是复姓，需要更严格验证
                if (name.length === 4) {
                    const doubleSurnames = ['欧阳', '上官', '东方', '西门', '南宫', '司马', '司徒', '司空'];
                    return doubleSurnames.some(surname => name.startsWith(surname));
                }
                
                return name.length >= 2 && name.length <= 3;
            }
            
            _extractIntermediaryInfo(text) {
                // 【阶段3新增】完善的中介信息提取（支持6个中介：国利/中诚/国际/信唐/上田/平安）
                const result = { intermediary: '', sequence: '' };
                let confidence = 0;
                
                // 1. 最高优先级：从【中介标记】中提取
                const intermediaryMatch = text.match(/【([^】]+)】/);
                if (intermediaryMatch && intermediaryMatch[1]) {
                    const source = intermediaryMatch[1];
                    const excludedSources = new Set(['请求', '备注', '注释', '说明', '补充', '提示']);
                    
                    if (source && !excludedSources.has(source)) {
                        const mappedIntermediary = this._mapIntermediaryName(source);
                        if (mappedIntermediary && confidence < 15) {
                            result.intermediary = mappedIntermediary;
                            confidence = 15;
                        }
                    }
                }
                
                // 2. 中级优先级：从文本中识别中介关键词
                if (!result.intermediary || confidence < 10) {
                    const intermediaryPatterns = [
                        { pattern: /(?:^|\s|,|，)(国利|TP)(?:\s|,|，|$)/, name: '国利', priority: 12 },
                        { pattern: /(?:^|\s|,|，)(中诚|BGC)(?:\s|,|，|$)/, name: '中诚', priority: 12 },
                        { pattern: /(?:^|\s|,|，)(国际|ICAP)(?:\s|,|，|$)/, name: '国际', priority: 12 },
                        { pattern: /(?:^|\s|,|，)(信唐|XT)(?:\s|,|，|$)/, name: '信唐', priority: 12 },
                        { pattern: /(?:^|\s|,|，)(上田|ST)(?:\s|,|，|$)/, name: '上田', priority: 12 },
                        { pattern: /(?:^|\s|,|，)(平安|PALS)(?:\s|,|，|$)/, name: '平安', priority: 12 }
                    ];
                    
                    for (const { pattern, name, priority } of intermediaryPatterns) {
                        if (pattern.test(text) && priority > confidence) {
                            result.intermediary = name;
                            confidence = priority;
                        }
                    }
                }
                
                // 3. 提取中介序号（支持多种格式）
                const seqPatterns = [
                    { pattern: /【[^】]+】\s*(\d+)\)/, confidence: 15 }, // "【国利】1)"
                    { pattern: /^\s*(\d+)\)\s*/, confidence: 12 },        // 行首"1)"
                    { pattern: /序号[：:]\s*(\d+)/, confidence: 10 },      // "序号：1"
                    { pattern: /编号[：:]\s*(\d+)/, confidence: 10 },      // "编号：1"
                    { pattern: /(?:^|\s)(\d+)(?:\s|$)/, confidence: 6 }   // 独立数字，最低优先级
                ];
                
                let seqConfidence = 0;
                for (const { pattern, confidence: patternConfidence } of seqPatterns) {
                    const match = text.match(pattern);
                    if (match && match[1]) {
                        const seq = match[1];
                        // 对独立数字进行额外验证
                        const actualConfidence = this._validateSequenceNumber(seq, text, patternConfidence);
                        if (actualConfidence > seqConfidence) {
                            result.sequence = seq;
                            seqConfidence = actualConfidence;
                        }
                    }
                }
                
                return result;
            }
            
            _mapIntermediaryName(source) {
                // 【阶段3新增】完整的中介名称映射表
                const intermediaryMap = new Map([
                    // 中文全称
                    ['国利', '国利'], ['中诚', '中诚'], ['国际', '国际'],
                    ['信唐', '信唐'], ['上田', '上田'], ['平安', '平安'],
                    
                    // 英文缩写
                    ['TP', '国利'], ['BGC', '中诚'], ['ICAP', '国际'],
                    ['XT', '信唐'], ['ST', '上田'], ['PALS', '平安'],
                    
                    // 变体和别名
                    ['国利宝', '国利'], ['TP宝', '国利'],
                    ['中诚信', '中诚'], ['BGC中诚', '中诚'],
                    ['国际资本', '国际'], ['ICAP国际', '国际'],
                    ['信唐证券', '信唐'], ['XT信唐', '信唐'],
                    ['上田八木', '上田'], ['ST上田', '上田'],
                    ['平安证券', '平安'], ['平安理财', '平安'], ['PALS平安', '平安']
                ]);
                
                // 精确匹配
                if (intermediaryMap.has(source)) {
                    return intermediaryMap.get(source);
                }
                
                // 模糊匹配（包含关系）
                for (const [key, value] of intermediaryMap) {
                    if (source.includes(key) || key.includes(source)) {
                        return value;
                    }
                }
                
                // 如果不是已知中介，但格式合理，保留原文
                if (/^[A-Z]{2,6}$/.test(source) || /^[\u4e00-\u9fa5]{2,4}$/.test(source)) {
                    return source;
                }
                
                return '';
            }
            
            _validateSequenceNumber(seq, text, baseConfidence) {
                // 【阶段3新增】验证序号的可信度
                if (baseConfidence < 8) {
                    // 对于低可信度的独立数字，进行额外检查
                    
                    // 如果文本中包含多个数字，降低可信度
                    const numberMatches = text.match(/\d+/g);
                    if (numberMatches && numberMatches.length > 3) {
                        baseConfidence -= 2;
                    }
                    
                    // 如果数字在收益率、交易量附近，进一步降低可信度
                    if (/\d+\.\d{2,4}/.test(text) || /\d{3,6}[万亿]/.test(text)) {
                        baseConfidence -= 2;
                    }
                    
                    // 序号一般在1-99范围内
                    const seqNum = parseInt(seq);
                    if (seqNum > 99 || seqNum < 1) {
                        baseConfidence = 0;
                    }
                }
                
                return Math.max(0, baseConfidence);
            }
            
            isValidChineseName(name) {
                // 验证是否为有效的中文姓名
                if (!name || name.length < 2 || name.length > 4) {
                    return false;
                }
                
                if (!/^[\u4e00-\u9fa5]{2,4}$/.test(name)) {
                    return false;
                }
                
                const invalidNames = [
                    '请求', '报价', '合单', '出给', '明天', '今天', '交易', '买入', '卖出',
                    '证券', '银行', '基金', '理财', '信托', '保险', '公司', '集团'
                ];
                
                return !invalidNames.includes(name);
            }

            parseLine(line) {
                // 先提取对手方信息
                const counterpartyInfo = this.parseCounterparty(line);
                
                // 提取发单方式
                const orderMethod = this.parseOrderMethod(line);
                
                // 提取结算信息
                const settlementInfo = this.extractSettlementInfo(line);
                
                // 提取价格信息
                const priceInfo = this.extractPrices(line);
                
                const result = {
                    原始文本: line,
                    原中介编号: counterpartyInfo.intermediarySeq || '',  // 修改：使用intermediarySeq
                    债券代码: this.parseBondCode(line),
                    债券名称: this.parseBondName(line),
                    期限: this.parseTerm(line),
                    方向: counterpartyInfo.direction || this.extractDirection(line),
                    对手方: counterpartyInfo.counterparty || '',
                    终端机构名称: counterpartyInfo.terminalInstitution || '',  // 新增
                    做市商机构名称: counterpartyInfo.marketMaker || '',       // 新增
                    中介: counterpartyInfo.intermediary || '',
                    户名: counterpartyInfo.accountName || this.extractAccountName(line),
                    发单方式: counterpartyInfo.orderMethod || this.parseOrderMethod(line),  // 修改
                    对手交易员: counterpartyInfo.counterpartyTrader || this.parseCounterpartyTrader(line, orderMethod),  // 修改
                    交易量: this.parseVolume(line),
                    收益率: '',
                    收益率类型: '',
                    净价: priceInfo.netPrice,
                    全价: priceInfo.fullPrice,
                    交易日期: this.parseDate(line),
                    清算速度: settlementInfo.speed || '',   // 去掉无脑T+0
                    // 优先取显式，推断在对象创建后进行
                    交易场所: settlementInfo.venue || '',
                    备注: this.parseRemarks(line),
                    状态: '待执行',
                    完成进度: 0,
                    交易员: ''
                };
                // 对象创建后再推断交易场所，避免引用未初始化的 result
                if (!result.交易场所) {
                    const inferredVenue = this._inferTradingVenue(result);
                    if (inferredVenue) result.交易场所 = inferredVenue;
                }
                
                // 解析收益率（传入方向）
                const yieldInfo = this.parseYield(line, result.方向);
                result.收益率 = yieldInfo.value;
                result.收益率类型 = yieldInfo.type;
                
                // 验证必要字段
                if (!result.债券代码 && !result.债券名称) {
                    result.解析状态 = '失败';
                    result.错误信息 = '无法识别债券信息';
                } else if (!result.方向) {
                    result.解析状态 = '警告';
                    result.错误信息 = '未识别到交易方向';
                } else {
                    result.解析状态 = '成功';
                }
                
                // 【阶段4优化】统一数据清理和字段验证
                const cleanedResult = this._cleanAndValidateResult(result);
                
                return cleanedResult;
            }

            parseText(text) {
                const lines = text.split('\n').filter(line => line.trim());
                
                // 尝试使用块级解析
                if (this.shouldUseBlockParsing(text)) {
                    return this.parseByBlocks(lines);
                }
                
                // 默认逐行解析
                return lines.map(line => this.parseLine(line));
            }
            
            shouldUseBlockParsing(text) {
                // 检查是否适合块级解析
                const hasMultiLineStructure = text.includes('【bid】') || text.includes('【ofr】') || 
                                             text.includes('【BID】') || text.includes('【OFR】');
                const hasCodePattern = this.patterns.codeExchange.test(text) || 
                                      this.patterns.codeInterbank.test(text);
                return hasMultiLineStructure || hasCodePattern;
            }
            
            parseByBlocks(lines) {
                // FSM块级解析系统
                const blocks = this.splitIntoBlocks(lines);
                const results = [];
                
                for (const block of blocks) {
                    const parsed = this.parseBlock(block);
                    if (parsed) {
                        results.push(parsed);
                    }
                }
                
                return results;
            }
            
            splitIntoBlocks(lines) {
                // 将文本分割成逻辑块
                const blocks = [];
                let currentBlock = [];
                let contextDirection = null;
                
                for (const line of lines) {
                    const lowerLine = line.toLowerCase();
                    
                    // 检测方向上下文标记
                    if (lowerLine.includes('【bid】')) {
                        contextDirection = '买入';
                        continue;
                    }
                    if (lowerLine.includes('【ofr】')) {
                        contextDirection = '卖出';
                        continue;
                    }
                    
                    // 检测新块的开始（包含债券代码）
                    const hasCode = this.parseBondCode(line);
                    if (hasCode && currentBlock.length > 0) {
                        // 保存当前块
                        blocks.push({
                            lines: currentBlock,
                            contextDirection: contextDirection
                        });
                        currentBlock = [];
                    }
                    
                    currentBlock.push(line);
                }
                
                // 保存最后一个块
                if (currentBlock.length > 0) {
                    blocks.push({
                        lines: currentBlock,
                        contextDirection: contextDirection
                    });
                }
                
                return blocks;
            }
            
            parseBlock(block) {
                // 解析一个逻辑块
                const { lines, contextDirection } = block;
                if (!lines || lines.length === 0) return null;
                
                // 合并所有行成一个完整文本
                const fullText = lines.join(' ');
                
                // 先提取对手方信息
                const counterpartyInfo = this.parseCounterparty(fullText);
                
                // 提取发单方式
                const orderMethod = this.parseOrderMethod(fullText);
                
                const result = {
                    原始文本: fullText,
                    债券代码: '',
                    债券名称: '',
                    期限: '',
                    方向: contextDirection || '',
                    对手方: counterpartyInfo.counterparty || '',
                    中介: counterpartyInfo.intermediary || '',
                    中介序号: counterpartyInfo.intermediarySeq || '',
                    户名: '',
                    发单方式: orderMethod,
                    对手交易员: '',
                    交易量: 0,
                    收益率: null,
                    收益率类型: '',
                    交易日期: '',
                    清算速度: 'T+0',
                    备注: '',
                    状态: '待执行',
                    完成进度: 0,
                    交易员: ''
                };
                
                // 从第一行提取主要信息
                const firstLine = lines[0] || '';
                result.债券代码 = this.parseBondCode(firstLine);
                result.债券名称 = this.parseBondName(firstLine);
                result.期限 = this.parseTerm(fullText);
                result.交易日期 = this.parseDate(fullText);
                result.清算速度 = this.parseSettlement(fullText);
                result.户名 = this.extractAccountName(fullText);
                result.对手交易员 = this.parseCounterpartyTrader(fullText, orderMethod);
                result.备注 = this.parseRemarks(fullText);
                
                // 从所有行中查找交易信息
                for (const line of lines) {
                    // 更新方向（如果找到更具体的）
                    const direction = this.extractDirection(line);
                    if (direction) {
                        result.方向 = direction;
                    }
                    
                    // 查找交易量
                    const volume = this.parseVolume(line);
                    if (volume > 0) {
                        result.交易量 = volume;
                    }
                    
                    // 查找收益率
                    const yieldRate = this.parseYield(line).value;
                    if (yieldRate !== null) {
                        result.收益率 = yieldRate;
                    }
                }
                
                // 设置收益率类型
                result.收益率类型 = this.parseYieldType(fullText);
                
                // 如果方向还是空的，使用counterpartyInfo的方向
                if (!result.方向 && counterpartyInfo.direction) {
                    result.方向 = counterpartyInfo.direction;
                }
                
                // 验证结果
                if (!result.债券代码 && !result.债券名称) {
                    result.解析状态 = '失败';
                    result.错误信息 = '无法识别债券信息';
                } else if (!result.方向) {
                    result.解析状态 = '警告';
                    result.错误信息 = '未识别到交易方向';
                } else {
                    result.解析状态 = '成功';
                }
                
                // 【阶段4优化】统一数据清理和字段验证
                const cleanedResult = this._cleanAndValidateResult(result);
                
                return cleanedResult;
            }
            // FSM块级解析方法
            splitBlocks(lines) {
                const blocks = [];
                let currentBlock = [];
                let contextDirection = null;
                
                for (const rawLine of lines) {
                    if (!rawLine) continue;
                    
                    const line = rawLine.replace(/\*/g, '').trim();
                    const lowerLine = line.toLowerCase();
                    
                    // 方向上下文
                    if (lowerLine.includes('【bid】')) {
                        contextDirection = 'Bid';
                        continue;
                    }
                    if (lowerLine.includes('【ofr】')) {
                        contextDirection = 'Offer';
                        continue;
                    }
                    
                    // 新块：遇到代码行就开块
                    const hasCode = this.parseBondCode(line);
                    if (hasCode && currentBlock.length > 0) {
                        blocks.push({
                            lines: currentBlock,
                            contextDirection: contextDirection
                        });
                        currentBlock = [];
                    }
                    
                    currentBlock.push({
                        text: line,
                        contextDirection: contextDirection
                    });
                }
                
                if (currentBlock.length > 0) {
                    blocks.push({
                        lines: currentBlock,
                        contextDirection: contextDirection
                    });
                }
                
                return blocks;
            }
            
            parseYieldFromQuoteLine(line, currentDirection = null) {
                const s = line.toLowerCase();
                let direction = null;
                
                // 检查买入信号
                for (let verb of this.buyVerbs) {
                    if (s.includes(verb.toLowerCase())) {
                        direction = 'Bid';
                        break;
                    }
                }
                
                // 检查卖出信号（优先级更高）
                for (let verb of this.sellVerbs) {
                    if (s.includes(verb.toLowerCase())) {
                        direction = 'Offer';
                        break;
                    }
                }
                
                if (!direction) {
                    direction = currentDirection; // 上下文继承
                }
                
                // 提取收益率
                const decimals = [];
                const decimalPattern = /\d+\.\d+/g;
                let match;
                while ((match = decimalPattern.exec(s)) !== null) {
                    decimals.push(parseFloat(match[0]));
                }
                
                if (decimals.length === 0) {
                    // 尝试"卖出1.85 1K"这种黏连写法
                    const m = s.match(/(?:卖出|给|bid|ofr)\s*([0-9]+(?:\.[0-9]+)?)/);
                    if (m) {
                        decimals.push(parseFloat(m[1]));
                    }
                }
                
                return {
                    direction: direction,
                    yield: decimals.length > 0 ? decimals[decimals.length - 1] : null
                };
            }
            
            parseAmount(line) {
                const s = line.toLowerCase().replace('~', '');
                const matches = Array.from(s.matchAll(/(\d+(?:\.\d+)?)(kw|k)?/g));
                
                for (let i = matches.length - 1; i >= 0; i--) {
                    const match = matches[i];
                    const num = match[1];
                    const suffix = match[2];
                    
                    if (suffix === 'k' || suffix === 'kw') {
                        return parseInt(parseFloat(num) * 1000);
                    }
                    
                    if (!num.includes('.') && num.length >= 3) {
                        // 排除代码（6-9位）和时间
                        if (num.length >= 6) {
                            continue;
                        }
                        return parseInt(num);
                    }
                }
                
                return null;
            }
            
            extractFromBlock(block) {
                const head = block.lines[0].text;
                const codeMatch = this.parseBondCode(head);
                const code = codeMatch || '';
                const name = head; // 简化处理
                
                // 逆序找最可信报价行
                let targetYield = null;
                let direction = null;
                let amount = null;
                
                for (let i = block.lines.length - 1; i >= 0; i--) {
                    const item = block.lines[i];
                    const quoteResult = this.parseYieldFromQuoteLine(item.text, item.contextDirection);
                    
                    if (quoteResult.direction && quoteResult.yield !== null) {
                        targetYield = quoteResult.yield;
                        direction = quoteResult.direction;
                        amount = this.parseAmount(item.text);
                        break;
                    }
                }
                
                // 如果没有找到报价行，从头行解析参考收益率
                let referenceYield = null;
                if (!targetYield) {
                    const headYield = this.parseYield(head).value;
                    if (headYield) {
                        referenceYield = headYield;
                    }
                }
                
                return {
                    code: code,
                    name: name,
                    direction: direction,
                    target_yield: targetYield,
                    reference_yield: referenceYield,
                    amount_wan: amount
                };
            }
            
            robustParseFreeform(text) {
                const lines = text.split('\n').filter(line => line.trim());
                const blocks = this.splitBlocks(lines);
                const results = [];
                
                for (const block of blocks) {
                    try {
                        const result = this.extractFromBlock(block);
                        if (result.code) {
                            results.push(result);
                        }
                    } catch (error) {
                        console.warn('块解析失败:', error);
                    }
                }
                
                return results;
            }
            
            // 单行解析方法（增强版）
            parseSingleLine(line, lineNum) {
                const record = {
                    序号: lineNum,
                    交易员: '',
                    债券代码: '',
                    债券名称: '',
                    方向: '',
                    中介: '',
                    原中介编号: '',  // 新增字段
                    做市商机构名称: '',
                    终端机构名称: '',
                    户名: '',  // 新增字段
                    交易量: '',
                    收益率: '',
                    收益率类型: '',
                    净价: '',
                    全价: '',
                    交易日期: '',
                    清算速度: '',
                    交易场所: '',
                    发单方式: '',
                    对手交易员: '',
                    备注: '',
                    原始文本: line
                };
                
                // 1. 提取中介信息（优先增强版）
                const intermInfo = this._extractIntermediaryInfo(line);
                record.中介 = intermInfo.intermediary || this.extractIntermediary(line);
                
                // 2. 提取原中介编号（增强版优先）
                record.原中介编号 = intermInfo.sequence || this.extractIntermediarySeq(line);
                
                // 3. 提取户名信息
                record.户名 = this.extractAccountName(line);
                
                // 4. 提取交易量（按行就近识别，避免跨行误串）
                record.交易量 = this.parseVolume(line);
                
                // 5. 提取债券代码（优化格式）
                record.债券代码 = this.parseBondCode(line);
                
                // 6. 提取债券名称
                record.债券名称 = this.parseBondName(line);
                
                // 7. 提取期限信息
                const termInfo = this.parseTerm(line);
                
                // 8. 提取交易方向和对手信息
                const directionInfo = this.extractDirectionAndCounterparties(line);
                record.方向 = directionInfo.direction;
                record.做市商机构名称 = directionInfo.makerInstitution;
                record.终端机构名称 = directionInfo.terminalInstitution;
                
                // 9. 提取收益率信息（就近优先：若该行有数字/单位，使用该行收益率）
                const hasLocalVolumeToken = /(\d+(?:\.\d+)?\s*(?:w|W|万|kw|KW|k(?!w)|K(?!W)|亿|E\b|e\b))/.test(line);
                if (hasLocalVolumeToken) {
                    const localYield = this.parseYield(line, record.方向).value;
                    if (localYield) {
                        record.收益率 = localYield;
                        record.收益率类型 = '到期收益率';
                    } else {
                        const yieldInfo = this.extractYieldInfo(line);
                        record.收益率 = yieldInfo.yield;
                        record.收益率类型 = yieldInfo.yieldType;
                    }
                } else {
                    const yieldInfo = this.extractYieldInfo(line);
                    record.收益率 = yieldInfo.yield;
                    record.收益率类型 = yieldInfo.yieldType;
                }
                
                // 10. 提取价格信息
                const priceInfo = this.extractPrices(line);
                record.净价 = priceInfo.netPrice;
                record.全价 = priceInfo.fullPrice;
                
                // 11. 提取交易日期
                record.交易日期 = this.parseDate(line);
                
                // 12. 提取清算速度和交易场所
                const settlementInfo = this.extractSettlementInfo(line);
                record.清算速度 = settlementInfo.speed;
                record.交易场所 = settlementInfo.venue;
                
                // 13. 提取发单方式和对手交易员
                record.发单方式 = this.parseOrderMethod(line);
                record.对手交易员 = this.parseCounterpartyTrader(line, record.发单方式);
                
                // 14. 提取完整备注
                record.备注 = this.extractCompleteRemarks(line, termInfo);
                
                return record;
            }
            
            // 新增的提取方法
            extractIntermediarySeq(line) {
                // 优先匹配：【中介名称】后的编号
                let match = line.match(/【[^】]+】\s*(\d+)\)/);
                if (match) {
                    return match[1];
                }
                
                // 备选：行首直接的编号
                match = line.match(/^\s*(\d+)\)\s*/);
                if (match) {
                    return match[1];
                }
                
                return '';
            }
            
            
            
            extractIntermediary(line) {
                if (!line) return '';
                
                // 中介映射表（统一为中文显示）
                const intermediaryMap = {
                    '国利': '国利',
                    '中诚': '中诚',
                    '国际': '国际',
                    '信唐': '信唐',
                    '上田': '上田',
                    '平安': '平安',
                    // 支持英文输入映射到中文
                    'TP': '国利',
                    'BGC': '中诚',
                    'ICAP': '国际',
                    'XT': '信唐',
                    'ST': '上田',
                    'PALS': '平安'
                };
                
                try {
                    // 方案1：优先查找有括号的模式
                    const bracketPatterns = [
                        /【\s*([^】\]]+?)\s*】/,  // 标准格式：【xxx】（允许空格）
                        /\[\s*([^\]【】]+?)\s*\]/,  // 方括号格式：[xxx]
                        /\(\s*([^)（）]+?)\s*\)/   // 圆括号格式：(xxx)
                    ];
                    
                    for (let pattern of bracketPatterns) {
                        const match = line.match(pattern);
                        if (match) {
                            const source = match[1].trim();
                            
                            // 检查是否为有效中介（在标准版中 _excluded_sources 可能不存在）
                            if (!this._excluded_sources || !this._excluded_sources.has(source)) {
                                // 查找映射
                                for (let [key, value] of Object.entries(intermediaryMap)) {
                                    if (source.includes(key)) {
                                        return value;
                                    }
                                }
                                return source; // 未映射但有效的中介
                            }
                        }
                    }
                    
                    // 方案2：未匹配到括号时，尝试在前缀区域直接检索六家中介关键字
                    const prefix = line.slice(0, 40);
                    // 去除序号等干扰
                    const normalizedPrefix = prefix.replace(/^\s*\d+\s*[)）.、]?\s*/, '').trim();
                    for (let [key, value] of Object.entries(intermediaryMap)) {
                        if (normalizedPrefix.startsWith(key) || normalizedPrefix.includes(`【${key}`) || normalizedPrefix.includes(`${key}】`)) {
                            return value;
                        }
                    }
                    
                    return '';
                } catch (error) {
                    console.warn('中介信息提取错误:', error);
                    return '';
                }
            }
            
            // ===== 阶段1重构：拆分方向和对手方提取逻辑为独立方法 =====
            
            /**
             * 提取交易方向 - 职责单一的方法
             * @param {string} line 原始文本
             * @returns {string} 交易方向
             */
            extractDirection(line) {
                if (!line) return '';

                // 1. 显式关键词（优先）
                if (line.includes('买入')) return '买入';
                if (line.includes('卖出')) return '卖出';

                // 2. 英文市话
                const t = line.toLowerCase();
                if (/\bbid\b/.test(t)) return '买入';
                if (/\b(ofr|offer|ask)\b/.test(t)) return '卖出';

                // 3. 俗语（拿=买入；给/出=卖出）
                if (/(帮忙拿|要拿|拿一下|收一下|收票|吃掉|扫货|要一下|求一口)/.test(line)) return '买入';
                if (/(?<!出)(给\s*\d+|给一下|报一口|挂一下|抛一下|让一下|放一下|出一下)/.test(line)) return '卖出';

                // 4. 结构推断（"A 出给 B"/"A to B" 以平安视角判断）
                const toMatch = line.match(/([\u4e00-\u9fa5a-zA-Z]+)\s+to\s+([\u4e00-\u9fa5a-zA-Z]+)/);
                if (toMatch) {
                    const A = toMatch[1], B = toMatch[2];
                    if (A.includes('平安理财')) return '卖出';
                    if (B.includes('平安理财')) return '买入';
                }
                const givePos = line.indexOf('出给');
                if (givePos !== -1) {
                    const before = line.substring(0, givePos);
                    const after  = line.substring(givePos + 2);
                    if (before.includes('平安理财')) return '卖出';
                    if (after.includes('平安理财'))  return '买入';
                }

                // 5. 无法判断 -> 返回空，禁止默认为卖出
                return '';
            }
            
            /**
             * 提取终端机构名称 - 基于"出给"结构和交易方向
             * @param {string} line 原始文本
             * @param {string} direction 交易方向
             * @returns {string} 终端机构名称
             */
            extractTerminalInstitution(line, direction) {
                if (!line || !direction) return '';
                
                // 1. 处理"to"结构
                const toMatch = line.match(/([\u4e00-\u9fa5]+[^\s]*?)\s+to\s+([\u4e00-\u9fa5]+[^\s]*?)/);
                if (toMatch) {
                    const partyA = this._cleanInstitutionName(toMatch[1]);
                    const partyB = this._cleanInstitutionName(toMatch[2]);
                    
                    // A to B结构中，B是买方
                    return direction === "买入" ? partyA : partyB;
                }
                
                // 2. 基于"出给"结构提取
                const giveToPos = line.indexOf('出给');
                if (giveToPos === -1) return '';
                
                const beforeGiveTo = line.substring(0, giveToPos).trim();
                const afterGiveTo = line.substring(giveToPos + 2).trim();
                
                const partyA = this._extractInstitutionNameBefore(beforeGiveTo);
                const partyB = this._extractInstitutionNameAfter(afterGiveTo);
                
                // 3. 根据交易方向确定终端机构（显式排除"平安理财"）
                if (direction === "买入") {
                    const cand = this._cleanInstitutionName(partyA);
                    if (!cand || cand.includes('平安理财')) return '';
                    // 防止整段落入（如包含年份/代码/期限），要求至少含机构关键词
                    if (!/(银行|证券|基金|理财|信托|资管|公司|集团|农商|农信)/.test(cand)) return '';
                    return cand;
                } else {
                    const cand = this._cleanInstitutionName(partyB);
                    if (!cand || cand.includes('平安理财')) return '';
                    if (!/(银行|证券|基金|理财|信托|资管|公司|集团|农商|农信)/.test(cand)) return '';
                    return cand;
                }
            }
            
            /**
             * 优化的做市商机构提取 - 专门从【请求】和"发xxx"模式提取
             * @param {string} line 原始文本
             * @returns {string} 做市商机构名称
             */
            extractMakerInstitution(line) {
                if (!line) return '';

                // 【请求】发xxx 优先
                const req = line.match(/(?:【请求】|请求)([^【】]*?)(?=【|$)/);
                if (req) {
                    const fa = req[1].match(/发\s*([^\s,，]+?(?:证券|银行|基金|理财|信托|资管|保险|公司|投顾)(?:[\(（][^\)）]*[\)）])?)/);
                    if (fa && fa[1] && fa[1] !== '请求') return fa[1].trim();
                }
                
                // 尝试直接匹配"发XXX"格式
                const directMatch = line.match(/[,，]\s*发\s*([^\s,，]+?(?:证券|银行|基金|理财|信托|资管|保险|公司|投顾)(?:\([^)]*\))?)/);
                if (directMatch && directMatch[1] && directMatch[1] !== '请求') {
                    return directMatch[1].trim();
                }

                // "固收联系/联系/固收"xxx 兜底
                const mmPatterns = [
                    /固收联系([^\s,，]+(?:证券|银行|基金|信托|保险|资管|公司))/,
                    /联系([^\s,，]+(?:证券|银行|基金|信托|保险|资管|公司))/,
                    /固收([^\s,，]+(?:证券|银行|基金|信托|保险|资管|公司))/
                ];
                for (const p of mmPatterns) {
                    const m = line.match(p);
                    if (m) return m[1].trim();
                }

                // "双方发" -> 留空（由操作侧再分配）
                if (/双方发/.test(line)) return '';

                return '';
            }
            
            /**
             * 统一的机构名称清理方法
             * @param {string} name 原始机构名称
             * @returns {string} 清理后的机构名称
             */
            _cleanInstitutionName(name) {
                if (!name) return '';
                
                // 基础清理
                name = name.trim().replace(/\s+/g, ' ');
                
                // 移除可能的交易量等数字信息
                name = name.replace(/\s*\d+\s*,?\s*$/, '');
                
                // 移除多余的标点符号
                name = name.replace(/[,，。;；]+$/, '').replace(/^[,，。;；]+/, '');
                
                // 验证是否为有效机构名称
                if (!this._isValidInstitutionName(name)) return '';
                
                return name;
            }
            
            /**
             * 增强的机构名称验证
             * @param {string} name 机构名称
             * @returns {boolean} 是否有效
             */
            _isValidInstitutionName(name) {
                if (!name || name.length < 2 || name.length > 20) return false;
                
                // 必须包含中文字符
                if (!/[\u4e00-\u9fa5]/.test(name)) return false;
                
                // 不能是纯数字
                if (/^\d+$/.test(name)) return false;
                
                // 排除明显的非机构名词汇
                const invalidWords = [
                    '请求', '报价', '合单', '双方', '发请求', '明天', '今天', 
                    '交易', '买入', '卖出', '行权', '到期', '出给'
                ];
                if (invalidWords.includes(name)) return false;
                
                // 排除我方机构名称
                if (name.includes('平安理财')) return false;
                
                // 不能以明显的非机构名词汇结尾（允许机构名后带括号分支，如 东海证券(上海)）
                if (/(?:请求|报价|合单|发请求)$/.test(name)) return false;
                
                return true;
            }
            
            /**
             * 从"出给"前的文本提取机构名称
             * @param {string} text 出给前的文本
             * @returns {string} 机构名称
             */
            _extractInstitutionNameBefore(text) {
                if (!text) return '';
                
                // 移除序号和标记
                text = text.replace(/^【[^】]+】\d+\)/, '').replace(/^\d+[、。]/, '');
                
                // 分词处理
                const words = text.trim().split(/\s+/);
                if (!words.length) return '';
                
                // 从后往前查找机构名称
                for (let i = words.length - 1; i >= 0; i--) {
                    const word = words[i];
                    const cleanWord = this._cleanInstitutionName(word);
                    
                    if (cleanWord && this._isLikelyInstitution(cleanWord)) {
                        return cleanWord;
                    }
                }
                
                return '';
            }
            
            /**
             * 从"出给"后的文本提取机构名称
             * @param {string} text 出给后的文本
             * @returns {string} 机构名称
             */
            _extractInstitutionNameAfter(text) {
                if (!text) return '';
                
                // 移除【请求】及其后面的内容
                const requestPos = text.indexOf('【请求】');
                if (requestPos !== -1) {
                    text = text.substring(0, requestPos);
                }
                
                // 移除逗号后的内容
                const commaPos = text.search(/[,，]/);
                if (commaPos !== -1) {
                    text = text.substring(0, commaPos);
                }
                
                text = text.trim();
                
                // 机构名称模式匹配
                const institutionMatch = text.match(/^([^\d+\-/\s]+(?:银行|理财|证券|基金|保险|信托|资管|金融|投资|集团|公司|农商行|农商|农信社))/);
                if (institutionMatch) {
                    return this._cleanInstitutionName(institutionMatch[1]);
                }
                
                // 提取第一个中文词组
                const chineseMatch = text.match(/^([^\d+\-/\s,，]{2,})/);
                if (chineseMatch) {
                    const candidate = this._cleanInstitutionName(chineseMatch[1]);
                    if (this._isLikelyInstitution(candidate)) {
                        return candidate;
                    }
                }
                
                return '';
            }
            
            /**
             * 判断是否可能是机构名称
             * @param {string} name 名称
             * @returns {boolean} 是否可能是机构
             */
            _isLikelyInstitution(name) {
                if (!name || name.length < 2) return false;
                
                // 机构特征词
                const institutionFeatures = [
                    '证券', '银行', '基金', '理财', '信托', '保险', '资管', '金融',
                    '投资', '集团', '公司', '农商', '农信', '农合', '资产'
                ];
                
                // 如果包含机构特征词，很可能是机构
                if (institutionFeatures.some(feature => name.includes(feature))) {
                    return true;
                }
                
                // 常见的券商简称
                const commonShortNames = [
                    '一创', '华创', '中金', '中信', '华泰', '招商', '广发', '海通',
                    '国泰', '申万', '东证', '光大', '兴业', '方正', '民生', '国信',
                    '长江', '银河', '东方', '太平', '平安', '华夏', '工银', '建信'
                ];
                
                return commonShortNames.includes(name);
            }

            extractDirectionAndCounterparties(line) {
                // 重构后的统一调用方法 - 职责分离，逻辑清晰
                const direction = this.extractDirection(line);
                const makerInstitution = this.extractMakerInstitution(line);
                const terminalInstitution = this.extractTerminalInstitution(line, direction);
                
                return {
                    direction: direction,
                    makerInstitution: makerInstitution,
                    terminalInstitution: terminalInstitution
                };
            }
            extractYieldInfo(line) {
                const result = {
                    yield: '',
                    yieldType: ''
                };
                
                // 检查行权收益率
                let match = line.match(this.patterns.yieldExercise);
                if (match) {
                    result.yield = match[1] + '%';
                    result.yieldType = '行权收益率';
                    return result;
                }
                
                // 检查到期收益率
                match = line.match(this.patterns.yieldMaturity);
                if (match) {
                    result.yield = match[1] + '%';
                    result.yieldType = '到期收益率';
                    return result;
                }
                
                // 检查双边报价
                match = line.match(this.patterns.bidOfferPair);
                if (match) {
                    // 获取交易方向
                    const direction = this.extractDirection(line);
                    const leftPrice = parseFloat(match[1]);
                    const rightPrice = parseFloat(match[2]);
                    
                    let selectedPrice;
                    if (direction === '买入') {
                        selectedPrice = rightPrice;  // 买入取对手卖价（右侧）
                    } else if (direction === '卖出') {
                        selectedPrice = leftPrice;   // 卖出取对手买价（左侧）
                    } else {
                        selectedPrice = leftPrice;   // 未知方向取左侧（保守）
                    }
                    
                    result.yield = selectedPrice.toFixed(4) + '%';
                    result.yieldType = '到期收益率';
                    return result;
                }
                
                // 检查带星号的收益率
                match = line.match(this.patterns.yieldWithStar);
                if (match) {
                    result.yield = match[1] + '%';
                    result.yieldType = '参考收益率';
                    return result;
                }
                
                // 普通收益率
                match = line.match(this.patterns.yieldGeneral);
                if (match) {
                    result.yield = match[1] + '%';
                    result.yieldType = '到期收益率';
                    return result;
                }
                
                return result;
            }
            
            extractCompleteRemarks(line, termInfo) {
                const remarks = [];
                
                if (termInfo) {
                    remarks.push(`期限: ${termInfo}`);
                }
                
                // 提取请求信息
                let match = line.match(this.patterns.remarksRequest);
                if (match) {
                    remarks.push(`请求: ${match[1].trim()}`);
                }
                
                // 提取费用信息
                match = line.match(this.patterns.remarksFee);
                if (match) {
                    remarks.push(`费用: ${match[1]}`);
                }
                
                // 提取产品信息
                match = line.match(this.patterns.remarksProduct);
                if (match) {
                    remarks.push(`产品: ${match[1]}`);
                }
                
                // 提取发/走信息
                match = line.match(this.patterns.remarksFaZou);
                if (match) {
                    remarks.push(`联系: ${match[1]}`);
                }
                
                return remarks.join('; ');
            }
            
            // 主解析方法（增强版）
            parseEnhancedRecords(rawText, traderName = '') {
                if (!rawText || typeof rawText !== 'string') {
                    console.warn('输入数据为空或格式错误');
                    return {
                        records: [],
                        stats: { total: 0, done_count: 0, unknown_count: 0, success_rate: 0 }
                    };
                }
                
                this.parsed_records = [];
                
                const lines = rawText.trim().split('\n');
                
                // 检测和处理复杂格式（增强版专用功能）
                const complexRecords = this.detectAndParseComplexFormats(lines);
                if (complexRecords.length > 0) {
                    this.parsed_records.push(...complexRecords);
                    
                    // 设置交易员信息
                    if (traderName && traderName.trim()) {
                        for (let record of this.parsed_records) {
                            if (!record.交易员) {
                                record.交易员 = traderName.trim();
                            }
                        }
                    }
                    
                    const stats = this.generateParsingStats();
                    return { records: this.parsed_records, stats: stats };
                }
                
                // FSM块级解析：优先处理报价行收益率（原有逻辑）
                let fsmResults = [];
                let fsmCodeMap = {};
                
                try {
                    fsmResults = this.robustParseFreeform(rawText);
                    // 创建代码到FSM结果的映射
                    for (let fsmRes of fsmResults) {
                        if (fsmRes.code) {
                            const codeKey = fsmRes.code.toUpperCase().replace(/\.(IB|SH|SZ)/g, '');
                            fsmCodeMap[codeKey] = fsmRes;
                        }
                    }
                    console.log(`FSM解析到 ${fsmResults.length} 个块，映射到 ${Object.keys(fsmCodeMap).length} 个代码`);
                } catch (error) {
                    console.warn('FSM解析失败，回退到标准解析:', error);
                }
                
                // 存储FSM结果供单行解析使用
                this._fsmCodeMap = fsmCodeMap;
                
                for (let lineNum = 0; lineNum < lines.length; lineNum++) {
                    const line = lines[lineNum].trim();
                    if (!line) continue;
                    
                    try {
                        const record = this.parseSingleLine(line, lineNum + 1);
                        
                        // FSM集成：报价行优先于正文参考值
                        if (record.债券代码 && this._fsmCodeMap) {
                            const codeKey = record.债券代码.toUpperCase().replace(/\.(IB|SH|SZ)/g, '');
                            const fsmResult = this._fsmCodeMap[codeKey];
                            
                            if (fsmResult) {
                                // 仅在标准解析未得出明确结果时，才使用FSM覆盖，避免跨行污染
                                if (!record.收益率 && fsmResult.target_yield !== null) {
                                    record.收益率 = `${fsmResult.target_yield.toFixed(4)}%`;
                                    record.收益率类型 = "报价收益率";
                                }

                                // 方向：仅当缺失时才覆盖
                                if (!record.方向 && fsmResult.direction) {
                                    const directionMap = {'Bid': '买入', 'Offer': '卖出'};
                                    if (directionMap[fsmResult.direction]) {
                                        record.方向 = directionMap[fsmResult.direction];
                                    }
                                }

                                // 交易量：仅当缺失或为0时才覆盖
                                if ((record.交易量 == null || record.交易量 === '' || Number(record.交易量) === 0) && fsmResult.amount_wan !== null) {
                                    record.交易量 = String(fsmResult.amount_wan);
                                }
                            }
                        }
                        
                        this.parsed_records.push(record);
                    } catch (error) {
                        console.warn(`行${lineNum + 1}: ${line} | 解析错误:`, error);
                        // 创建失败记录
                        this.parsed_records.push({
                            序号: lineNum + 1,
                            交易员: '',
                            债券代码: '',
                            债券名称: '',
                            方向: '',
                            中介: '',
                            原中介编号: '',
                            做市商机构名称: '',
                            终端机构名称: '',
                            户名: '',
                            交易量: '',
                            收益率: '',
                            收益率类型: '',
                            净价: '',
                            全价: '',
                            交易日期: '',
                            清算速度: '',
                            交易场所: '',
                            发单方式: '',
                            对手交易员: '',
                            备注: '解析失败',
                            原始文本: line
                        });
                    }
                }
                
                // 设置交易员信息
                if (traderName && traderName.trim()) {
                    for (let record of this.parsed_records) {
                        if (!record.交易员) {
                            record.交易员 = traderName.trim();
                        }
                    }
                }
                
                // 生成解析统计信息
                const stats = this.generateParsingStats();
                
                return {
                    records: this.parsed_records,
                    stats: stats
                };
            }
            
            generateParsingStats() {
                const stats = {
                    total: this.parsed_records.length,
                    done_count: 0,
                    unknown_count: 0,
                    success_rate: 0.0
                };
                
                for (let record of this.parsed_records) {
                    const originalText = (record.原始文本 || '').toUpperCase();
                    const direction = record.方向 || '';
                    
                    // 判断是否为有效的DONE记录
                    if (direction && ['买入', '卖出'].includes(direction) && 
                        (originalText.includes('出给') || 
                         ['买入', '卖出', '做市', '成交'].some(keyword => originalText.includes(keyword)))) {
                        stats.done_count += 1;
                    } else {
                        stats.unknown_count += 1;
                    }
                }
                
                // 计算成功识别率
                if (stats.total > 0) {
                    stats.success_rate = Math.round((stats.total - stats.unknown_count) / stats.total * 100 * 10) / 10;
                }
                
                return stats;
            }
            
            // 增强版专用：检测和解析复杂格式
            detectAndParseComplexFormats(lines) {
                const records = [];
                let i = 0;
                
                while (i < lines.length) {
                    const line = lines[i].trim();
                    if (!line) {
                        i++;
                        continue;
                    }
                    
                    try {
                        // 1. 检测完整市场数据格式
                        if (this.isCompleteMarketDataFormat(line)) {
                            const parsedRecords = this.parseCompleteMarketData(lines, i);
                            records.push(...parsedRecords.records);
                            i += parsedRecords.skipLines;
                            continue;
                        }
                        
                        // 2. 检测表格批量格式
                        if (this.isTableBatchFormat(line, lines, i)) {
                            const parsedRecords = this.parseTableBatch(lines, i);
                            records.push(...parsedRecords.records);
                            i += parsedRecords.skipLines;
                            continue;
                        }
                        
                        // 3. 检测bid/ofr上下文格式
                        if (this.isBidOfferContextFormat(line)) {
                            const parsedRecords = this.parseBidOfferContext(lines, i);
                            records.push(...parsedRecords.records);
                            i += parsedRecords.skipLines;
                            continue;
                        }
                        
                        // 4. 检测简化单行格式
                        if (this.isSimplifiedFormat(line)) {
                            const record = this.parseSimplifiedFormat(line, i + 1);
                            if (record) {
                                records.push(record);
                            }
                            i++;
                            continue;
                        }
                        
                        i++;
                    } catch (error) {
                        console.warn(`复杂格式解析错误 行${i + 1}:`, error);
                        i++;
                    }
                }
                
                return records;
            }
            
            isCompleteMarketDataFormat(line) {
                // 检测完整市场数据格式：包含剩余期限、债券代码、估值、时间戳等
                // 支持：239D+2Y、229D(休2)、4.5Y(休1)、3.65Y+NY、3.65Y+N(休2) 等
                return /^(?:\d+\.\d+Y|\d+D)(?:\([^)]*\))?(?:\s*\+\s*(?:\d+(?:Y|D)|N(?:Y)?)(?:\([^)]*\))?)*\s+\d+\.(?:IB|SH|SZ)\s+/.test(line);
            }
            
            parseCompleteMarketData(lines, startIndex) {
                const mainLine = lines[startIndex];
                const quoteLine = lines[startIndex + 1] || '';
                
                const record = this.createBaseRecord(mainLine, startIndex + 1);
                
                // 解析剩余期限（支持首段括号与 +NY/+N(休x)）
                const termMatch = mainLine.match(/^(\d+\.\d+Y(?:\([^)]*\))?(?:\s*\+\s*(?:\d+Y|N(?:Y)?)(?:\([^)]*\))?)?|\d+D(?:\([^)]*\))?)/);
                if (termMatch) {
                    record.期限 = termMatch[1];
                }
                
                // 解析债券代码和名称
                const codeMatch = mainLine.match(/(\d+\.(IB|SH|SZ))/);
                if (codeMatch) {
                    record.债券代码 = codeMatch[1];
                    record.交易场所 = codeMatch[2] === 'IB' ? '银行间' : '交易所';
                }
                
                // 解析债券名称：优先使用通用清洗提取，兼容“23长江02/23东证C2（特）/25中海03”
                let extractedName = '';
                if (record.债券代码) {
                    extractedName = extractBondNameByCleanMethod(mainLine, record.债券代码);
                }
                if (!extractedName) {
                    // 回退到通用名称解析器
                    extractedName = this.parseBondName(mainLine);
                }
                if (extractedName) {
                    record.债券名称 = extractedName;
                }
                
                // 解析时间戳
                const timeMatch = mainLine.match(/(\d{2}:\d{2}:\d{2})$/);
                if (timeMatch) {
                    const today = new Date().toISOString().split('T')[0];
                    record.交易日期 = today;
                    record.备注 = `时间戳: ${timeMatch[1]}`;
                }
                
                // 解析报价（支持下一行报价，或主行末尾的内联报价）
                let hasQuoteLine = false;
                if (quoteLine) {
                    hasQuoteLine = this.parseQuoteLine(quoteLine, record);
                }
                if (!hasQuoteLine) {
                    // 尝试在主行中解析内联 "1.85 bid 1900" 或 "1.83 OFR 5KW"
                    this.parseQuoteInline(mainLine, record);
                }
                
                return {
                    records: [record],
                    skipLines: hasQuoteLine ? 2 : 1
                };
            }
            
            parseQuoteLine(quoteLine, record) {
                // 解析类似 "1.89 bid 1kw" 或 "1.84 给 2k~" 这样的报价行
                const quotePattern = /(\d+\.\d+)\s*(bid|ofr|offer|给)\s*(\d+(?:\.\d+)?)(kw|k|万|w)?~?/i;
                const match = quoteLine.match(quotePattern);
                
                if (match) {
                    record.收益率 = parseFloat(match[1]).toFixed(4) + '%';
                    
                    const direction = match[2].toLowerCase();
                    if (direction === 'bid') {
                        record.方向 = '买入';
                    } else if (direction === 'ofr' || direction === 'offer') {
                        record.方向 = '卖出';
                    } else if (direction === '给') {
                        record.方向 = '卖出';
                    }
                    
                    // 解析交易量
                    const amount = parseFloat(match[3]);
                    const unit = match[4] ? match[4].toLowerCase() : '';
                    
                    if (unit === 'kw') {
                        record.交易量 = amount * 1000; // 1kw = 1000万
                    } else if (unit === 'k') {
                        record.交易量 = amount * 1000;  // 1k = 1000万（按你的规则）
                    } else if (unit === '万' || unit === 'w') {
                        record.交易量 = amount;
                    } else {
                        record.交易量 = amount; // 默认为万
                    }
                    
                    record.收益率类型 = '到期收益率';
                    return true;
                }
                return false;
            }

            // 主行内联报价解析（用于市场数据主行包含 "收益率 方向 数量" 的情况）
            parseQuoteInline(line, record) {
                const inlinePattern = /(\d+\.\d+)\s*(bid|ofr|offer|给)\s*(\d+(?:\.\d+)?)(kw|k|万|w)?(?!\S)/i;
                const m = line.match(inlinePattern);
                if (!m) return false;
                record.收益率 = parseFloat(m[1]).toFixed(4) + '%';
                const dir = m[2].toLowerCase();
                record.方向 = dir === 'bid' ? '买入' : '卖出';
                const amt = parseFloat(m[3]);
                const unit = m[4] ? m[4].toLowerCase() : '';
                if (unit === 'kw' || unit === 'k') {
                    record.交易量 = amt * 1000;
                } else if (unit === '万' || unit === 'w' || unit === '') {
                    record.交易量 = amt;
                }
                record.收益率类型 = '到期收益率';
                return true;
            }
            
            isTableBatchFormat(line, lines, index) {
                // 检测表格批量格式（如【ofr】后跟多行债券数据）
                return /^【(bid|ofr|offer)】$/i.test(line) ||
                       /^\d+\.(SH|SZ)\s+[\u4e00-\u9fa5A-Z0-9]+\s+\d+\s+\d+\.\d+$/.test(line);
            }
            
            parseTableBatch(lines, startIndex) {
                const records = [];
                let i = startIndex;
                let direction = '';
                
                // 检查是否有方向标记
                const directionMatch = lines[i].match(/^【(bid|ofr|offer)】$/i);
                if (directionMatch) {
                    direction = directionMatch[1].toLowerCase() === 'bid' ? '买入' : '卖出';
                    i++; // 跳过方向行
                }
                
                // 解析后续的表格数据行
                while (i < lines.length) {
                    const line = lines[i].trim();
                    if (!line) break;
                    
                    // 匹配表格格式：债券代码 债券名称 交易量 收益率
                    const tableMatch = line.match(/^(\d+\.(SH|SZ))\s+([\u4e00-\u9fa5A-Z0-9]+)\s+(\d+)\s+(\d+\.\d+)$/);
                    if (tableMatch) {
                        const record = this.createBaseRecord(line, i + 1);
                        record.债券代码 = tableMatch[1];
                        record.债券名称 = tableMatch[3];
                        record.交易量 = parseInt(tableMatch[4]);
                        record.收益率 = parseFloat(tableMatch[5]).toFixed(4) + '%';
                        record.方向 = direction || '卖出'; // 默认卖出
                        record.交易场所 = tableMatch[2] === 'IB' ? '银行间' : '交易所';
                        record.收益率类型 = '到期收益率';
                        
                        records.push(record);
                        i++;
                    } else {
                        break; // 表格格式结束
                    }
                }
                
                return {
                    records: records,
                    skipLines: i - startIndex
                };
            }
            
            isBidOfferContextFormat(line) {
                // 检测bid/ofr上下文格式
                return /^(bid|ofr|买入|卖出)$/i.test(line);
            }
            
            parseBidOfferContext(lines, startIndex) {
                const records = [];
                let i = startIndex;
                let contextDirection = '';
                
                // 检查是否有方向上下文
                const directionMatch = lines[i].match(/^(bid|ofr|买入|卖出)$/i);
                if (directionMatch) {
                    const dir = directionMatch[1].toLowerCase();
                    contextDirection = (dir === 'bid' || dir === '买入') ? '买入' : '卖出';
                    i++; // 跳过方向行
                }
                
                // 解析后续行
                while (i < lines.length) {
                    const line = lines[i].trim();
                    if (!line) break;
                    
                    // 简单格式：期限 代码 名称
                    const simpleMatch = line.match(/^(\d+\.\d+Y(?:\([^)]*\))?(?:\+\d+Y(?:\([^)]*\))?)?)\s+(\d+\.(IB|SH|SZ))\s+([\u4e00-\u9fa5A-Z0-9]+(?:MTN|债|CD|永续|二级|资本|专项|企业|公司|中期票据|绿色债)\d*)$/);
                    if (simpleMatch) {
                        const record = this.createBaseRecord(line, i + 1);
                        record.期限 = simpleMatch[1];
                        record.债券代码 = simpleMatch[2];
                        record.债券名称 = simpleMatch[4];
                        record.方向 = contextDirection || '买入';
                        record.交易场所 = simpleMatch[3] === 'IB' ? '银行间' : '交易所';
                        
                        records.push(record);
                        i++;
                    } else {
                        break; // 格式结束
                    }
                }
                
                return {
                    records: records,
                    skipLines: i - startIndex
                };
            }
            
            isSimplifiedFormat(line) {
                // 检测简化格式，如："25靖投01 卖出 2.09 1400"、"24赣建01 bid 2.1 2K"、"22绿城地产MTN006 2.35* bid 1K"
                return /^[\u4e00-\u9fa5A-Z0-9MTN]+\s+(bid|ofr|买入|卖出)\s+\d+\.\d+\*?\s+\d+[kKwW]?$/i.test(line) ||
                       /^[\u4e00-\u9fa5A-Z0-9MTN]+\s+\d+\.\d+\*?\s*(bid|ofr|买入|卖出)\s+\d+[kKwW]?$/i.test(line) ||
                       /^[\u4e00-\u9fa5A-Z0-9MTN]+\s+(bid|ofr|买入|卖出)\s+\d+\.\d+\*?\s*$/i.test(line);
            }
            
            parseSimplifiedFormat(line, lineNum) {
                // 解析简化格式：名称 方向 收益率 交易量
                let match = line.match(/^([\u4e00-\u9fa5A-Z0-9MTN]+)\s+(bid|ofr|买入|卖出)\s+(\d+\.\d+)\*?\s+(\d+)([kKwW]?)$/i);
                
                if (!match) {
                    // 尝试另一种格式：名称 收益率 方向 交易量
                    match = line.match(/^([\u4e00-\u9fa5A-Z0-9MTN]+)\s+(\d+\.\d+)\*?\s*(bid|ofr|买入|卖出)\s+(\d+)([kKwW]?)$/i);
                    if (match) {
                        // 重新排序匹配结果
                        match = [match[0], match[1], match[3], match[2], match[4], match[5]];
                    }
                }
                
                if (!match) {
                    // 尝试第三种格式：名称 收益率 方向（无交易量）
                    match = line.match(/^([\u4e00-\u9fa5A-Z0-9MTN]+)\s+(\d+\.\d+)\*?\s*(bid|ofr|买入|卖出)\s*$/i);
                    if (match) {
                        // 添加默认交易量
                        match = [match[0], match[1], match[3], match[2], '1000', ''];
                    }
                }
                
                if (!match) {
                    // 尝试带债券代码的格式：名称 代码 收益率行权/到期 方向
                    match = line.match(/^([\u4e00-\u9fa5A-Z0-9MTN]+)\s+(\d+\.(SH|SZ|IB))\s+(\d+\.\d+)\*?(行权|到期)?\s*(bid|ofr|买入|卖出)\s*(\d+)?([kKwW]?)$/i);
                    if (match) {
                        // 重新组织匹配结果：[原文, 名称, 方向, 收益率, 交易量, 单位, 代码]
                        const name = match[1];
                        const code = match[2];
                        const yieldValue = match[4];
                        const yieldType = match[5];
                        const direction = match[6];
                        const amount = match[7] || '1000';
                        const unit = match[8] || '';
                        
                        const record = this.createBaseRecord(line, lineNum);
                        record.债券名称 = name;
                        record.债券代码 = code;
                        record.收益率 = parseFloat(yieldValue).toFixed(4) + '%';
                        record.收益率类型 = yieldType === '行权' ? '行权收益率' : '到期收益率';
                        
                        const dir = direction.toLowerCase();
                        if (dir === 'bid' || dir === '买入') {
                            record.方向 = '买入';
                        } else {
                            record.方向 = '卖出';
                        }
                        
                        // 解析交易量
                        const amountNum = parseInt(amount);
                        if (unit.toLowerCase() === 'k') {
                            record.交易量 = amountNum * 100; // K = 100万
                        } else {
                            record.交易量 = amountNum; // 默认万
                        }
                        
                        record.交易场所 = match[3] === 'IB' ? '银行间' : '交易所';
                        
                        return record;
                    }
                }
                
                if (match) {
                    const record = this.createBaseRecord(line, lineNum);
                    record.债券名称 = match[1];
                    
                    const direction = match[2].toLowerCase();
                    if (direction === 'bid' || direction === '买入') {
                        record.方向 = '买入';
                    } else {
                        record.方向 = '卖出';
                    }
                    
                    record.收益率 = parseFloat(match[3]).toFixed(4) + '%';
                    record.收益率类型 = '到期收益率';
                    
                    // 解析交易量
                    const amount = parseInt(match[4]);
                    const unit = match[5] ? match[5].toLowerCase() : '';
                    
                    if (unit === 'k') {
                        record.交易量 = amount * 100; // K = 100万
                    } else {
                        record.交易量 = amount; // 默认万
                    }
                    
                    return record;
                }
                
                return null;
            }
            
            createBaseRecord(originalText, lineNum) {
                return {
                    序号: lineNum,
                    投资经理: '',
                    债券代码: '',
                    债券名称: '',
                    期限: '',
                    方向: '',
                    中介: '',
                    原中介编号: '',
                    做市商机构名称: '',
                    终端机构名称: '',
                    户名: '',
                    交易量: '',
                    收益率: '',
                    收益率类型: '',
                    净价: '',
                    全价: '',
                    交易日期: '',
                    清算速度: 'T+0',
                    交易场所: '',
                    发单方式: '',
                    对手交易员: '',
                    备注: '',
                    原始文本: originalText,
                    解析状态: '成功'
                };
            }
        }
        // 文本预处理器类 - 标准化市场用语
        class TextPreprocessor {
            constructor() {
                this.initPatterns();
            }
            
            initPatterns() {
                // 英文方向词映射
                this.bidPatterns = /\b(bid|BID|Bid)\b/gi;
                this.ofrPatterns = /\b(ofr|OFR|Ofr|offer|OFFER|Offer|of|OF|ask|ASK)\b/gi;
                
                // 中文俗语模式
                this.buyPhrases = /(帮忙拿|要拿|拿一下|收一下|收票|吃掉|扫货|要一下|求一口|拿\s*\d+|要|拉|吃|扫|收|要\s*\d+[kwE亿万]*)/;
                this.sellPhrases = /(?<!出)(给\s*\d+|给一下|报一口|挂一下|抛一下|让一下|放一下|出一下|给\s*\w+\s*\d+|出|给|放|让|挂|报)/;
            }
            
            preprocessText(text) {
                if (!text) return text;
                
                const lines = text.split('\n');
                const processedLines = [];
                
                for (let line of lines) {
                    let processed = line.trim();
                    if (!processed) {
                        processedLines.push(processed);
                        continue;
                    }
                    
                    // 保护中介标记，避免被后续替换打乱
                    const intermMatch = processed.match(/【[^】]+】/);
                    let intermToken = null;
                    if (intermMatch) {
                        intermToken = intermMatch[0];
                        processed = processed.replace(intermToken, '<<INTERM>>');
                    }
                    
                    // 英文方向词标准化
                    processed = processed.replace(this.bidPatterns, '买入');
                    processed = processed.replace(this.ofrPatterns, '卖出');
                    
                    // 处理【bid】【ofr】标记
                    if (/【bid】/i.test(processed) || /【BID】/i.test(processed)) {
                        if (!processed.includes('买入') && !processed.includes('卖出')) {
                            processed = '买入 ' + processed.replace(/【bid】|【BID】/gi, '');
                        }
                    }
                    if (/【ofr】/i.test(processed) || /【offer】/i.test(processed)) {
                        if (!processed.includes('买入') && !processed.includes('卖出')) {
                            processed = '卖出 ' + processed.replace(/【ofr】|【offer】/gi, '');
                        }
                    }
                    
                    // 中文俗语处理
                    if (this.buyPhrases.test(processed)) {
                        if (!processed.includes('买入') && !processed.includes('卖出')) {
                            // 智能插入位置
                            if (/^\d{2}[\u4e00-\u9fa5]/.test(processed)) {
                                processed = '买入 ' + processed;
                            } else {
                                // 在数量前插入
                                processed = processed.replace(/(\s|^)(\d+(?:\.\d+)?(?:k|K|w|W|万|kw|KW)?(?:\s|$))/, '$1买入 $2');
                                if (!processed.includes('买入')) {
                                    processed = '买入 ' + processed;
                                }
                            }
                        }
                    }
                    
                    if (this.sellPhrases.test(processed)) {
                        if (!processed.includes('买入') && !processed.includes('卖出') && !processed.includes('出给')) {
                            if (/^\d{2}[\u4e00-\u9fa5]/.test(processed)) {
                                processed = '卖出 ' + processed;
                            } else {
                                processed = processed.replace(/(\s|^)(\d+(?:\.\d+)?(?:k|K|w|W|万|kw|KW)?(?:\s|$))/, '$1卖出 $2');
                                if (!processed.includes('卖出')) {
                                    processed = '卖出 ' + processed;
                                }
                            }
                        }
                    }
                    
                    // 还原中介标记
                    if (intermToken) {
                        processed = processed.replace('<<INTERM>>', intermToken);
                    }
                    
                    processedLines.push(processed);
                }
                
                return processedLines.join('\n');
            }
        }
        
        // 全局变量声明
        let parser = null;
        let enhancedParser = null;
        let textPreprocessor = null;

        // 初始化所有解析器（在页面加载完成后调用）
        function initializeParsers() {
            try {
                parser = new BondParser();
                enhancedParser = new EnhancedBondParser();
                textPreprocessor = new TextPreprocessor();
                console.log('解析器初始化成功');
            } catch (error) {
                console.error('解析器初始化失败:', error);
            }
        }

        // 模式选择

        // 返回模式选择
        function backToMode() {
            document.getElementById('standardApp').style.display = 'none';
            document.getElementById('enhancedApp').style.display = 'none';
            document.getElementById('modeSelector').style.display = 'flex';
        }

        // ===== 基于清洁版.py的核心方法实现 =====
        
        /**
         * 基于清洁版.py的extract_bond_name逻辑提取债券名称
         * @param {string} line - 原始文本
         * @param {string} bondCode - 债券代码
         * @returns {string} 提取的债券名称
         */
        function extractBondNameByCleanMethod(line, bondCode) {
            if (!bondCode || !line) return '';
            
            const actualCode = bondCode.replace(/\.(IB|SH|SZ)$/, '');
            
            // 查找债券代码在文本中的位置
            let codePos = line.indexOf(bondCode);
            let codeLength = bondCode.length;
            
            if (codePos === -1) {
                codePos = line.indexOf(actualCode);
                if (codePos === -1) return '';
                codeLength = actualCode.length;
            }
            
            let codeEndPos = codePos + codeLength;
            
            // 检查是否有后缀（.SH, .SZ, .IB）
            if (codeEndPos < line.length && codePos === line.indexOf(bondCode)) {
                const suffix = line.substring(codeEndPos, codeEndPos + 3);
                if (['.SH', '.SZ', '.IB'].includes(suffix)) {
                    codeEndPos += 3;
                }
            }
            
            if (codeEndPos >= line.length) return '';
            
            const remaining = line.substring(codeEndPos).trim();
            
            // 查找收益率位置（兼容 1~4 位小数，允许尾随*，及括号内“* 到期”等形式）
            const yieldMatch = remaining.match(/(?<!净价)(?<!全价)\d+\.\d{1,4}\*?(?:\([^)]*\)|\s*(?:%|行权|到期))?/);
            let bondNameText;
            
            if (yieldMatch) {
                // 在存在收益率的情况下，同样考虑提前终止关键词，避免把“私募债”等类型词带入名称
                let cutPos = yieldMatch.index;
                const stopPatternsBeforeYield = [
                    /出给/, /私募债/, /公募债/, /T\+\d/, /交易所/, /远期/,
                    /[（(]\s*私(?:募(?:债|债券)?)?\s*[）)]/,
                    /\s+--\//, /\s+[-—–－]{2,}\s*\/?/
                ];
                for (const pattern of stopPatternsBeforeYield) {
                    const m = remaining.match(pattern);
                    if (m && m.index < cutPos) {
                        cutPos = m.index;
                    }
                }
                bondNameText = remaining.substring(0, cutPos).trim();
            } else {
                // 修复stopPatterns - 支持 1~4 位小数与括号/星号起始，添加“(私)”等
                const stopPatterns = [
                    /出给/, /私募债/, /公募债/, /T\+\d/, /交易所/, /远期/,
                    /[（(]\s*私(?:募(?:债|债券)?)?\s*[）)]/,
                    /\s+\d{1,2}\.\d{1,4}(?:\+|\s|\(|\*)/
                ];
                let minPos = remaining.length;
                
                for (const pattern of stopPatterns) {
                    const match = remaining.match(pattern);
                    if (match) {
                        minPos = Math.min(minPos, match.index);
                    }
                }
                
                bondNameText = remaining.substring(0, minPos).trim();
            }
            
            // 清理尾部标点符号
            bondNameText = bondNameText.replace(/[,，。、\s]+$/, '');
            // 进一步清理：移除尾部分隔符（如 --/ 等非名称字符）
            bondNameText = bondNameText.replace(/[^\u4e00-\u9fa5A-Za-z0-9（）()]+$/, '');
            // 额外清理：尾部类型词（如“私募债/公募债”），以及括号“(私)/(私募)/(私募债)”
            bondNameText = bondNameText.replace(/\s*(?:私募债|公募债)\s*$/, '');
            bondNameText = bondNameText.replace(/(?:[（(]\s*私(?:募(?:债|债券)?)?\s*[）)])+\s*$/, '');
            
            // 验证提取的债券名称
            if (isValidExtractedBondName(bondNameText)) {
                return bondNameText;
            }
            
            // Fallback：在代码后的剩余文本中直接搜索标准格式名称（如“23长江02”、“23东证C2（特）”）
            const directPattern = /(\d{2}[\u4e00-\u9fa5]{1,12}[A-Z]?\d{0,4}(?:（[^）]{1,6}）)?)/g;
            const directMatches = [];
            let dm;
            while ((dm = directPattern.exec(remaining)) !== null) {
                const cand = (dm[1] || '').trim();
                if (isValidExtractedBondName(cand)) directMatches.push({ text: cand, index: dm.index });
            }
            if (directMatches.length > 0) {
                directMatches.sort((a,b) => a.index - b.index);
                return directMatches[0].text;
            }
            
            return '';
        }
        
        /**
         * 验证提取的债券名称是否有效（基于清洁版.py的_is_valid_extracted_bond_name逻辑）
         * @param {string} bondName - 债券名称
         * @returns {boolean} 是否有效
         */
        function isValidExtractedBondName(bondName) {
            if (!bondName || bondName.length < 2) {
                return false;
            }
            
            if (/^\d+$/.test(bondName)) {
                return false;
            }
            
            // 检查是否包含英文字符
            const hasEnglish = /[A-Z]/.test(bondName);
            if (hasEnglish) {
                const chineseChars = (bondName.match(/[\u4e00-\u9fa5]/g) || []).length;
                if (chineseChars < 1) {
                    return false;
                }
            } else {
                const chineseChars = (bondName.match(/[\u4e00-\u9fa5]/g) || []).length;
                if (chineseChars < 2) {
                    return false;
                }
            }
            
            // 排除无效模式
            const invalidPatterns = [
                /^行权$/, /^到期$/, /^出给$/,
                /^\d+\.\d+$/, /^\d+$/
            ];
            
            for (const pattern of invalidPatterns) {
                if (pattern.test(bondName)) {
                    return false;
                }
            }
            
            // 排除金融机构名称
            const financialInstitutions = [
                '华夏基金', '华夏银行', '华福证券', '申港证券', '平安理财', '中银理财',
                '长城证券', '国泰君安', '中信证券', '海通证券', '招商证券', '广发证券'
            ];
            
            if (financialInstitutions.includes(bondName)) {
                return false;
            }

            // 进一步排除：交易场所关键词不应出现在债券名称中
            const invalidKeywords = ['交易所'];
            for (const kw of invalidKeywords) {
                if (bondName.includes(kw)) {
                    return false;
                }
            }
            
            // 排除信托产品和资管产品名称（关键修复）
            const trustProductPatterns = [
                /.*信托.*\d+号/,              // 如"外贸信托臻今60号"
                /.*信托.*计划/,               // 信托计划
                /.*集合.*计划/,               // 集合计划
                /.*资管.*计划/,               // 资管计划
                /.*金穗\d+号?/,               // 金穗系列
                /.*专户.*\d+号/               // 专户产品
            ];
            
            for (const pattern of trustProductPatterns) {
                if (pattern.test(bondName)) {
                    return false;
                }
            }
            
            return true;
        }
        
        /**
         * 基于清洁版.py的extract_volume逻辑提取交易量
         * @param {string} line - 原始文本
         * @returns {string} 提取的交易量
         */
        function extractVolumeByCleanMethod(line) {
            if (!line) return '';
            
            // 1. 优先匹配"X亿"格式
            const yiMatch = line.match(/(\d+(?:\.\d+)?)\s*亿(?![^\s,，;]*)/);
            if (yiMatch) {
                try {
                    const volYi = parseFloat(yiMatch[1]);
                    return String(Math.round(volYi * 10000));
                } catch (e) {
                    // 继续其他匹配
                }
            }
            
            // 2. 匹配kw/KW格式
            const kwMatch = line.match(/(\d+(?:\.\d+)?)\s*(?:kw|KW|Kw)\b/i);
            if (kwMatch) {
                try {
                    const number = parseFloat(kwMatch[1]);
                    return String(Math.round(number * 1000));
                } catch (e) {
                    // 继续其他匹配
                }
            }
            
            // 3. 匹配k/K格式（但不是kw）
            const kMatch = line.match(/(\d+(?:\.\d+)?)\s*[kK](?![wW])\b/);
            if (kMatch) {
                try {
                    const number = parseFloat(kMatch[1]);
                    return String(Math.round(number * 1000)); // 1k = 1000万（按你的规则）
                } catch (e) {
                    // 继续其他匹配
                }
            }
            
            // 4. 匹配万/W格式
            const wanMatch = line.match(/(\d+(?:\.\d+)?)\s*[万Ww](?![\u4e00-\u9fa5])/);
            if (wanMatch) {
                try {
                    const number = parseFloat(wanMatch[1]);
                    return String(Math.round(number));
                } catch (e) {
                    // 继续其他匹配
                }
            }
            
            // 5. 优先匹配收益率后的交易量
            const volumeAfterYield = line.match(/\d+\.\d{2,3}%?\s+(\d+[kKwW万]?)(?=\s)/);
            if (volumeAfterYield) {
                const volumeStr = volumeAfterYield[1];
                if (volumeStr.toLowerCase().endsWith('k')) {
                    return String(Math.round(parseFloat(volumeStr.slice(0, -1)) * 1000)); // k = 1000万
                } else if (volumeStr.endsWith('万') || volumeStr.toLowerCase().endsWith('w')) {
                    return volumeStr.slice(0, -1);
                } else {
                    return volumeStr;
                }
            }
            
            // 6. 识别科学记数法格式（E/e表示亿）
            const scientificPattern = /(\d+(?:\.\d+)?)\s*[Ee](?=\s|$|\+|T\+|\/|\d{1,2}\.\d{2}|出给|交易所|远|明天|今天)/i;
            const scientificMatches = [...line.matchAll(new RegExp(scientificPattern.source, 'gi'))];
            
            for (const match of scientificMatches) {
                try {
                    const number = parseFloat(match[1]);
                    const volumeInWan = Math.round(number * 10000);
                    
                    if (volumeInWan >= 100 && volumeInWan <= 1000000) {
                        if (isValidVolumePosition(line, match)) {
                            return String(volumeInWan);
                        }
                    }
                } catch (e) {
                    continue;
                }
            }
            
            // 7. 识别传统数字格式（改进逻辑避免债券代码干扰）
            const volumePattern = /\b(\d{3,6})\b/g;
            const volumeCandidates = [];
            
            let match;
            while ((match = volumePattern.exec(line)) !== null) {
                const volume = match[1];
                const volInt = parseInt(volume);
                
                // 排除日期格式
                if (volume.length === 4 && isDateFormat(volume)) {
                    continue;
                }
                
                // 新增：排除债券代码的一部分（检查是否在9位数字中间）
                const beforeMatch = line.substring(0, match.index);
                const afterMatch = line.substring(match.index + volume.length);
                
                // 如果前面有数字且整体构成6-9位数字，跳过（可能是债券代码）
                const fullNumberMatch = line.substring(Math.max(0, match.index - 6), match.index + volume.length + 3).match(/(\d{6,9})/);
                if (fullNumberMatch && fullNumberMatch[1].includes(volume) && fullNumberMatch[1].length > volume.length) {
                    continue;
                }
                
                if (volInt >= 100 && volInt <= 100000) {
                    if (isValidVolumePosition(line, match)) {
                        volumeCandidates.push({
                            value: volInt,
                            text: volume,
                            position: match.index
                        });
                    }
                }
            }
            
            if (volumeCandidates.length > 0) {
                // 按位置从后往前排序，选择最后一个（最接近结尾的）
                volumeCandidates.sort((a, b) => b.position - a.position);
                return volumeCandidates[0].text;
            }
            
            return '';
        }
        
        /**
         * 验证交易量位置的合理性（基于清洁版.py的_is_valid_volume_position逻辑）
         * @param {string} line - 原始文本
         * @param {object} match - 正则匹配对象
         * @returns {boolean} 位置是否合理
         */
        function isValidVolumePosition(line, match) {
            const startPos = match.index;
            const endPos = startPos + match[0].length;
            
            const beforeText = line.substring(0, startPos).trim();
            const afterText = line.substring(endPos).trim();
            
            // 检查前面是否有收益率模式（行权收益率）
            if (/\d+\.\d{2,4}\s*(?:行权)?\s*$/.test(beforeText)) {
                return true;
            }
            
            // 检查前面是否有债券名称模式
            if (/[\u4e00-\u9fa5]+(?:债券|MTN|永续债|二级资本债)?\d*\s*$/.test(beforeText)) {
                return true;
            }
            
            // 检查前面是否有一般收益率
            if (/\d+\.\d{2,4}\s*$/.test(beforeText)) {
                return true;
            }
            
            // 支持纯数字交易量（但要排除债券代码）
            const pureVolumeMatch = beforeText.match(/\b(\d{3,6})$/);
            if (pureVolumeMatch) {
                // 进一步检查，确保不是债券代码的一部分
                const beforePureVolume = beforeText.substring(0, beforeText.length - pureVolumeMatch[0].length);
                if (!/\d{3,6}$/.test(beforePureVolume)) {
                    return true;
                }
            }
            
            return false;
        }
        
        /**
         * 判断是否为日期格式
         * @param {string} text - 文本
         * @returns {boolean} 是否为日期
         */
        function isDateFormat(text) {
            if (text.length === 4) {
                try {
                    const month = parseInt(text.substring(0, 2));
                    const day = parseInt(text.substring(2, 4));
                    return month >= 1 && month <= 12 && day >= 1 && day <= 31;
                } catch (e) {
                    return false;
                }
            }
            return false;
        }
        // 标准版功能
        function parseStandard() {
            // 检查解析器是否已初始化
            if (!parser || !textPreprocessor) {
                showToast('解析器尚未初始化，请稍候重试', 'error');
                return;
            }
            
            let text = document.getElementById('standardInput').value;
            if (!text.trim()) {
                showToast('请输入交易记录', 'error');
                return;
            }
            
            // 预处理文本
            text = textPreprocessor.preprocessText(text);
            
            const traderName = document.getElementById('traderName').value.trim();
            const results = parser.parseText(text);
            
            // 如果有投资经理名称，添加到每条记录
            if (traderName) {
                results.forEach(record => {
                    if (!record.投资经理) {
                        record.投资经理 = traderName;
                    }
                });
            }
            
            // 后处理修复：解决特定解析问题
            results.forEach(record => {
                const originalText = record.原始文本 || '';
                
                            // 修复1：中介识别问题（基于清洁版.py的逻辑）
            const intermediaryMatch = originalText.match(/【([^】]+)】/);
            if (intermediaryMatch) {
                const extractedIntermediary = intermediaryMatch[1];
                const excludedSources = ['请求', '备注', '注释', '说明'];
                
                if (!excludedSources.includes(extractedIntermediary)) {
                    // 基于清洁版.py的中介映射表
                    const intermediaryMap = {
                        '国利': '国利', '中诚': '中诚', '国际': '国际',
                        '信唐': '信唐', '上田': '上田', '平安': '平安',
                        'TP': '国利', 'BGC': '中诚', 'ICAP': '国际',
                        'XT': '信唐', 'ST': '上田', 'PALS': '平安'
                    };
                    
                    // 先检查映射表
                    let finalIntermediary = extractedIntermediary;
                    for (const [key, value] of Object.entries(intermediaryMap)) {
                        if (extractedIntermediary.includes(key)) {
                            finalIntermediary = value;
                            break;
                        }
                    }
                    
                    if (!record.中介 || record.中介 === '【请求】') {
                        record.中介 = finalIntermediary;
                    }
                    
                    // 同时提取原中介编号
                    if (!record.原中介编号) {
                        const seqPatterns = [
                            /【[^】]+】\s*(\d+)\s*[)）]/,  // 【国利】1)
                            /^\s*(\d+)\s*[)）]/,           // 行首的 1)
                            /^.*?(\d+)\s*[)）]/            // 任意位置的第一个 数字)
                        ];
                        
                        for (const pattern of seqPatterns) {
                            const seqMatch = originalText.match(pattern);
                            if (seqMatch) {
                                record.原中介编号 = seqMatch[1];
                                break;
                            }
                        }
                    }
                }
            }
                
                // 修复2：债券代码识别优化
                if (!record.债券代码 || record.债券代码.length < 6) {
                    // 重新精确解析债券代码
                    const codeMatches = [];
                    
                    // 9位+后缀格式（最高优先级）
                    const exchangeCodeMatch = originalText.match(/\b(\d{9})\.(IB|SH|SZ)\b/);
                    if (exchangeCodeMatch) {
                        codeMatches.push(exchangeCodeMatch[0]);
                    }
                    
                    // 6位+后缀格式
                    const sixDigitCodeMatch = originalText.match(/\b(\d{6})\.(SH|SZ)\b/);
                    if (sixDigitCodeMatch) {
                        codeMatches.push(sixDigitCodeMatch[0]);
                    }
                    
                    // 9位无后缀（银行间）
                    const ninePureMatch = originalText.match(/\b(\d{9})(?!\.(IB|SH|SZ))\b/);
                    if (ninePureMatch) {
                        // 确保不在日期格式中
                        const beforeText = originalText.substring(Math.max(0, ninePureMatch.index - 5), ninePureMatch.index);
                        const afterText = originalText.substring(ninePureMatch.index + 9, ninePureMatch.index + 15);
                        if (!beforeText.includes('.') && !afterText.includes('+')) {
                            codeMatches.push(ninePureMatch[1] + '.IB');
                        }
                    }
                    
                    // 7位国债代码
                    const sevenDigitMatch = originalText.match(/\b(\d{7})(?!\d)\b/);
                    if (sevenDigitMatch) {
                        const code = sevenDigitMatch[1];
                        // 国债通常以2开头
                        if (code.startsWith('2')) {
                            codeMatches.push(code);
                        }
                    }
                    
                    // 6位纯数字代码（推断后缀）
                    const sixPureMatch = originalText.match(/\b(\d{6})(?!\d|\.)\b/);
                    if (sixPureMatch) {
                        const code = sixPureMatch[1];
                        // 根据首位数字推断交易所
                        if (code.startsWith('1') || code.startsWith('5')) {
                            codeMatches.push(code + '.SH');
                        } else if (code.startsWith('3')) {
                            codeMatches.push(code + '.SZ');
                        } else {
                            codeMatches.push(code + '.IB');
                        }
                    }
                    
                    // 选择最优的债券代码
                    if (codeMatches.length > 0) {
                        record.债券代码 = codeMatches[0];
                    }
                }
                
                // 修复2b：债券名称识别优化（完全基于清洁版.py的extract_bond_name逻辑）
                if (record.债券代码 && (!record.债券名称 || record.债券名称.length < 4)) {
                    const extractedBondName = extractBondNameByCleanMethod(originalText, record.债券代码);
                    if (extractedBondName) {
                        record.债券名称 = extractedBondName;
                    }
                }
                
                // 修复3：交易场所识别
                if (!record.交易场所) {
                    if (record.债券代码) {
                        if (record.债券代码.includes('.IB')) {
                            record.交易场所 = '银行间';
                        } else if (record.债券代码.includes('.SH') || record.债券代码.includes('.SZ')) {
                            record.交易场所 = '交易所';
                        } else if (/^\d{7}$/.test(record.债券代码)) {
                            record.交易场所 = '银行间'; // 国债通常在银行间
                        }
                    }
                    
                    // 从文本中推断
                    if (!record.交易场所) {
                        if (originalText.includes('交易所')) {
                            record.交易场所 = '交易所';
                        } else if (originalText.includes('.IB') || originalText.match(/\d{2}\.\d{2}\+\d/)) {
                            record.交易场所 = '银行间';
                        }
                    }
                    
                    // 设置相应的清算速度
                    if (record.交易场所 === '银行间' && !record.清算速度) {
                        record.清算速度 = 'T+0';
                    } else if (record.交易场所 === '交易所' && !record.清算速度) {
                        record.清算速度 = 'T+1';
                    }
                }
                
                // 修复4：发单方式识别（统一为：请求/对话/固收平台；否则置空）
                if (!record.发单方式) {
                    if (/(?:【\s*)?请求(?:\s*】)?/.test(originalText)) {
                        record.发单方式 = '请求';
                    } else if (/(固收平台|固收联系|【固收】\s*联系|固收\s*联系|固收平台\s*交易)/.test(originalText)) {
                        record.发单方式 = '固收平台';
                    } else if (/对话/.test(originalText)) {
                        record.发单方式 = '对话';
                    }
                }
                
                // 修复5：对手方信息全面解析（基于清洁版.py逻辑）
                
                // 统一户名提取：仅使用解析器实例的方法
                if (!record.户名) {
                    record.户名 = (typeof parser !== 'undefined' && parser && typeof parser.extractAccountName === 'function')
                        ? parser.extractAccountName(originalText)
                        : '';
                }
                
                // 5.2 方向和对手方识别（基于清洁版.py的extract_direction_and_counterparties逻辑）
                const directionMatch = originalText.match(/([^\s,，]+(?:\s+[^\s,，]+)*)\s+出给\s+([^\s,，]+(?:\s+[^\s,，]+)*)/);
                if (directionMatch) {
                    let partyA = directionMatch[1].trim();
                    let partyB = directionMatch[2].trim();
                    
                    // 清理A/B两侧杂质
                    partyA = partyA.replace(/[,，。]+$/, '');
                    partyB = partyB.replace(/^[,，。]+/, '').replace(/[,，。]+$/, '');
                    partyB = partyB.split(/[,，]/)[0].trim(); // 去掉【请求】等尾随部分

                    // 使用专用提取器提纯机构名（避免整段文本落入终端列）
                    const beforeInst = (typeof parser !== 'undefined' && parser && typeof parser._extractInstitutionNameBefore === 'function'
                        ? parser._extractInstitutionNameBefore(partyA)
                        : normalizeInstitutionName(partyA));
                    const afterInst  = (typeof parser !== 'undefined' && parser && typeof parser._extractInstitutionNameAfter === 'function'
                        ? parser._extractInstitutionNameAfter(partyB)
                        : normalizeInstitutionName(partyB));
                    
                    // 确定交易方向和终端机构（显式排除"平安理财"）
                    if (partyA.includes('平安理财')) {
                        record.方向 = '卖出';
                        record.终端机构名称 = (afterInst && !afterInst.includes('平安理财')) ? cleanInstitutionName(afterInst) : '';
                    } else if (partyB.includes('平安理财')) {
                        record.方向 = '买入';
                        record.终端机构名称 = (beforeInst && !beforeInst.includes('平安理财')) ? cleanInstitutionName(beforeInst) : '';
                    } else {
                        // 没有明确"平安理财"时，按既有方向决定
                        if (record.方向 === '买入') {
                            record.终端机构名称 = (beforeInst && !beforeInst.includes('平安理财')) ? cleanInstitutionName(beforeInst) : '';
                        } else if (record.方向 === '卖出') {
                            record.终端机构名称 = (afterInst && !afterInst.includes('平安理财')) ? cleanInstitutionName(afterInst) : '';
                        }
                    }
                }
                
                // 5.3 做市商机构识别
                let makerInstitution = '';
                
                // 从【请求】发xxx模式中提取（改进版）
                const requestMakerPatterns = [
                    /【请求】[^【】]*发\s*([^\s,，]+?(?:证券|银行|基金|理财|信托|资管|保险|公司|投顾)(?:[\(（][^\)）]*[\)）])?)/,
                    /【请求】[^【】]*发\s*([^\s,，]+)/,
                ];
                
                for (const pattern of requestMakerPatterns) {
                    const match = originalText.match(pattern);
                    if (match && match[1] && match[1] !== '请求') {
                        makerInstitution = match[1].trim();
                        break;
                    }
                }
                
                    // 尝试直接的"发xxx"格式
                if (!makerInstitution) {
                    const directMakerPatterns = [
                        /[,，]\s*发\s*([^\s,，]+?(?:证券|银行|基金|理财|信托|资管|保险|公司|投顾)(?:[\(（][^\)）]*[\)）])?)/,
                        /[,，]\s*发\s*([^\s,，]+)/,
                    ];
                    
                    for (const pattern of directMakerPatterns) {
                        const match = originalText.match(pattern);
                        if (match && match[1] && match[1] !== '请求') {
                            makerInstitution = match[1].trim();
                            break;
                        }
                    }
                }
                
                // 固收联系模式
                if (!makerInstitution) {
                    const gushouPatterns = [
                        /固收联系([^\s,，]+(?:证券|银行|基金|信托|保险|资管|公司|投顾)(?:[\(（][^\)）]*[\)）])?)/,
                        /联系([^\s,，]+(?:证券|银行|基金|信托|保险|资管|公司|投顾)(?:[\(（][^\)）]*[\)）])?)/,
                        /固收([^\s,，]+(?:证券|银行|基金|信托|保险|资管|公司|投顾)(?:[\(（][^\)）]*[\)）])?)/
                    ];
                    
                    for (const pattern of gushouPatterns) {
                        const match = originalText.match(pattern);
                        if (match) {
                            const potential = this.normalizeInstitutionName(match[1]);
                            // 简单验证机构名称
                            if (potential.length >= 2 && potential.length <= 20) {
                                makerInstitution = potential;
                                break;
                            }
                        }
                    }
                }

                // 新增：基于"做市/报价/询价"的回溯提取
                if (!makerInstitution) {
                    const aroundMarketPatterns = [
                        /([\u4e00-\u9fa5A-Za-z0-9（）()]+?(?:证券|银行|基金|理财|信托|资管|公司))[^,，]{0,8}(?:做市|报价|询价)/,
                        /(?:由|请)\s*([\u4e00-\u9fa5A-Za-z0-9（）()]+?(?:证券|银行|基金|理财|信托|资管|公司))[^,，]{0,6}(?:做市|报价)/
                    ];
                    for (const p of aroundMarketPatterns) {
                        const m = originalText.match(p);
                        if (m && m[1]) {
                            const candidate = this.normalizeInstitutionName(m[1]);
                            if (candidate && candidate !== '请求' && candidate !== '发') {
                                makerInstitution = candidate;
                                break;
                            }
                        }
                    }
                }
                
                if (makerInstitution && makerInstitution !== '发' && makerInstitution !== '请求') {
                    // 确保做市商机构名称不是中介名称
                    const intermediaryNames = ['国利', '中诚', '国际', '信唐', '上田', '平安'];
                    if (!intermediaryNames.includes(makerInstitution)) {
                        record.做市商机构名称 = cleanInstitutionName(makerInstitution);
                    }
                }
                
                // 5.4 对手交易员识别（清理机构名称，只保留个人姓名）
                if (record.对手交易员) {
                    // 如果包含机构关键词，清空
                    const institutionKeywords = ['证券', '基金', '银行', '理财', '信托', '保险', '资管', '公司'];
                    if (institutionKeywords.some(keyword => record.对手交易员.includes(keyword))) {
                        record.对手交易员 = '';
                    }
                }
                
                // 从特定模式中提取交易员姓名
                if (!record.对手交易员) {
                    const traderPatterns = [
                        /联系\s*([^\s,，]{2,4})(?=(?:\s|[,，]|$))/,
                        /(?:证券|银行|基金|理财|信托|资管|保险|公司)[^,，\s]*\s+([^\s,，]{2,4})\s+出给/
                    ];
                    
                    for (const pattern of traderPatterns) {
                        const match = originalText.match(pattern);
                        if (match) {
                            const traderName = match[1].trim();
                            const ok = (typeof parser !== 'undefined' && parser && typeof parser._isValidTraderName === 'function')
                                ? parser._isValidTraderName(traderName)
                                : /^[\u4e00-\u9fa5]{2,4}$/.test(traderName);
                            if (ok) {
                                record.对手交易员 = traderName;
                                break;
                            }
                        }
                    }
                }
                
                // 修复6：交易量识别修复（完全基于清洁版.py逻辑）
                if (originalText && (!record.交易量 || record.交易量 === 0)) {
                    const extractedVolume = extractVolumeByCleanMethod(originalText);
                    if (extractedVolume) {
                        record.交易量 = parseInt(extractedVolume);
                    }
                }
                
                // 修复7：收益率识别修复（全面优化）
                if (originalText && (!record.收益率 || record.收益率 === '')) {
                    const yieldCandidates = [];
                    
                    // 1. 优先查找明确标注的行权收益率
                    const exerciseMatches = originalText.matchAll(/(\d+\.\d{2,4})\s*行权/g);
                    for (const match of exerciseMatches) {
                        yieldCandidates.push({
                            value: parseFloat(match[1]),
                            type: '行权收益率',
                            priority: 1,
                            text: match[0]
                        });
                    }
                    
                    // 2. 查找明确标注的到期收益率
                    const maturityMatches = originalText.matchAll(/(\d+\.\d{2,4})\s*到期/g);
                    for (const match of maturityMatches) {
                        yieldCandidates.push({
                            value: parseFloat(match[1]),
                            type: '到期收益率',
                            priority: 2,
                            text: match[0]
                        });
                    }
                    
                    // 3. 查找一般数字格式（需要智能判断）
                    const numberMatches = originalText.matchAll(/(\d+\.\d{2,4})(?!\+|[-/]|\s*[YDT])/g);
                    for (const match of numberMatches) {
                        const value = parseFloat(match[1]);
                        const fullMatch = match[0];
                        const position = match.index;
                        
                        // 排除明显不是收益率的情况
                        const beforeText = originalText.substring(Math.max(0, position - 10), position);
                        const afterText = originalText.substring(position + fullMatch.length, position + fullMatch.length + 10);
                        
                        // 排除日期格式（如08.20+0）
                        if (afterText.startsWith('+') || afterText.startsWith('T+')) continue;
                        
                        // 排除代码中的数字
                        if (beforeText.match(/\d$/) && afterText.match(/^\d/)) continue;
                        
                        // 合理的收益率范围
                        if (value >= 0.1 && value <= 50.0) {
                            // 根据上下文推断收益率类型
                            let inferredType = '到期收益率';
                            
                            // 如果在行权相关文本附近，推断为行权收益率
                            const contextText = originalText.substring(Math.max(0, position - 30), position + fullMatch.length + 30);
                            if (contextText.includes('行权') || contextText.includes('永续') || contextText.includes('+N')) {
                                inferredType = '行权收益率';
                            }
                            
                            yieldCandidates.push({
                                value: value,
                                type: inferredType,
                                priority: 3,
                                text: fullMatch,
                                position: position
                            });
                        }
                    }
                    
                    // 选择最优的收益率
                    if (yieldCandidates.length > 0) {
                        // 按优先级排序，同优先级按位置排序
                        yieldCandidates.sort((a, b) => {
                            if (a.priority !== b.priority) {
                                return a.priority - b.priority;
                            }
                            // 同优先级时，选择最后出现的（通常在交易量之前）
                            return (b.position || 0) - (a.position || 0);
                        });
                        
                        const selectedYield = yieldCandidates[0];
                        record.收益率 = selectedYield.value.toFixed(4) + '%';
                        record.收益率类型 = selectedYield.type;
                    }
                }
                
                // 修复8：交易日期和清算速度优化识别
                if (originalText && (!record.交易日期 || !record.清算速度)) {
                    // 识别交易日期格式
                    const datePatterns = [
                        // MM.DD+清算格式
                        /(\d{2})\.(\d{2})\+(\d)/g,
                        // MM.DD交易所格式
                        /(\d{2})\.(\d{2})交易所/g,
                        // 明天格式
                        /明天\+(\d)/g,
                        // 单独的+清算格式
                        /(?<!\d)\+(\d)(?!\d)/g
                    ];
                    
                    for (const pattern of datePatterns) {
                        const matches = [...originalText.matchAll(pattern)];
                        for (const match of matches) {
                            if (match[0].includes('交易所')) {
                                // 交易所格式
                                if (!record.交易场所) record.交易场所 = '交易所';
                                if (!record.清算速度) record.清算速度 = 'T+1';
                                if (!record.交易日期 && match[1] && match[2]) {
                                    const currentYear = new Date().getFullYear();
                                    record.交易日期 = `${currentYear}-${match[1]}-${match[2]}`;
                                }
                            } else if (match[0].includes('明天')) {
                                // 明天格式
                                if (!record.交易场所) record.交易场所 = '银行间';
                                if (!record.清算速度) record.清算速度 = `T+${match[1] || '0'}`;
                                if (!record.交易日期) {
                                    const tomorrow = new Date();
                                    tomorrow.setDate(tomorrow.getDate() + 1);
                                    record.交易日期 = tomorrow.toISOString().split('T')[0];
                                }
                            } else if (match[3] !== undefined) {
                                // MM.DD+清算格式
                                if (!record.交易场所) record.交易场所 = '银行间';
                                if (!record.清算速度) record.清算速度 = `T+${match[3]}`;
                                if (!record.交易日期 && match[1] && match[2]) {
                                    const currentYear = new Date().getFullYear();
                                    record.交易日期 = `${currentYear}-${match[1]}-${match[2]}`;
                                }
                            } else if (match[1] !== undefined) {
                                // 单独+清算格式
                                if (!record.交易场所) record.交易场所 = '银行间';
                                if (!record.清算速度) record.清算速度 = `T+${match[1]}`;
                            }
                        }
                    }
                }
                
                // 保持字段独立：不再强行同步"对手方"和"终端机构名称"
                
                // 确保设置解析状态
                if (!record.解析状态) {
                    if (record.债券代码 && record.债券名称 && record.方向) {
                        record.解析状态 = '成功';
                    } else if (record.债券代码 || record.债券名称) {
                        record.解析状态 = '警告';
                    } else {
                        record.解析状态 = '失败';
                    }
                }
            });
            
            // 实现同债券买入优先、买入内部按收益率排序
            results.sort((a, b) => {
                // 先按债券代码分组
                if (a.债券代码 !== b.债券代码) {
                    return (a.债券代码 || '').localeCompare(b.债券代码 || '');
                }
                
                // 同债券：买入优先
                if (a.方向 !== b.方向) {
                    if (a.方向 === '买入') return -1;
                    if (b.方向 === '买入') return 1;
                }
                
                // 同方向：按收益率排序（买入收益率高的在前，卖出收益率低的在前）
                const aYield = parseFloat((a.收益率 || '0').replace('%', '')) || 0;
                const bYield = parseFloat((b.收益率 || '0').replace('%', '')) || 0;
                
                if (a.方向 === '买入') {
                    return bYield - aYield; // 买入：收益率高的在前
                } else {
                    return aYield - bYield; // 卖出：收益率低的在前
                }
            });
            
            // 显示解析结果编辑界面，让用户确认和修正
            showStandardParseResultsModal(results, document.getElementById('standardInput').value.trim());
        }
        
        // 检查并处理空日期
        function checkAndHandleEmptyDates(records) {
            const emptyDateRecords = [];
            records.forEach((record, index) => {
                if (!record.交易日期 || record.交易日期.trim() === '') {
                    emptyDateRecords.push({index, record});
                }
            });
            
            if (emptyDateRecords.length > 0) {
                // 创建并显示日期处理对话框
                showDateHandlingDialog(emptyDateRecords);
            }
        }
        
        // 显示日期处理对话框
        function showDateHandlingDialog(emptyDateRecords) {
            const today = new Date();
            const tomorrow = new Date(today);
            tomorrow.setDate(tomorrow.getDate() + 1);
            
            const todayStr = today.toISOString().split('T')[0];
            const tomorrowStr = tomorrow.toISOString().split('T')[0];
            
            // 创建模态框
            const modal = document.createElement('div');
            modal.className = 'modal active';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>发现 ${emptyDateRecords.length} 条记录的交易日期为空</h3>
                        <button class="close-btn" onclick="this.closest('.modal').remove()">&times;</button>
                    </div>
                    <div style="margin-bottom: 20px;">
                        <p>请选择如何处理这些空日期记录：</p>
                    </div>
                    <div class="form-group">
                        <label>空日期记录概览：</label>
                        <div style="max-height: 150px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; background: #f9f9f9;">
                            ${emptyDateRecords.slice(0, 5).map(({index, record}) => 
                                `<div style="margin: 5px 0;">记录${index + 1}: ${record.债券名称 || record.债券代码 || '未知债券'} - ${record.方向 || ''} - ${record.交易量 || ''}万</div>`
                            ).join('')}
                            ${emptyDateRecords.length > 5 ? `<div style="color: #999;">...还有 ${emptyDateRecords.length - 5} 条记录</div>` : ''}
                        </div>
                    </div>
                    <div class="button-group" style="display: flex; flex-direction: column; gap: 10px;">
                        <button class="btn btn-primary" onclick="handleEmptyDates('${todayStr}', [${emptyDateRecords.map(e => e.index).join(',')}])">
                            填入今天的日期 (${todayStr})
                        </button>
                        <button class="btn btn-primary" onclick="handleEmptyDates('${tomorrowStr}', [${emptyDateRecords.map(e => e.index).join(',')}])">
                            填入明天的日期 (${tomorrowStr})
                        </button>
                        <button class="btn btn-secondary" onclick="showCustomDateInput([${emptyDateRecords.map(e => e.index).join(',')}])">
                            自定义日期
                        </button>
                        <button class="btn btn-secondary" onclick="this.closest('.modal').remove()">
                            保持空着
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        // 处理空日期
        function handleEmptyDates(dateStr, indices) {
            indices.forEach(index => {
                if (AppState.standardData[index]) {
                    AppState.standardData[index].交易日期 = dateStr;
                }
            });
            
            // 关闭模态框
            const modal = document.querySelector('.modal.active');
            if (modal) modal.remove();
            
            // 刷新显示
            displayStandardResults(AppState.standardData);
            showToast(`已将 ${indices.length} 条记录的日期设为 ${dateStr}`, 'success');
        }
        
        // 显示自定义日期输入
        function showCustomDateInput(indices) {
            const today = new Date().toISOString().split('T')[0];
            const dateInput = prompt('请输入日期 (格式: YYYY-MM-DD):', today);
            
            if (dateInput && /^\d{4}-\d{2}-\d{2}$/.test(dateInput)) {
                handleEmptyDates(dateInput, indices);
            } else if (dateInput) {
                showToast('日期格式不正确，请使用 YYYY-MM-DD 格式', 'error');
            }
        }

        // 删除标准版记录
        function deleteStandardRecord(index) {
            if (confirm('确定要删除这条记录吗？')) {
                AppState.standardData.splice(index, 1);
                displayStandardResults(AppState.standardData);
                showToast('记录删除成功', 'success');
            }
        }
        // 更新标准版选中项数量
        function updateStandardSelectedCount() {
            const checkboxes = document.querySelectorAll('.standardRecordCheckbox');
            const checked = document.querySelectorAll('.standardRecordCheckbox:checked');
            const countElement = document.getElementById('standardSelectedCount');
            if (countElement) {
                countElement.textContent = `已选择: ${checked.length} 项`;
            }
            
            // 更新全选复选框状态
            const selectAllCheckbox = document.getElementById('standardSelectAll');
            if (selectAllCheckbox) {
                if (checked.length === 0) {
                    selectAllCheckbox.indeterminate = false;
                    selectAllCheckbox.checked = false;
                } else if (checked.length === checkboxes.length) {
                    selectAllCheckbox.indeterminate = false;
                    selectAllCheckbox.checked = true;
                } else {
                    selectAllCheckbox.indeterminate = true;
                }
            }
        }

        // 全选/取消全选
        function toggleAllStandardRecords(selectAllCheckbox) {
            const checkboxes = document.querySelectorAll('.standardRecordCheckbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = selectAllCheckbox.checked;
            });
            updateStandardSelectedCount();
        }

        // 全选
        function selectAllStandardRecords() {
            const checkboxes = document.querySelectorAll('.standardRecordCheckbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
            });
            updateStandardSelectedCount();
        }

        // 取消全选
        function deselectAllStandardRecords() {
            const checkboxes = document.querySelectorAll('.standardRecordCheckbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            updateStandardSelectedCount();
        }

        // 批量删除标准版记录
        function batchDeleteStandardRecords() {
            const checkedCheckboxes = document.querySelectorAll('.standardRecordCheckbox:checked');
            if (checkedCheckboxes.length === 0) {
                showToast('请先选择要删除的记录', 'error');
                return;
            }
            
            if (confirm(`确定要删除选中的 ${checkedCheckboxes.length} 条记录吗？`)) {
                // 获取要删除的索引（从大到小排序，避免删除时索引变化）
                const indicesToDelete = Array.from(checkedCheckboxes)
                    .map(checkbox => parseInt(checkbox.dataset.index))
                    .sort((a, b) => b - a);
                
                // 删除记录
                indicesToDelete.forEach(index => {
                    AppState.standardData.splice(index, 1);
                });
                
                // 重新显示结果
                displayStandardResults(AppState.standardData);
                showToast(`成功删除 ${indicesToDelete.length} 条记录`, 'success');
            }
        }

        function renderStandardTableInto(containerId, results, opts = {}) {
            const selectable = !!opts.selectable;
            const selectAllHtml = opts.selectAllHtml || '<input type="checkbox" id="standardSelectAll" onchange="toggleAllStandardRecords(this)">';
            const rowCheckboxHtml = opts.rowCheckboxHtml; // function(record, index) => html
            const extraOpsRenderer = opts.extraOpsRenderer; // function(record, index) => html
            const container = document.getElementById(containerId);
            if (!container) return;

            let html = '';
            if (containerId === 'standardResultsContent') {
                html += '<div style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 5px; display: none;" id="standardBatchTools">';
                html += '<div style="display: flex; align-items: center; gap: 10px;">';
                html += '<span style="font-weight: bold;">批量操作:</span>';
                html += '<button class="btn btn-primary" onclick="selectAllStandardRecords()" style="padding: 5px 10px; font-size: 12px;">全选</button>';
                html += '<button class="btn btn-secondary" onclick="deselectAllStandardRecords()" style="padding: 5px 10px; font-size: 12px;">取消全选</button>';
                html += '<button class="btn" style="background: #ff4444; color: white; padding: 5px 10px; font-size: 12px;" onclick="batchDeleteStandardRecords()">批量删除</button>';
                html += '<span id="standardSelectedCount" style="margin-left: 10px; color: #666;">已选择: 0 项</span>';
                html += '</div></div>';
            }

            html += '<table style="width:100%; border-collapse: collapse;">';
            html += '<thead><tr style="background: #f5f5f5;">';
            if (selectable) {
                html += '<th style="padding: 10px; border: 1px solid #ddd; width: 40px;">' + selectAllHtml + '</th>';
            } else {
                html += '<th style="padding: 10px; border: 1px solid #ddd; width: 40px;">#</th>';
            }
            html += '<th style="padding: 10px; border: 1px solid #ddd;">序号</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">原中介编号</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">方向</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">债券代码</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">债券名称</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">交易量(万)</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">收益率(%)</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">中介</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">终端机构名称</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">做市商机构名称</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">发单方式</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">对手交易员</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">户名</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">交易日期</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">清算速度</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">备注</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">操作</th>';
            html += '</tr></thead><tbody>';

            results.forEach((record, index) => {
                const directionBg = record.方向 === '买入' ? '#e8f5e9' : record.方向 === '卖出' ? '#ffebee' : '';
                html += '<tr>';
                if (selectable) {
                    const rowCb = (typeof rowCheckboxHtml === 'function') ? rowCheckboxHtml(record, index) : '<input type="checkbox" class="standardRecordCheckbox" data-index="'+index+'" onchange="updateStandardSelectedCount()">';
                    html += '<td style="padding: 8px; border: 1px solid #ddd; text-align: center;">' + rowCb + '</td>';
                } else {
                    html += '<td style="padding: 8px; border: 1px solid #ddd; text-align: center;">' + (index + 1) + '</td>';
                }
                html += '<td style="padding: 8px; border: 1px solid #ddd; text-align: center;">' + (index + 1) + '</td>';
                html += '<td style="padding: 8px; border: 1px solid #ddd;">' + (record.原中介编号 || '') + '</td>';
                html += '<td style="padding: 8px; border: 1px solid #ddd; background: '+directionBg+'; font-weight: bold;">' + (record.方向 || '') + '</td>';
                html += '<td style="padding: 8px; border: 1px solid #ddd; font-weight: bold;">' + (record.债券代码 || '') + '</td>';
                html += '<td style="padding: 8px; border: 1px solid #ddd;">' + (record.债券名称 || '') + '</td>';
                html += '<td style="padding: 8px; border: 1px solid #ddd; text-align: right;">' + (record.交易量 || '') + '</td>';
                html += '<td style="padding: 8px; border: 1px solid #ddd; text-align: right;">' + (record.收益率 || '') + '</td>';
                html += '<td style="padding: 8px; border: 1px solid #ddd;">' + (record.中介 || '') + '</td>';
                html += '<td style="padding: 8px; border: 1px solid #ddd;">' + (record.终端机构名称 || '') + '</td>';
                html += '<td style="padding: 8px; border: 1px solid #ddd;">' + (record.做市商机构名称 || '') + '</td>';
                html += '<td style="padding: 8px; border: 1px solid #ddd;">' + (record.发单方式 || '') + '</td>';
                html += '<td style="padding: 8px; border: 1px solid #ddd;">' + (record.对手交易员 || '') + '</td>';
                html += '<td style="padding: 8px; border: 1px solid #ddd;">' + (record.户名 || '') + '</td>';
                html += '<td style="padding: 8px; border: 1px solid #ddd;">' + (record.交易日期 || '') + '</td>';
                html += '<td style="padding: 8px; border: 1px solid #ddd;">' + (record.清算速度 || 'T+0') + '</td>';
                html += '<td style="padding: 8px; border: 1px solid #ddd; font-size: 12px;">' + (record.备注 || '') + '</td>';
                const opsHtml = (typeof extraOpsRenderer === 'function')
                    ? extraOpsRenderer(record, index)
                    : '<button class="btn" style="background: #ff4444; color: white; padding: 4px 8px; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;" onclick="deleteStandardRecord('+index+')" title="删除记录">删除</button>';
                html += '<td style="padding: 8px; border: 1px solid #ddd; text-align: center;">' + opsHtml + '</td>';
                html += '</tr>';
            });

            // 合计
            let totalVolume = 0;
            let buyVolume = 0;
            let sellVolume = 0;
            results.forEach(record => {
                const volume = parseFloat(record.交易量) || 0;
                totalVolume += volume;
                if (record.方向 === '买入') buyVolume += volume; else if (record.方向 === '卖出') sellVolume += volume;
            });

            html += '<tr style="background: #f0f8ff; font-weight: bold; border-top: 2px solid #1976d2;">';
            html += '<td colspan="10" style="padding: 12px; border: 1px solid #ddd; text-align: right; font-size: 14px;">合计:</td>';
            html += '<td style="padding: 12px; border: 1px solid #ddd; text-align: right; font-size: 14px; color: #1976d2;">' + totalVolume.toFixed(2) + '</td>';
            html += '<td colspan="12" style="padding: 12px; border: 1px solid #ddd; text-align: left; font-size: 12px; color: #666;">';
            html += '买入: ' + buyVolume.toFixed(2) + '万 | 卖出: ' + sellVolume.toFixed(2) + '万 | 总计: ' + totalVolume.toFixed(2) + '万';
            html += '</td>';
            html += '</tr>';

            html += '</tbody></table>';
            container.innerHTML = html;

            if (containerId === 'standardResultsContent' && results.length > 0) {
                const el = document.getElementById('standardBatchTools');
                if (el) el.style.display = 'block';
                if (typeof updateStandardSelectedCount === 'function') updateStandardSelectedCount();
            }
        }

        function displayStandardResults(results) {
            renderStandardTableInto('standardResultsContent', results, { selectable: true });
            document.getElementById('standardResults').style.display = 'block';
            const container = document.getElementById('standardResultsContent');
            let html = '<div style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 5px; display: none;" id="standardBatchTools">';
            html += '<div style="display: flex; align-items: center; gap: 10px;">';
            html += '<span style="font-weight: bold;">批量操作:</span>';
            html += '<button class="btn btn-primary" onclick="selectAllStandardRecords()" style="padding: 5px 10px; font-size: 12px;">全选</button>';
            html += '<button class="btn btn-secondary" onclick="deselectAllStandardRecords()" style="padding: 5px 10px; font-size: 12px;">取消全选</button>';
            html += '<button class="btn" style="background: #ff4444; color: white; padding: 5px 10px; font-size: 12px;" onclick="batchDeleteStandardRecords()">批量删除</button>';
            html += '<span id="standardSelectedCount" style="margin-left: 10px; color: #666;">已选择: 0 项</span>';
            html += '</div></div>';
            html += '<table style="width:100%; border-collapse: collapse;">';
            html += '<thead><tr style="background: #f5f5f5;">';
            html += '<th style="padding: 10px; border: 1px solid #ddd; width: 40px;"><input type="checkbox" id="standardSelectAll" onchange="toggleAllStandardRecords(this)"></th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">序号</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">原中介编号</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">方向</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">债券代码</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">债券名称</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">交易量(万)</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">收益率(%)</th>';
            // UI改名：对手方 -> 中介
            html += '<th style="padding: 10px; border: 1px solid #ddd;">中介</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">终端机构名称</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">做市商机构名称</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">发单方式</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">对手交易员</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">户名</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">交易日期</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">清算速度</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">备注</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd;">操作</th>';
            html += '</tr></thead><tbody>';
            
            results.forEach((record, index) => {
                const statusColor = record.解析状态 === '成功' ? 'green' : 
                                   record.解析状态 === '警告' ? 'orange' : 'red';
                const directionBg = record.方向 === '买入' ? '#e8f5e9' : 
                                   record.方向 === '卖出' ? '#ffebee' : '';
                html += '<tr>';
                html += `<td style="padding: 8px; border: 1px solid #ddd; text-align: center;"><input type="checkbox" class="standardRecordCheckbox" data-index="${index}" onchange="updateStandardSelectedCount()"></td>`;
                html += `<td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${index + 1}</td>`;
                html += `<td style="padding: 8px; border: 1px solid #ddd;">${record.原中介编号 || ''}</td>`;
                html += `<td style="padding: 8px; border: 1px solid #ddd; background: ${directionBg}; font-weight: bold;">${record.方向 || ''}</td>`;
                html += `<td style="padding: 8px; border: 1px solid #ddd; font-weight: bold;">${record.债券代码 || ''}</td>`;
                html += `<td style="padding: 8px; border: 1px solid #ddd;">${record.债券名称 || ''}</td>`;
                html += `<td style="padding: 8px; border: 1px solid #ddd; text-align: right;">${record.交易量 || ''}</td>`;
                html += `<td style="padding: 8px; border: 1px solid #ddd; text-align: right;">${record.收益率 || ''}</td>`;
                html += `<td style="padding: 8px; border: 1px solid #ddd;">${record.中介 || ''}</td>`;
                html += `<td style="padding: 8px; border: 1px solid #ddd;">${record.终端机构名称 || ''}</td>`;
                html += `<td style="padding: 8px; border: 1px solid #ddd;">${record.做市商机构名称 || ''}</td>`;
                html += `<td style="padding: 8px; border: 1px solid #ddd;">${record.发单方式 || ''}</td>`;
                html += `<td style="padding: 8px; border: 1px solid #ddd;">${record.对手交易员 || ''}</td>`;
                html += `<td style="padding: 8px; border: 1px solid #ddd;">${record.户名 || ''}</td>`;
                html += `<td style="padding: 8px; border: 1px solid #ddd;">${record.交易日期 || ''}</td>`;
                html += `<td style="padding: 8px; border: 1px solid #ddd;">${record.清算速度 || 'T+0'}</td>`;
                html += `<td style="padding: 8px; border: 1px solid #ddd; font-size: 12px;">${record.备注 || ''}</td>`;
                html += `<td style="padding: 8px; border: 1px solid #ddd; text-align: center;">
                    <button class="btn" style="background: #ff4444; color: white; padding: 4px 8px; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;" 
                            onclick="deleteStandardRecord(${index})" title="删除记录">删除</button>
                </td>`;
                html += '</tr>';
            });
            
            // 计算交易量合计
            let totalVolume = 0;
            let buyVolume = 0;
            let sellVolume = 0;
            
            results.forEach(record => {
                const volume = parseFloat(record.交易量) || 0;
                totalVolume += volume;
                
                if (record.方向 === '买入') {
                    buyVolume += volume;
                } else if (record.方向 === '卖出') {
                    sellVolume += volume;
                }
            });
            
            // 添加合计行
            html += '<tr style="background: #f0f8ff; font-weight: bold; border-top: 2px solid #1976d2;">';
            html += '<td colspan="10" style="padding: 12px; border: 1px solid #ddd; text-align: right; font-size: 14px;">合计:</td>';
            html += `<td style="padding: 12px; border: 1px solid #ddd; text-align: right; font-size: 14px; color: #1976d2;">${totalVolume.toFixed(2)}</td>`;
            html += '<td colspan="12" style="padding: 12px; border: 1px solid #ddd; text-align: left; font-size: 12px; color: #666;">';
            html += `买入: ${buyVolume.toFixed(2)}万 | 卖出: ${sellVolume.toFixed(2)}万 | 总计: ${totalVolume.toFixed(2)}万`;
            html += '</td>';
            html += '</tr>';
            
            html += '</tbody></table>';
            container.innerHTML = html;
            document.getElementById('standardResults').style.display = 'block';
            
            // 显示批量操作工具栏
            if (results.length > 0) {
                document.getElementById('standardBatchTools').style.display = 'block';
                updateStandardSelectedCount();
            }
        }

        function loadSampleData() {
            const sampleData = `【完整功能示例数据】
1.48Y 102400608.IB 24晋城国资MTN001 1.89*/1.86* bid 1kw
1.28Y 102383162.IB 23北部湾MTN007 1.9*/1.85 bid 1kw
2.98Y+5Y 240737.SH 24株国05 2.0 bid 2000
93D 242385.SH 25国君C4 5000 1.81 ofr
25民生银行永续债01 33 BID T+1
24赣建01 bid 2.1 2K 交易所
23绿城房产MTN002 2.68* bid 1K 今天
3.5Y+N 24华夏银行02 1.95 拿 5000万
21国开05 1.84 给 3亿
240225.IB 24国开25 1.95 出给 国信证券

【市场俗语示例】
24农发08 帮忙拿 2000 1.90
22兴业银行01 给一下 3kw 2.05
23建设银行CD001 收一下 1E 1.85
24工商银行二级资本债 报一口 5千万 2.15
21苏州城投债 要拿 1000~2000 2.35

【复杂格式示例】
1.5Y+3Y 24北京银行次级债01 2.1到期 2.05行权 bid 看1000~2000
210810.IB 21农发10 买入 5000万 1.88* T+0
24深圳地铁MTN001 卖出 1亿 2.25 明天
3Y+2Y+N(休2) 24江苏银行永续债 要 3000 2.35
【TP】2) 24工商银行CD001 3.5 拿 2000 发李四 QQ`;
            
            document.getElementById('standardInput').value = sampleData;
            showToast('已加载完整功能示例数据', 'info');
        }

        function clearStandard() {
            document.getElementById('standardInput').value = '';
            document.getElementById('standardResults').style.display = 'none';
            AppState.standardData = [];
        }

        function exportStandardCSV() {
            if (AppState.standardData.length === 0) {
                showToast('没有数据可导出', 'error');
                return;
            }
            
            // 添加BOM以支持Excel正确显示中文（按清洁版.py标准列顺序）
            let csv = '\ufeff';
            csv += '投资经理,指令ID,债券代码,债券名称,方向,中介,原中介编号,做市商机构,终端机构,户名,交易量(万),收益率(%),收益率类型,净价,全价,交易日期,清算速度,交易场所,发单方式,对手交易员,备注,状态,完成进度(%),拆单策略,创建时间\n';
            
            AppState.standardData.forEach((record, index) => {
                const rowNum = index + 2; // CSV中数据从第2行开始（第1行是标题）
                
                // 债券代码：如果缺失则使用Wind公式
                const bondCode = record.债券代码 || `=to_windcode(E${rowNum})`;
                
                // 债券名称：如果缺失则使用Wind公式  
                const bondName = record.债券名称 || `=b_info_name(D${rowNum})`;
                
                const yieldValue = record.收益率 ? (typeof record.收益率 === 'string' && record.收益率.includes('%') ? parseFloat(record.收益率.replace('%', '')).toFixed(4) + '%' : record.收益率) : '';
                
                csv += `${record.投资经理 || ''},${record.指令ID || ''},${bondCode},${bondName},${record.方向 || ''},`;
                csv += `${record.中介 || ''},${record.原中介编号 || ''},${record.做市商机构名称 || ''},${record.终端机构名称 || ''},${record.户名 || ''},`;
                csv += `${record.交易量 || ''},${yieldValue},${record.收益率类型 || ''},`;
                csv += `${record.净价 || ''},${record.全价 || ''},${record.交易日期 || ''},`;
                csv += `${record.清算速度 || ''},${record.交易场所 || ''},${record.发单方式 || ''},${record.对手交易员 || ''},`;
                csv += `"${record.备注 || ''}",${record.状态 || ''},${record.完成进度 || ''},${record.拆单策略 || ''},${record.创建时间 || ''}"\n`;
            });
            
            downloadFile(csv, `bond_records_${new Date().toISOString().slice(0,10)}.csv`, 'text/csv;charset=utf-8');
            showToast('CSV文件导出成功（含Wind函数自动填充）', 'success');
        }

        function exportStandardExcel() {
            if (AppState.standardData.length === 0) {
                showToast('没有数据可导出', 'error');
                return;
            }
            
            // 使用离线Excel导出功能
            console.log('使用离线Excel导出功能，输出为Excel兼容的CSV格式');
            
            try {
                // 准备数据
                const exportData = [];
                
                // 添加标题行（按清洁版.py标准列顺序）
                exportData.push([
                    '原始文本', '序号', '投资经理', '债券代码', '债券名称', '方向',
                    '中介', '原中介编号', '发单方式', '对手交易员', '做市商机构名称', '终端机构名称',
                    '户名', '交易量（万元）', '收益率', '收益率类型', '净价',
                    '全价', '交易日期', '清算速度', '交易场所', '备注'
                ]);
                
                // 添加数据行（按清洁版.py标准列顺序）
                AppState.standardData.forEach((record, index) => {
                    const rowNum = index + 2; // Excel中数据从第2行开始（第1行是标题）
                    
                    // 债券代码：如果缺失则使用Wind公式 (D列是债券代码，E列是债券名称)
                    const bondCode = record.债券代码 || `=to_windcode(E${rowNum})`;
                    
                    // 债券名称：如果缺失则使用Wind公式
                    const bondName = record.债券名称 || `=b_info_name(D${rowNum})`;
                    
                    exportData.push([
                        record.原始文本 || '',          // A列：原始文本
                        index + 1,                      // B列：序号
                        record.投资经理 || '',            // C列：投资经理
                        bondCode,                       // D列：债券代码（含Wind公式）
                        bondName,                       // E列：债券名称（含Wind公式）
                        record.方向 || '',              // F列：方向
                        record.中介 || '',              // G列：中介
                        record.中介序号 || '',          // H列：原中介编号
                        record.发单方式 || '',          // I列：发单方式
                        record.对手交易员 || '',        // J列：对手交易员
                        record.做市商机构名称 || '',    // K列：做市商机构名称
                        record.终端机构名称 || '',      // L列：终端机构名称
                        record.户名 || '',              // M列：户名
                        record.交易量 || '',            // N列：交易量（万元）
                        record.收益率 || '',            // O列：收益率
                        record.收益率类型 || '',        // P列：收益率类型
                        record.净价 || '',              // Q列：净价
                        record.全价 || '',              // R列：全价
                        record.交易日期 || '',          // S列：交易日期
                        record.清算速度 || '',          // U列：清算速度
                        record.交易场所 || '',          // V列：交易场所
                        record.备注 || ''               // W列：备注
                    ]);
                });
                
                // 创建工作簿
                const wb = XLSX.utils.book_new();
                const ws = XLSX.utils.aoa_to_sheet(exportData);
                
                // 设置列宽（按清洁版.py标准）
                const colWidths = [
                    {wch: 50},  // A列：原始文本
                    {wch: 8},   // B列：序号
                    {wch: 12},  // C列：交易员
                    {wch: 15},  // D列：债券代码
                    {wch: 25},  // E列：债券名称
                    {wch: 8},   // F列：方向
                    {wch: 10},  // G列：中介
                    {wch: 10},  // H列：原中介编号
                    {wch: 10},  // I列：发单方式
                    {wch: 12},  // J列：对手交易员
                    {wch: 20},  // K列：做市商机构名称
                    {wch: 20},  // L列：终端机构名称
                    {wch: 25},  // M列：户名
                    {wch: 15},  // N列：交易量（万元）
                    {wch: 10},  // O列：收益率
                    {wch: 12},  // P列：收益率类型
                    {wch: 10},  // Q列：净价
                    {wch: 10},  // R列：全价
                    {wch: 12},  // S列：交易日期
                    {wch: 10},  // U列：清算速度
                    {wch: 10},  // V列：交易场所
                    {wch: 25}   // W列：备注
                ];
                ws['!cols'] = colWidths;
                
                // Wind函数已在数据准备阶段添加，无需额外处理
                // addWindFunctionsToSheet(ws, AppState.standardData.length);
                
                // 添加Excel样式格式化（基于清洁版.py逻辑）
                formatExcelSheet(ws, AppState.standardData.length);
                
                // 添加工作表到工作簿
                XLSX.utils.book_append_sheet(wb, ws, '交易记录');
                
                // 生成Excel文件
                const fileName = `债券交易记录_${new Date().toISOString().slice(0,10)}.xlsx`;
                XLSX.writeFile(wb, fileName);
                
                showToast('Excel文件导出成功（包含Wind函数）', 'success');
            } catch (error) {
                console.error('Excel导出错误:', error);
                // 如果导出失败，降级到CSV
                exportStandardCSV();
                showToast('已导出为CSV格式（Excel兼容）', 'info');
            }
        }
        
        function addWindFunctionsToSheet(ws, dataRows) {
            // 添加Wind债券信息函数（严格按照清洁版.py逻辑）
            try {
                for (let rowNum = 2; rowNum <= dataRows + 1; rowNum++) {
                    const bondCodeCell = `D${rowNum}`;    // D列：债券代码
                    const bondNameCell = `E${rowNum}`;    // E列：债券名称
                    
                    const bondCodeValue = ws[bondCodeCell] ? ws[bondCodeCell].v : '';
                    const bondNameValue = ws[bondNameCell] ? ws[bondNameCell].v : '';
                    
                    // 只有当债券代码存在但债券名称为空时，才在债券名称列添加Wind函数
                    if (bondCodeValue && !bondNameValue) {
                        // 按照清洁版.py的Wind函数格式
                        const windFormula = `=IFERROR(w.wsd(${bondCodeCell},"sec_name",TODAY(),TODAY(),""),"待补充")`;
                        
                        // 直接设置公式字符串，让Excel识别为公式
                        ws[bondNameCell] = windFormula;
                    }
                }
                
                console.log('Wind函数添加成功（清洁版.py逻辑）');
            } catch (error) {
                console.warn('Wind函数添加警告:', error);
            }
        }
        
        function formatExcelSheet(ws, dataRows) {
            // Excel格式化（基于清洁版.py样式逻辑）
            try {
                // 获取列字母序列
                const getColumnLetter = (col) => {
                    let result = '';
                    while (col > 0) {
                        col--;
                        result = String.fromCharCode(65 + (col % 26)) + result;
                        col = Math.floor(col / 26);
                    }
                    return result;
                };
                
                // 设置标题行样式
                const headerRange = `A1:W1`;  // A到W列，第1行（标题行）
                if (!ws['!merges']) ws['!merges'] = [];
                
                // 为数据范围添加格式信息（在SheetJS中的有限实现）
                const lastColumn = getColumnLetter(23);  // 第23列（W列）
                const dataRange = `A1:${lastColumn}${dataRows + 1}`;
                ws['!ref'] = dataRange;
                
                // 设置数字格式（收益率列显示为百分比）
                for (let rowNum = 2; rowNum <= dataRows + 1; rowNum++) {
                    const yieldCell = `P${rowNum}`;  // P列：收益率
                    if (ws[yieldCell]) {
                        ws[yieldCell].z = '0.00%';  // 百分比格式
                    }
                }
                
                // 设置冻结窗格（冻结第一行）
                ws['!freeze'] = { xSplit: 0, ySplit: 1, topLeftCell: 'A2' };
                
                // 设置行高信息（在注释中记录，实际效果受限于SheetJS）
                if (!ws['!rows']) ws['!rows'] = [];
                ws['!rows'][0] = { hpt: 25 };  // 标题行高度
                for (let i = 1; i <= dataRows; i++) {
                    ws['!rows'][i] = { hpt: 22 };  // 数据行高度
                }
                
                console.log('Excel格式化完成（清洁版.py样式）');
            } catch (error) {
                console.warn('Excel格式化警告:', error);
            }
        }

        // 测试函数（调试用）
        function testParsingLogic() {
            console.log('=== 开始测试解析逻辑 ===');
            
            const testInput = "【国利】66) 卖出 29.78Y 2500002 1.8645 1000 07.17+0 平安理财 出给 华福证券";
            console.log('测试输入:', testInput);
            
            if (!parser) {
                console.error('Parser未初始化');
                return;
            }
            
            // 测试各个解析函数
            console.log('--- 基础字段解析 ---');
            console.log('债券代码:', parser.parseBondCode(testInput));
            console.log('债券名称:', parser.parseBondName(testInput));
            console.log('交易量:', parser.parseVolume(testInput));
            console.log('收益率:', parser.parseYield(testInput));
            console.log('交易日期:', parser.parseDate(testInput));
            
            console.log('--- 对手方信息解析 ---');
            const counterpartyInfo = parser.parseCounterparty(testInput);
            console.log('方向:', counterpartyInfo.direction);
            console.log('中介(做市商机构):', counterpartyInfo.intermediary);
            console.log('对手方(终端机构):', counterpartyInfo.counterparty);
            console.log('中介序号:', counterpartyInfo.intermediarySeq);
            
            console.log('--- 完整解析结果 ---');
            const fullResult = parser.parseLine(testInput);
            console.log('完整结果:', fullResult);
            
            console.log('=== 测试完成 ===');
        }
        
        // 在控制台提供测试函数
        window.testParsingLogic = testParsingLogic;
        
        // ===== 解析结果编辑功能 =====
        
        let currentParseResults = []; // 当前编辑的解析结果
        let currentManager = '';      // 当前投资经理
        let currentInputText = '';    // 当前输入文本
        let editingRecordIndex = -1;  // 当前编辑的记录索引
        
        // ===== 标准版解析结果编辑功能 =====
        
        let currentStandardResults = []; // 当前编辑的标准版解析结果
        let currentStandardInputText = ''; // 当前标准版输入文本
        
        // 显示标准版解析结果编辑模态框
        function showStandardParseResultsModal(results, inputText) {
            currentStandardResults = JSON.parse(JSON.stringify(results)); // 深拷贝
            currentStandardInputText = inputText;
            
            // 转换标准版结果为编辑界面需要的格式
            const orders = results.map((record, index) => ({
                指令ID: `STD_${Date.now()}_${index}`,
                投资经理: '标准版',
                债券代码: record.债券代码 || '',
                债券名称: record.债券名称 || '',
                方向: record.方向 || '',
                中介: record.中介 || '',
                原中介编号: record.原中介编号 || '',
                做市商机构名称: record.做市商机构名称 || '',
                终端机构名称: record.终端机构名称 || '',
                户名: record.户名 || '',
                交易量: parseFloat(record.交易量) || 0,
                收益率: record.收益率 ? parseFloat(record.收益率.replace('%', '')) : null,
                收益率类型: record.收益率类型 || '',
                净价: parseFloat(record.净价) || null,
                全价: parseFloat(record.全价) || null,
                交易日期: record.交易日期 || '',
                清算速度: record.清算速度 || '',
                交易场所: record.交易场所 || '',
                发单方式: record.发单方式 || '',
                对手交易员: record.对手交易员 || '',
                备注: record.备注 || '',
                原始文本: record.原始文本 || inputText,
                原始指令文本: record.原始文本 || inputText,
                创建时间: new Date().toISOString(),
                状态: '待执行',
                完成进度: 0
            }));
            
            // 复用现有的解析结果编辑界面
            currentParseResults = orders;
            currentManager = '标准版';
            currentInputText = inputText;
            
            // 更新模态框标题
            const modalTitle = document.querySelector('#parseResultsModal .modal-header h3');
            if (modalTitle) {
                modalTitle.textContent = '标准版解析结果确认与修正';
            }
            
            // 显示统计信息
            updateParseStatsInfo();
            
            // 渲染表格
            renderParseResultsTable();
            
            // 显示模态框
            document.getElementById('parseResultsModal').classList.add('active');
        }
        
        // 标准版确认保存结果
        function confirmStandardParseResults() {
            if (currentStandardResults.length === 0) {
                showToast('没有可保存的记录', 'warning');
                return;
            }
            
            // 转换回标准版格式并保存
            const results = currentParseResults.map(order => ({
                原始文本: order.原始文本 || order.原始指令文本,
                投资经理: order.投资经理,
                债券代码: order.债券代码,
                债券名称: order.债券名称,
                方向: order.方向,
                中介: order.中介,
                原中介编号: order.原中介编号 || '',
                发单方式: order.发单方式 || '',
                对手交易员: order.对手交易员 || '',
                做市商机构名称: order.做市商机构名称 || '',
                终端机构名称: order.终端机构名称 || '',
                户名: order.户名 || '',
                交易量: order.交易量,
                收益率: order.收益率 ? order.收益率.toFixed(4) + '%' : '',
                收益率类型: order.收益率类型,
                净价: order.净价,
                全价: order.全价,
                交易日期: order.交易日期 || new Date().toISOString().split('T')[0],
                清算速度: order.清算速度,
                交易场所: order.交易场所,
                备注: order.备注,
                解析状态: (order.债券代码 && order.债券名称 && order.方向) ? '成功' : '警告',
                状态: '待执行',
                完成进度: 0
            }));
            
            AppState.standardData = results;
            // 统一数据旁路写入（deals）
            try {
                const decorated = results.map(decorateDealRecord);
                const existed = new Set((AppState.unifiedData.deals || []).map(d => d.dealId));
                decorated.forEach(d => { if (!existed.has(d.dealId)) AppState.unifiedData.deals.push(d); });
                AppState.unifiedData.stats.totalDeals = AppState.unifiedData.deals.length;
                if (typeof MatchEngine !== 'undefined') { MatchEngine.run(); }
                if (typeof renderUnifiedBoard === 'function') { renderUnifiedBoard(); }
                DataStorage.saveAppState();
            } catch (e) { console.warn('Unified(deals) write-through failed:', e); }
            
            // 检查并处理空日期
            checkAndHandleEmptyDates(results);
            
            displayStandardResults(results);
            showToast(`成功保存 ${results.length} 条记录`, 'success');
            
            // 关闭模态框
            closeModal('parseResultsModal');

            // 回到挂起的意图
            const a = (window.UnifiedIntent||{nextAction:null}).nextAction; (window.UnifiedIntent||{nextAction:null}).nextAction = null;
            if (a === 'auto') setTimeout(openAutoMatchPreview, 0);
            if (a === 'manual') setTimeout(openManualMatchWizard, 0);
        }
        
        // 标准版重新解析
        function reparseStandard() {
            if (!currentStandardInputText) {
                showToast('缺少原始数据，无法重新解析', 'error');
                return;
            }
            
            // 关闭当前模态框
            closeModal('parseResultsModal');
            
            // 重新填充标准版界面
            document.getElementById('standardInput').value = currentStandardInputText;
            
            // 重新执行解析
            parseStandard();
        }
        
        // 显示解析结果编辑模态框
        function showParseResultsModal(orders, manager, inputText) {
            currentParseResults = JSON.parse(JSON.stringify(orders)); // 深拷贝
            currentManager = manager;
            currentInputText = inputText;
            
            // 更新模态框标题
            const modalTitle = document.querySelector('#parseResultsModal .modal-header h3');
            if (modalTitle) {
                modalTitle.textContent = '扩展版解析结果确认与修正';
            }
            
            // 显示统计信息
            updateParseStatsInfo();
            
            // 渲染表格
            renderParseResultsTable();
            
            // 显示模态框
            document.getElementById('parseResultsModal').classList.add('active');
        }
        // 更新统计信息
        function updateParseStatsInfo() {
            const total = currentParseResults.length;
            const hasCode = currentParseResults.filter(r => r.债券代码).length;
            const hasName = currentParseResults.filter(r => r.债券名称).length;
            const hasDirection = currentParseResults.filter(r => r.方向).length;
            const hasVolume = currentParseResults.filter(r => r.交易量 > 0).length;
            const hasYield = currentParseResults.filter(r => r.收益率 > 0).length;
            
            const successRate = total > 0 ? Math.round((hasDirection / total) * 100) : 0;
            
            const statsHtml = `
                <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 15px; text-align: center;">
                    <div>
                        <div style="font-size: 24px; font-weight: bold; color: #007bff;">${total}</div>
                        <div style="font-size: 12px; color: #666;">总记录数</div>
                    </div>
                    <div>
                        <div style="font-size: 24px; font-weight: bold; color: ${hasCode/total >= 0.8 ? '#28a745' : '#ffc107'};">${hasCode}</div>
                        <div style="font-size: 12px; color: #666;">有债券代码</div>
                    </div>
                    <div>
                        <div style="font-size: 24px; font-weight: bold; color: ${hasName/total >= 0.8 ? '#28a745' : '#ffc107'};">${hasName}</div>
                        <div style="font-size: 12px; color: #666;">有债券名称</div>
                    </div>
                    <div>
                        <div style="font-size: 24px; font-weight: bold; color: ${hasDirection/total >= 0.8 ? '#28a745' : '#ffc107'};">${hasDirection}</div>
                        <div style="font-size: 12px; color: #666;">有交易方向</div>
                    </div>
                    <div>
                        <div style="font-size: 24px; font-weight: bold; color: ${hasVolume/total >= 0.8 ? '#28a745' : '#ffc107'};">${hasVolume}</div>
                        <div style="font-size: 12px; color: #666;">有交易量</div>
                    </div>
                    <div>
                        <div style="font-size: 24px; font-weight: bold; color: ${successRate >= 80 ? '#28a745' : successRate >= 60 ? '#ffc107' : '#dc3545'};">${successRate}%</div>
                        <div style="font-size: 12px; color: #666;">识别准确率</div>
                    </div>
                </div>
                <div style="margin-top: 10px; padding: 10px; background: ${successRate >= 80 ? '#d4edda' : successRate >= 60 ? '#fff3cd' : '#f8d7da'}; border-radius: 3px;">
                    <strong>投资经理:</strong> ${currentManager} &nbsp;&nbsp;
                    ${successRate < 80 ? '<strong style="color: #721c24;">⚠️ 建议检查并修正识别错误的记录</strong>' : '<strong style="color: #155724;">✅ 识别质量良好</strong>'}
                </div>
            `;
            
            document.getElementById('parseStatsInfo').innerHTML = statsHtml;
        }
        
        // 渲染解析结果表格
        function renderParseResultsTable() {
            const tbody = document.getElementById('parseResultsTable');
            tbody.innerHTML = '';
            
            currentParseResults.forEach((record, index) => {
                const row = document.createElement('tr');
                
                // 根据数据完整性设置行的背景色
                const isComplete = record.债券代码 && record.债券名称 && record.方向 && record.交易量 > 0;
                const bgColor = isComplete ? '#ffffff' : '#fff3cd';
                row.style.backgroundColor = bgColor;
                
                row.innerHTML = `
                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">
                        <input type="checkbox" class="record-checkbox" data-index="${index}">
                    </td>
                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${index + 1}</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">${record.债券代码 || '<span style="color: #dc3545;">未识别</span>'}</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">${record.债券名称 || '<span style="color: #dc3545;">未识别</span>'}</td>
                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${record.方向 || '<span style="color: #dc3545;">未识别</span>'}</td>
                    <td style="padding: 8px; border: 1px solid #ddd; text-align: right;">${record.交易量 || '<span style="color: #dc3545;">0</span>'}</td>
                    <td style="padding: 8px; border: 1px solid #ddd; text-align: right;">${record.收益率 || '<span style=\"color: #dc3545;\">未识别</span>'}</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">${record.收益率类型 || '未知'}</td>
                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${record.交易场所 || '未知'}</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">${record.中介 || ''}</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">${record.终端机构名称 || ''}</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">${record.做市商机构名称 || ''}</td>
                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">
                        <button class="btn btn-sm btn-primary" onclick="editRecord(${index})" style="padding: 2px 6px; font-size: 11px;">编辑</button>
                    </td>
                    <td style="padding: 8px; border: 1px solid #ddd; font-size: 12px; max-width: 300px; overflow: hidden; text-overflow: ellipsis;" title="${record.原始文本 || record.原始指令文本 || '无原始文本'}">${record.原始文本 || record.原始指令文本 || '无原始文本'}</td>
                `;
                
                tbody.appendChild(row);
            });
            
            // 计算交易量合计并添加合计行
            let totalVolume = 0;
            let buyVolume = 0;
            let sellVolume = 0;
            
            currentParseResults.forEach(record => {
                const volume = parseFloat(record.交易量) || 0;
                totalVolume += volume;
                
                if (record.方向 === '买入') {
                    buyVolume += volume;
                } else if (record.方向 === '卖出') {
                    sellVolume += volume;
                }
            });
            
            // 添加合计行
            const totalRow = document.createElement('tr');
            totalRow.style.backgroundColor = '#f0f8ff';
            totalRow.style.fontWeight = 'bold';
            totalRow.style.borderTop = '2px solid #1976d2';
            
            totalRow.innerHTML = `
                <td colspan="5" style="padding: 12px; border: 1px solid #ddd; text-align: right; font-size: 14px;">合计:</td>
                <td style="padding: 12px; border: 1px solid #ddd; text-align: right; font-size: 14px; color: #1976d2;">${totalVolume.toFixed(2)}</td>
                <td colspan="5" style="padding: 12px; border: 1px solid #ddd; text-align: left; font-size: 12px; color: #666;">
                    买入: ${buyVolume.toFixed(2)}万 | 卖出: ${sellVolume.toFixed(2)}万 | 总计: ${totalVolume.toFixed(2)}万
                </td>
            `;
            
            tbody.appendChild(totalRow);
            
            // 更新记录计数
            document.getElementById('editingRecordCount').textContent = `共 ${currentParseResults.length} 条记录`;
        }
        
        // 编辑记录
        function editRecord(index) {
            editingRecordIndex = index;
            const record = currentParseResults[index];
            
            // 填充编辑表单
            document.getElementById('editBondCode').value = record.债券代码 || '';
            document.getElementById('editBondName').value = record.债券名称 || '';
            document.getElementById('editDirection').value = record.方向 || '买入';
            document.getElementById('editVolume').value = record.交易量 || '';
            document.getElementById('editYield').value = record.收益率 || '';
            document.getElementById('editYieldType').value = record.收益率类型 || '到期收益率';
            document.getElementById('editTradingVenue').value = record.交易场所 || '';
            document.getElementById('editIntermediary').value = record.中介 || '';
            document.getElementById('editRemarks').value = record.备注 || '';
            
            // 显示编辑表单
            document.getElementById('recordEditForm').style.display = 'block';
            document.getElementById('editingRecordIndex').textContent = `#${index + 1}`;
            
            // 滚动到编辑表单
            document.getElementById('recordEditForm').scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        
        // 保存记录编辑
        function saveRecordEdit() {
            if (editingRecordIndex < 0) return;
            
            const record = currentParseResults[editingRecordIndex];
            
            // 更新记录
            record.债券代码 = document.getElementById('editBondCode').value.trim();
            record.债券名称 = document.getElementById('editBondName').value.trim();
            record.方向 = document.getElementById('editDirection').value;
            record.交易量 = parseFloat(document.getElementById('editVolume').value) || 0;
            record.收益率 = parseFloat(document.getElementById('editYield').value) || null;
            record.收益率类型 = document.getElementById('editYieldType').value;
            record.交易场所 = document.getElementById('editTradingVenue').value;
            record.中介 = document.getElementById('editIntermediary').value.trim();
            record.备注 = document.getElementById('editRemarks').value.trim();
            
            // 隐藏编辑表单
            cancelRecordEdit();
            
            // 重新渲染表格和统计
            renderParseResultsTable();
            updateParseStatsInfo();
            
            showToast(`记录 #${editingRecordIndex + 1} 修改成功`, 'success');
        }
        
        // 取消记录编辑
        function cancelRecordEdit() {
            document.getElementById('recordEditForm').style.display = 'none';
            editingRecordIndex = -1;
        }
        
        // 智能修正常见错误
        function autoFixCommonErrors() {
            let fixedCount = 0;
            
            currentParseResults.forEach(record => {
                // 修正1：自动填充交易场所
                if (!record.交易场所 && record.债券代码) {
                    if (record.债券代码.includes('.IB')) {
                        record.交易场所 = '银行间';
                        fixedCount++;
                    } else if (record.债券代码.includes('.SH') || record.债券代码.includes('.SZ')) {
                        record.交易场所 = '交易所';
                        fixedCount++;
                    }
                }
                
                // 修正2：收益率格式标准化（确保4位小数）
                if (record.收益率 && typeof record.收益率 === 'string') {
                    const yieldValue = parseFloat(record.收益率.replace('%', ''));
                    if (!isNaN(yieldValue)) {
                        record.收益率 = yieldValue; // 存储为数字，显示时添加4位小数和%
                        fixedCount++;
                    }
                } else if (record.收益率 && typeof record.收益率 === 'number') {
                    // 确保数字类型的收益率也保持精度
                    record.收益率 = parseFloat(record.收益率.toFixed(4));
                }
                
                // 修正3：交易量格式标准化
                if (record.交易量 && typeof record.交易量 === 'string') {
                    const volumeValue = parseFloat(record.交易量.replace(/[万,，]/g, ''));
                    if (!isNaN(volumeValue)) {
                        record.交易量 = volumeValue;
                        fixedCount++;
                    }
                }
                
                // 修正4：自动设置收益率类型
                if (record.收益率 && !record.收益率类型) {
                    record.收益率类型 = '到期收益率';
                    fixedCount++;
                }
                
                // 修正5：债券名称去除多余字符
                if (record.债券名称) {
                    const cleanName = record.债券名称.replace(/[\*\(\)（）]/g, '').trim();
                    if (cleanName !== record.债券名称) {
                        record.债券名称 = cleanName;
                        fixedCount++;
                    }
                }
            });
            
            if (fixedCount > 0) {
                renderParseResultsTable();
                updateParseStatsInfo();
                showToast(`智能修正完成，共修正 ${fixedCount} 处问题`, 'success');
            } else {
                showToast('未发现需要修正的问题', 'info');
            }
        }
        
        // 选择/取消选择记录
        function selectAllRecords() {
            document.querySelectorAll('.record-checkbox').forEach(cb => cb.checked = true);
        }
        
        function deselectAllRecords() {
            document.querySelectorAll('.record-checkbox').forEach(cb => cb.checked = false);
        }
        
        // 删除选中的记录
        function deleteSelectedRecords() {
            const selectedIndexes = [];
            document.querySelectorAll('.record-checkbox:checked').forEach(cb => {
                selectedIndexes.push(parseInt(cb.dataset.index));
            });
            
            if (selectedIndexes.length === 0) {
                showToast('请先选择要删除的记录', 'warning');
                return;
            }
            
            if (!confirm(`确定删除选中的 ${selectedIndexes.length} 条记录吗？`)) {
                return;
            }
            
            // 从后往前删除，避免索引变化
            selectedIndexes.sort((a, b) => b - a).forEach(index => {
                currentParseResults.splice(index, 1);
            });
            
            renderParseResultsTable();
            updateParseStatsInfo();
            cancelRecordEdit();
            
            showToast(`已删除 ${selectedIndexes.length} 条记录`, 'success');
        }
        
        // 确认并导入解析结果
        function confirmParseResults() {
            // 检查是否为标准版
            if (currentManager === '标准版') {
                confirmStandardParseResults();
                return;
            }
            
            // 扩展版的逻辑
            if (currentParseResults.length === 0) {
                showToast('没有可导入的记录', 'error');
                return;
            }
            
            // 验证必要字段
            const incompleteRecords = currentParseResults.filter(r => 
                !r.债券代码 || !r.债券名称 || !r.方向 || !r.交易量
            );
            
            if (incompleteRecords.length > 0) {
                const proceed = confirm(`有 ${incompleteRecords.length} 条记录信息不完整，确定要导入吗？\n\n不完整的记录可能影响后续处理。`);
                if (!proceed) return;
            }
            
            // 添加到系统中
            const orders = currentParseResults.map((record, index) => ({
                ...record,
                投资经理: currentManager,
                指令ID: `${currentManager}_${Date.now()}_${index}`,
                创建时间: new Date().toISOString(),
                状态: '待执行',
                完成进度: 0,
                子单列表: []
            }));
            
            // 更新状态
            if (!AppState.enhancedData.managers[currentManager]) {
                AppState.enhancedData.managers[currentManager] = [];
            }
            AppState.enhancedData.managers[currentManager].push(...orders);
            AppState.enhancedData.orders.push(...orders);
            // 统一数据旁路写入（quotes）
            try {
                const decoratedQ = orders.map(decorateQuoteRecord);
                const existedQ = new Set((AppState.unifiedData.quotes || []).map(q => q.quoteId));
                decoratedQ.forEach(q => { if (!existedQ.has(q.quoteId)) AppState.unifiedData.quotes.push(q); });
                if (typeof MatchEngine !== 'undefined') { MatchEngine.run(); }
                if (typeof renderUnifiedBoard === 'function') { renderUnifiedBoard(); }
                DataStorage.saveAppState();
            } catch (e) { console.warn('Unified(quotes) write-through failed:', e); }
            
            // 更新界面
            updateDashboard();
            renderManagerList();
            
            // 关闭模态框
            closeModal('parseResultsModal');
            
            // 清空导入输入框
            document.getElementById('importManager').value = '';
            document.getElementById('importText').value = '';
            
            showToast(`成功导入 ${orders.length} 条指令`, 'success');

            // 回到挂起的意图
            const a = (window.UnifiedIntent||{nextAction:null}).nextAction; (window.UnifiedIntent||{nextAction:null}).nextAction = null;
            if (a === 'auto') setTimeout(openAutoMatchPreview, 0);
            if (a === 'manual') setTimeout(openManualMatchWizard, 0);
        }
        
        // 重新解析
        function reparse() {
            // 检查是否为标准版
            if (currentManager === '标准版') {
                reparseStandard();
                return;
            }
            
            // 扩展版的逻辑
            if (!currentInputText || !currentManager) {
                showToast('缺少原始数据，无法重新解析', 'error');
                return;
            }
            
            // 关闭当前模态框
            closeModal('parseResultsModal');
            
            // 重新填充导入界面
            document.getElementById('importManager').value = currentManager;
            document.getElementById('importText').value = currentInputText;
            
            // 显示导入模态框
            document.getElementById('importModal').classList.add('active');
        }
        
        // ===== 编辑现有指令功能 =====
        
        let currentEditingOrder = null; // 当前正在编辑的指令
        
        // 编辑现有指令
        function editExistingOrder(orderId) {
            const order = AppState.enhancedData.orders.find(o => o.指令ID === orderId);
            if (!order) {
                showToast('指令未找到', 'error');
                return;
            }
            
            currentEditingOrder = order;
            
            // 填充基本信息
            document.getElementById('editOrderId').textContent = order.指令ID;
            document.getElementById('editOrderCreateTime').textContent = formatDateTime(order.创建时间);
            document.getElementById('editOrderStatus').textContent = order.状态;
            document.getElementById('editOrderProgress').textContent = order.完成进度 || 0;
            document.getElementById('editOrderOriginalText').textContent = order.原始文本 || order.原始指令文本 || '无原始文本';
            
            // 填充编辑表单
            document.getElementById('editOrderManager').value = order.投资经理 || '';
            document.getElementById('editOrderCode').value = order.债券代码 || '';
            document.getElementById('editOrderName').value = order.债券名称 || '';
            document.getElementById('editOrderDirection').value = order.方向 || '买入';
            document.getElementById('editOrderVolume').value = order.交易量 || '';
            document.getElementById('editOrderYield').value = order.收益率 ? (typeof order.收益率 === 'number' ? order.收益率.toFixed(4) : parseFloat(order.收益率.replace('%', '')).toFixed(4)) : '';
            document.getElementById('editOrderYieldType').value = order.收益率类型 || '';
            document.getElementById('editOrderTradingVenue').value = order.交易场所 || '';
            document.getElementById('editOrderIntermediary').value = order.中介 || '';
            document.getElementById('editOrderSettlement').value = order.清算速度 || '';
            document.getElementById('editOrderNetPrice').value = order.净价 || '';
            document.getElementById('editOrderFullPrice').value = order.全价 || '';
            document.getElementById('editOrderRemarks').value = order.备注 || '';
            
            // 隐藏智能提示
            document.getElementById('editOrderSmartTips').style.display = 'none';
            
            // 显示模态框
            document.getElementById('editOrderModal').classList.add('active');
        }
        
        // 智能填充指令信息
        function autoFillOrderInfo() {
            const code = document.getElementById('editOrderCode').value.trim();
            const name = document.getElementById('editOrderName').value.trim();
            let tips = [];
            let fillCount = 0;
            
            // 根据债券代码智能填充交易场所
            if (code) {
                const tradingVenue = document.getElementById('editOrderTradingVenue');
                if (!tradingVenue.value) {
                    if (code.includes('.IB')) {
                        tradingVenue.value = '银行间';
                        tips.push('根据债券代码自动设置交易场所为：银行间');
                        fillCount++;
                    } else if (code.includes('.SH') || code.includes('.SZ')) {
                        tradingVenue.value = '交易所';
                        tips.push('根据债券代码自动设置交易场所为：交易所');
                        fillCount++;
                    }
                }
                
                // 自动设置清算速度
                const settlement = document.getElementById('editOrderSettlement');
                if (!settlement.value) {
                    settlement.value = 'T+0';
                    tips.push('自动设置清算速度为：T+0');
                    fillCount++;
                }
            }
            
            // 根据债券名称智能判断类型
            if (name) {
                const yieldType = document.getElementById('editOrderYieldType');
                if (!yieldType.value) {
                    if (name.includes('永续') || name.includes('永债')) {
                        yieldType.value = '行权收益率';
                        tips.push('永续债券建议使用行权收益率');
                        fillCount++;
                    } else {
                        yieldType.value = '到期收益率';
                        tips.push('常规债券设置为到期收益率');
                        fillCount++;
                    }
                }
            }
            
            // 显示智能提示
            if (tips.length > 0) {
                document.getElementById('editOrderTipsContent').innerHTML = tips.map(tip => 
                    `<div style="margin-bottom: 5px;">• ${tip}</div>`
                ).join('');
                document.getElementById('editOrderSmartTips').style.display = 'block';
                showToast(`智能填充完成，共填充 ${fillCount} 个字段`, 'success');
            } else {
                showToast('暂无可填充的字段', 'info');
            }
        }
        
        // 保存指令编辑
        function saveOrderEdit() {
            if (!currentEditingOrder) {
                showToast('没有正在编辑的指令', 'error');
                return;
            }
            
            // 获取表单数据
            const formData = {
                投资经理: document.getElementById('editOrderManager').value.trim(),
                债券代码: document.getElementById('editOrderCode').value.trim(),
                债券名称: document.getElementById('editOrderName').value.trim(),
                方向: document.getElementById('editOrderDirection').value,
                交易量: parseFloat(document.getElementById('editOrderVolume').value) || 0,
                收益率: document.getElementById('editOrderYield').value ? parseFloat(document.getElementById('editOrderYield').value) : null,
                收益率类型: document.getElementById('editOrderYieldType').value,
                交易场所: document.getElementById('editOrderTradingVenue').value,
                中介: document.getElementById('editOrderIntermediary').value.trim(),
                清算速度: document.getElementById('editOrderSettlement').value,
                净价: parseFloat(document.getElementById('editOrderNetPrice').value) || null,
                全价: parseFloat(document.getElementById('editOrderFullPrice').value) || null,
                备注: document.getElementById('editOrderRemarks').value.trim()
            };
            
            // 验证必填字段
            if (!formData.债券代码 || !formData.债券名称 || !formData.交易量) {
                showToast('请填写必要信息（债券代码、债券名称、交易量）', 'error');
                return;
            }
            
            // 记录修改历史
            const changes = [];
            for (const key in formData) {
                if (currentEditingOrder[key] !== formData[key]) {
                    changes.push({
                        field: key,
                        oldValue: currentEditingOrder[key],
                        newValue: formData[key]
                    });
                }
            }
            
            if (changes.length === 0) {
                showToast('没有检测到任何修改', 'info');
                return;
            }
            
            // 更新指令数据
            Object.assign(currentEditingOrder, formData);
            currentEditingOrder.修改时间 = new Date().toISOString();
            
            // 如果投资经理发生变化，需要更新管理器列表
            if (changes.some(c => c.field === '投资经理')) {
                // 从原管理器列表中移除
                const oldManager = changes.find(c => c.field === '投资经理').oldValue;
                if (AppState.enhancedData.managers[oldManager]) {
                    AppState.enhancedData.managers[oldManager] = AppState.enhancedData.managers[oldManager]
                        .filter(o => o.指令ID !== currentEditingOrder.指令ID);
                    if (AppState.enhancedData.managers[oldManager].length === 0) {
                        delete AppState.enhancedData.managers[oldManager];
                    }
                }
                
                // 添加到新管理器列表
                if (!AppState.enhancedData.managers[formData.投资经理]) {
                    AppState.enhancedData.managers[formData.投资经理] = [];
                }
                AppState.enhancedData.managers[formData.投资经理].push(currentEditingOrder);
            }
            
            // 更新界面
            updateDashboard();
            renderManagerList();
            if (window.currentViewMode === 'table') {
                renderOrdersTable();
            } else {
                renderOrderDetails();
            }
            
            // 关闭模态框
            closeModal('editOrderModal');
            
            // 显示修改总结
            const changesSummary = changes.map(c => 
                `${c.field}: ${c.oldValue || '空'} → ${c.newValue || '空'}`
            ).join('\n');
            
            showToast(`指令修改成功！共更新 ${changes.length} 个字段`, 'success');
            console.log('修改详情:', changesSummary);
            
            currentEditingOrder = null;
        }
        
        // 格式化日期时间
        function formatDateTime(isoString) {
            if (!isoString) return '-';
            const date = new Date(isoString);
            return date.toLocaleString('zh-CN', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        // 扩展版功能
        function initEnhancedApp() {
            updateDashboard();
            renderManagerList();
            
            // 默认显示表格视图
            window.currentViewMode = 'table';
            switchToTableView();
        }

        function initUnifiedApp() {
            if (!AppState.unifiedData) AppState.unifiedData = { prefs: {} };
            if (!AppState.unifiedData.prefs) AppState.unifiedData.prefs = {};
            if (AppState.unifiedData.prefs.previewBeforeMerge === undefined) {
                AppState.unifiedData.prefs.previewBeforeMerge = true;
            }
            const chk = document.getElementById('unifiedPreviewBeforeMerge');
            if (chk) chk.checked = !!AppState.unifiedData.prefs.previewBeforeMerge;
            renderUnifiedBoard();
        }

        // 统计重算：每次渲染/清空/解析后调用，避免旧缓存值
        function recomputeUnifiedStats() {
            const data   = AppState.unifiedData || {};
            const deals  = data.deals  || [];
            const quotes = data.quotes || [];
            const links  = data.links  || [];

            // 仅统计“已确认”的匹配作为有效进度来源
            const confirmedLinks    = links.filter(l => l.confirmed);
            const confirmedDealIds  = new Set(confirmedLinks.map(l => l.dealId));
            const confirmedQuoteIds = new Set(confirmedLinks.map(l => l.quoteId));

            // DONE 覆盖率：与之前一致
            const matchedDeals = deals.filter(d => confirmedDealIds.has(d.dealId)
                                || (d.state && d.state !== 'unfilled')
                                || (d.fillWan||0) > 0).length;

            // 报价统计：以“全部报价”为分母；以“已确认关联DONE的报价”为完成
            const totalQuotes     = quotes.length;
            const confirmedQuotes = quotes.filter(q => confirmedQuoteIds.has(q.quoteId));
            const completedQuotes = confirmedQuotes.length;
            const totalQuoteWan   = quotes.reduce((s,q)=> s + (q.volumeWan||0), 0);
            // 量：按确认参与匹配的报价量累计（无需等待分配落地）
            const filledQuoteWan  = confirmedQuotes.reduce((s,q)=> s + (q.volumeWan||0), 0);

            data.stats = {
                totalDeals: deals.length,
                matchedDeals,
                coverage: deals.length ? Math.round(100*matchedDeals/deals.length) : 0,
                totalQuotes,
                completedQuotes,
                completionRate: totalQuotes ? Math.round(100*completedQuotes/totalQuotes) : 0,
                totalQuoteWan,
                filledQuoteWan,
                remainingQuoteWan: Math.max(0, totalQuoteWan - filledQuoteWan),
                lastMatchedAt: data.stats && data.stats.lastMatchedAt || null
            };
        }

        function parseUnifiedDone() {
            const text = (document.getElementById('unifiedDoneInput').value || '').trim();
            if (!text) { showToast('请输入DONE文本', 'error'); return; }
            if (!parser) initializeParsers();
            const stdResults = parser.parseText(text) || [];
            if (AppState.unifiedData && AppState.unifiedData.prefs && AppState.unifiedData.prefs.previewBeforeMerge) {
                const defaultMgr = (AppState.unifiedData && AppState.unifiedData.prefs &&
                               (AppState.unifiedData.prefs.defaultManagerDone ?? AppState.unifiedData.prefs.defaultManager)) || '';
                const resultsForEdit = stdResults.map(order => ({
                    原始文本: order.原始文本,
                    投资经理: order.投资经理 || defaultMgr,
                    债券代码: order.债券代码,
                    债券名称: order.债券名称,
                    方向: order.方向,
                    中介: order.中介,
                    原中介编号: order.原中介编号 || '',
                    发单方式: order.发单方式 || '',
                    对手交易员: order.对手交易员 || '',
                    做市商机构名称: order.做市商机构名称 || '',
                    终端机构名称: order.终端机构名称 || '',
                    户名: order.户名 || '',
                    交易量: order.交易量,
                    收益率: order.收益率,
                    收益率类型: order.收益率类型,
                    净价: order.净价,
                    全价: order.全价,
                    交易日期: order.交易日期 || new Date().toISOString().split('T')[0],
                    清算速度: order.清算速度,
                    交易场所: order.交易场所,
                    备注: order.备注,
                    解析状态: (order.债券代码 && order.债券名称 && order.方向) ? '成功' : '警告',
                    状态: '待执行',
                    完成进度: 0,
                    指令ID: order.指令ID || `STD_${Date.now()}_${Math.random().toString(16).slice(2,6)}`
                }));
                if (resultsForEdit.length === 0) {
                    resultsForEdit.push({
                        原始文本: text, 投资经理: defaultMgr,
                        债券代码: '', 债券名称: '', 方向: '', 中介: '', 原中介编号: '',
                        做市商机构名称: '', 终端机构名称: '', 户名: '',
                        交易量: '', 收益率: '', 收益率类型: '', 净价: '', 全价: '',
                        交易日期: '', 清算速度: '', 交易场所: '', 发单方式: '',
                        对手交易员: '', 备注: '', 解析状态: '失败'
                    });
                    showToast('未识别到有效DONE记录，已插入一条空白行以便手工录入', 'warning');
                }
                showStandardParseResultsModal(resultsForEdit, text);
                return;
            }
            const defaultMgr = (AppState.unifiedData && AppState.unifiedData.prefs &&
                           (AppState.unifiedData.prefs.defaultManagerDone ?? AppState.unifiedData.prefs.defaultManager)) || '';
            const results = stdResults.map(order => ({
                原始文本: order.原始文本,
                投资经理: order.投资经理 || defaultMgr,
                债券代码: order.债券代码,
                债券名称: order.债券名称,
                方向: order.方向,
                中介: order.中介,
                原中介编号: order.原中介编号 || '',
                发单方式: order.发单方式 || '',
                对手交易员: order.对手交易员 || '',
                做市商机构名称: order.做市商机构名称 || '',
                终端机构名称: order.终端机构名称 || '',
                户名: order.户名 || '',
                交易量: order.交易量,
                收益率: order.收益率,
                收益率类型: order.收益率类型,
                净价: order.净价,
                全价: order.全价,
                交易日期: order.交易日期 || new Date().toISOString().split('T')[0],
                清算速度: order.清算速度,
                交易场所: order.交易场所,
                备注: order.备注,
                解析状态: (order.债券代码 && order.债券名称 && order.方向) ? '成功' : '警告',
                状态: '待执行',
                完成进度: 0,
                指令ID: order.指令ID || `STD_${Date.now()}_${Math.random().toString(16).slice(2,6)}`
            }));
            try {
                const decorated = results.map(decorateDealRecord);
                const existed = new Set((AppState.unifiedData.deals||[]).map(d=>d.dealId));
                decorated.forEach(d=>{ if(!existed.has(d.dealId)) AppState.unifiedData.deals.push(d); });
                AppState.unifiedData.stats.totalDeals = AppState.unifiedData.deals.length;
                MatchEngine.run();
                if (typeof recomputeUnifiedStats === 'function') recomputeUnifiedStats();
                renderUnifiedBoard();
                DataStorage.saveAppState();
                showToast(`DONE解析完成，新增${decorated.length}条`, 'success');
                if (UnifiedViewState.activeTab !== 'deals') {
                    if (confirm('DONE 解析完成，是否切换到 DONE 预览？（不会影响已解析的报价）')) {
                        toggleUnifiedPreview('deals');
                    }
                } else {
                    toggleUnifiedPreview('deals');
                }
            } catch(e){ console.warn('Unified parse DONE failed:', e); }
        }
        function parseUnifiedQuote() {
            const text = (document.getElementById('unifiedQuoteInput').value || '').trim();
            if (!text) { showToast('请输入报价文本', 'error'); return; }
            if (!enhancedParser) initializeParsers();
            const defaultMgr = (AppState.unifiedData && AppState.unifiedData.prefs &&
                           (AppState.unifiedData.prefs.defaultManagerQuote ?? AppState.unifiedData.prefs.defaultManager)) || '统一导入';
            const parsed = (enhancedParser.parseEnhancedRecords(text, defaultMgr)||{}).records || [];
            if (AppState.unifiedData && AppState.unifiedData.prefs && AppState.unifiedData.prefs.previewBeforeMerge) {
                const resultsForEdit = parsed.map(r => ({
                    原始指令文本: r.原始文本 || r.原始指令文本 || '',
                    投资经理: r.投资经理 || defaultMgr,
                    债券代码: r.债券代码 || '',
                    债券名称: r.债券名称 || '',
                    方向: r.方向 || '',
                    收益率: r.收益率 ?? '',
                    收益率类型: r.收益率类型 || '',
                    交易量: r.交易量 || 0,
                    交易日期: r.交易日期 || '',
                    备注: r.备注 || '',
                    解析状态: r.解析状态 || '成功'
                }));
                if (resultsForEdit.length === 0) {
                    resultsForEdit.push({
                        原始指令文本: text, 投资经理: defaultMgr,
                        债券代码: '', 债券名称: '', 方向: '', 收益率: '', 交易量: '',
                        交易日期: '', 备注: '', 解析状态: '失败'
                    });
                    showToast('未识别到有效报价记录，已插入一条空白行以便手工录入', 'warning');
                }
                showParseResultsModal(resultsForEdit, defaultMgr, text);
                return;
            }
            parsed.forEach((o, i) => {
                if (!o.指令ID) o.指令ID = `QTE_${Date.now()}_${i}`;
                const y = parseFloat((o.收益率||'').toString().replace('%',''));
                if (!isNaN(y)) o.收益率 = y;
            });
            try {
                const decoratedQ = parsed.map(decorateQuoteRecord);
                const existedQ = new Set((AppState.unifiedData.quotes||[]).map(q=>q.quoteId));
                decoratedQ.forEach(q=>{ if(!existedQ.has(q.quoteId)) AppState.unifiedData.quotes.push(q); });
                MatchEngine.run();
                if (typeof recomputeUnifiedStats === 'function') recomputeUnifiedStats();
                renderUnifiedBoard();
                DataStorage.saveAppState();
                showToast(`报价解析完成，新增${decoratedQ.length}条`, 'success');
                if (UnifiedViewState.activeTab !== 'quotes') {
                    if (confirm('报价解析完成，是否切换到 报价 预览？（不会影响已解析的DONE）')) {
                        toggleUnifiedPreview('quotes');
                    }
                } else {
                    toggleUnifiedPreview('quotes');
                }
            } catch(e){ console.warn('Unified parse QUOTE failed:', e); }
        }
        function openStatsDrilldown(which){
            UnifiedViewState.dealFilter = null;
            UnifiedViewState.quoteFilter = null;

            if (which === 'deals_all') {
                toggleUnifiedPreview('deals');
            } else if (which === 'deals_matched') {
                const data = AppState.unifiedData || {};
                const matchedDealIds = new Set((data.links||[]).filter(l=>l.confirmed).map(l=>l.dealId));
                UnifiedViewState.dealFilter = d => matchedDealIds.has(d.dealId) || (d.state && d.state !== 'unfilled');
                toggleUnifiedPreview('deals');
            } else if (which === 'quotes_completed') {
                UnifiedViewState.quoteFilter = q => !!q.completed;
                toggleUnifiedPreview('quotes');
            } else if (which === 'quotes_filled') {
                UnifiedViewState.quoteFilter = q => (q.filledWan||0) > 0;
                toggleUnifiedPreview('quotes');
            }

            if (document.getElementById('unifiedDealsPreview')) renderUnifiedDealsPreview();
            if (document.getElementById('unifiedQuotesPreview')) renderUnifiedQuotesPreview();
        }

        // 统一预览切换与渲染
        function toggleUnifiedPreview(which){
            const d=document.getElementById('unifiedDealsPreview');
            const q=document.getElementById('unifiedQuotesPreview');
            if (!d || !q) return;
            UnifiedViewState.activeTab = which;
            d.style.display = (which==='deals'?'block':'none');
            q.style.display = (which==='quotes'?'block':'none');
            if (which==='deals') { renderUnifiedDealsPreview(); } else { renderUnifiedQuotesPreview(); }
        }

        function renderUnifiedDealsPreview() {
            let deals = (AppState.unifiedData.deals||[]);
            if (typeof UnifiedViewState.dealFilter === 'function') {
                deals = deals.filter(UnifiedViewState.dealFilter);
            }
            const rows = deals.map(d => d.raw || {});
            renderStandardTableInto('unifiedDealsPreview', rows, {
                selectable: true,
                selectAllHtml: '<input type="checkbox" id="selAllDeals" onchange="toggleSelectAllUnified(\'deal\', this.checked)">',
                rowCheckboxHtml: (record)=> `<input type=\"checkbox\" class=\"sel-deal\" data-id=\"${(record.指令ID||'')}\">`,
                extraOpsRenderer: (record) => {
                    const id = record.指令ID || '';
                    return `
                        <div style="display:flex;gap:6px;justify-content:center;flex-wrap:wrap;">
                          <button class=\"btn btn-sm\" onclick=\"openEditFromUnified('deal','${id}')\">编辑</button>
                        </div>`;
                }
            });
        }

        function renderUnifiedQuotesPreview() {
            const data = AppState.unifiedData || {};
            let quotes = (data.quotes || []);
            if (typeof UnifiedViewState.quoteFilter === 'function') {
                quotes = quotes.filter(UnifiedViewState.quoteFilter);
            }
            if (UnifiedViewState.quoteDone) quotes = quotes.filter(q => q.completed);

            const linksByQuote = (data.links || [])
                .filter(l => l.confirmed)
                .reduce((m, l) => { if (!m[l.quoteId]) m[l.quoteId] = []; m[l.quoteId].push(l); return m; }, {});

            const rows = quotes.map(q => {
                const filled = q.filledWan || 0;
                const total  = q.volumeWan || 0;
                const remain = Math.max(0, total - filled);
                const prog   = total > 0 ? Math.min(100, Math.round(100 * filled / total)) : 0;
                const dn     = (linksByQuote[q.quoteId] || []).length;

                const bar = `
                  <div class="progress-bar">
                    <div class="fill" style="width:${prog}%"></div>
                  </div>
                  <div style="font-size:12px;color:#666;text-align:right;">${prog}%</div>
                `;

                return `
                  <tr>
                    <td><input type="checkbox" class="sel-quote" data-id="${q.quoteId}"></td>
                    <td>${q.code || '-'}</td>
                    <td>${q.name || '-'}</td>
                    <td>${q.side || '-'}</td>
                    <td>${q.volumeWan ?? '-'}</td>
                    <td>${q.yield == null ? '-' : Number(q.yield).toFixed(4)}</td>
                    <td>${q.tradeDate || '-'}</td>
                    <td>${filled}</td>
                    <td>${remain}</td>
                    <td style="min-width:140px;">${bar}</td>
                    <td>${dn}</td>
                    <td>${q.manager || '-'}</td>
                    <td>
                      <button class="btn btn-sm" onclick="openEditFromUnified('quote','${q.quoteId}')">编辑</button>
                      <button class="btn btn-sm" onclick="clearQuoteAlloc('${q.quoteId}')">重置进度</button>
                    </td>
                  </tr>`;
            }).join('');

            const html = `
                <table class="orders-table" style="width:100%; background:white; border-radius:8px;">
                  <thead>
                    <tr style="text-align:left;background:#f1f3f5;">
                      <th style="width:36px;"><input type="checkbox" id="selAllQuotes" onchange="toggleSelectAllUnified('quote', this.checked)"></th>
                      <th style="padding:8px;">债券代码</th>
                      <th style="padding:8px;">债券名称</th>
                      <th style="padding:8px;">边</th>
                      <th style="padding:8px;">数量(万)</th>
                      <th style="padding:8px;">收益率(%)</th>
                      <th style="padding:8px;">交易日</th>
                      <th style="padding:8px;">已成交(万)</th>
                      <th style="padding:8px;">剩余(万)</th>
                      <th style="padding:8px;">进度</th>
                      <th style="padding:8px;">关联DONE</th>
                      <th style="padding:8px;">投资经理</th>
                      <th style="padding:8px;">操作</th>
                    </tr>
                  </thead>
                  <tbody>${rows || ''}</tbody>
                </table>`;
            const el = document.getElementById('unifiedQuotesPreview'); if (el) el.innerHTML = html;
        }

        function openEditFromUnified(kind, id){
            if (kind==='deal'){
                const d = (AppState.unifiedData.deals||[]).find(x=>x.dealId===id || (x.raw&&x.raw.指令ID===id));
                if (!d) return;
                const r = d.raw || {};
                showStandardParseResultsModal([{...r}], r.原始文本 || r.原始指令文本 || '');
            } else {
                const q = (AppState.unifiedData.quotes||[]).find(x=>x.quoteId===id);
                if (!q) return;
                const r = q.raw || {};
                showParseResultsModal([{...r}], r.投资经理 || '统一导入', r.原始文本 || r.原始指令文本 || '');
            }
        }


        // Link Picker（匹配选择）
        let _linkPickerState = { dealId: null, selectedQuoteId: null };
        function openLinkPickerModal(dealId) {
            const { deals=[], quotes=[], links=[] } = AppState.unifiedData || {};
            const deal = deals.find(d => (d.raw?.指令ID || d.dealId) === dealId);
            if (!deal) return;
            _linkPickerState = { dealId, selectedQuoteId: null };
            const candidates = links.filter(l => l.dealId === deal.dealId).sort((a,b)=> (b.score||0)-(a.score||0));
            const qIndex = new Map(quotes.map(q=>[q.quoteId,q]));
            const dealInfo = `
                <div style="margin-bottom:8px;padding:8px;background:#f8f9fa;border-radius:6px;">
                  <div><b>${deal.code||''}</b> ${deal.name || ''} ｜ <b>${deal.direction||''}</b> ｜ ${deal.volumeWan||'-'}万 ｜ ${deal.yield??'-'}</div>
                  <div style="font-size:12px;color:#666;">期望边：${deal.expQuoteSide || '-'}</div>
                </div>`;
            const rows = (candidates.map(c=>{
                const q = qIndex.get(c.quoteId) || {};
                const reason = (c.reason||[]).join(' | ');
                return `
                <tr>
                  <td><input type=\"radio\" name=\"quotePick\" value=\"${c.quoteId}\" onclick=\"_linkPickerState.selectedQuoteId='${c.quoteId}'\"></td>
                  <td>${q.code||'-'}</td>
                  <td>${q.name||'-'}</td>
                  <td>${q.side||'-'}</td>
                  <td>${q.yield==null?'-':Number(q.yield).toFixed(4)}</td>
                  <td>${q.volumeWan||'-'}</td>
                  <td>${q.manager||'-'}</td>
                  <td>${c.score||'-'}</td>
                  <td style=\"font-size:12px;color:#666;\">${reason||''}</td>
                </tr>`;
            }).join('')) || `<tr><td colspan=\"9\" style=\"text-align:center;color:#999;\">暂无候选（可「手动录入」）</td></tr>`;
            const table = `
              ${dealInfo}
              <div style="margin-bottom:8px;">
                <button class="btn btn-secondary btn-sm" onclick="openManualQuoteModal('${dealId}')">手动录入报价并绑定</button>
              </div>
              <table class="orders-table">
                <thead>
                  <tr>
                    <th>选择</th><th>债券代码</th><th>债券名称</th><th>边</th>
                    <th>收益率</th><th>量(万)</th><th>投资经理</th>
                    <th>分数</th><th>依据</th>
                  </tr>
                </thead>
                <tbody>${rows}</tbody>
              </table>`;
            const body = document.getElementById('linkPickerBody'); if (body) body.innerHTML = table;
            document.getElementById('linkPickerModal')?.classList.add('active');
        }
        function confirmLinkSelection() {
            const { selectedQuoteId, dealId } = _linkPickerState;
            if (!selectedQuoteId) { showToast('请先选择一个报价或手动录入', 'warning'); return; }
            const data = AppState.unifiedData || {};
            const d = (data.deals||[]).find(x => (x.raw?.指令ID || x.dealId) === dealId);
            if (!d) return;
            const l = (data.links||[]).find(x => x.dealId === d.dealId && x.quoteId === selectedQuoteId);
            if (l) {
                l.confirmed = true;
                DataStorage.saveAppState();
                renderUnifiedBoard();
                showToast('已确认匹配', 'success');
            }
            closeModal('linkPickerModal');
        }

        // 批量匹配选择：状态与打开
        let _batchPickState = { sel: new Map(), topN: 3 };
        function openBatchLinkPickerModal(){
            try { if (typeof MatchEngine !== 'undefined') MatchEngine.run(); } catch(e){}
            _batchPickState.sel = new Map();
            renderBatchLinkPickerContent();
            document.getElementById('batchLinkPickerModal')?.classList.add('active');
        }
        function batchPickTop1(){
            const data = AppState.unifiedData || {};
            const links = data.links || [];
            const deals = data.deals || [];
            const linksByDeal = links.reduce((m, l)=>{ if (!m[l.dealId]) m[l.dealId] = []; m[l.dealId].push(l); return m; }, {});
            deals.forEach(d=>{
                const cands = (linksByDeal[d.dealId]||[]).sort((a,b)=>(b.score||0)-(a.score||0));
                const top = cands[0];
                if (top) _batchPickState.sel.set(d.dealId, top.quoteId);
            });
            renderBatchLinkPickerContent();
        }
        function batchClearSelections(){
            _batchPickState.sel.clear();
            renderBatchLinkPickerContent();
        }
        function renderBatchLinkPickerContent(){
            const kw = (document.getElementById('batchPickSearch')?.value || '').trim().toUpperCase();
            const onlyNo = !!(document.getElementById('batchOnlyNoCandidate')||{}).checked;
            const onlyUnconfirmed = !!(document.getElementById('batchOnlyUnconfirmed')||{}).checked;

            const data = AppState.unifiedData || {};
            const { deals=[], quotes=[], links=[] } = data;
            const qIdx = new Map(quotes.map(q=>[q.quoteId,q]));
            const linksByDeal = links.reduce((m, l)=>{ if (!m[l.dealId]) m[l.dealId] = []; m[l.dealId].push(l); return m; }, {});
            const pieces = [];
            deals.forEach(d => {
                const cand = (linksByDeal[d.dealId]||[]).sort((a,b)=>(b.score||0)-(a.score||0));
                const hasCand = cand.length>0;
                const hasConfirmed = cand.some(l=>l.confirmed);
                if (kw) {
                    const t = `${(d.code||'')}${(d.name||'')}`.toUpperCase();
                    if (!t.includes(kw)) return;
                }
                if (onlyNo && hasCand) return;
                if (onlyUnconfirmed && hasConfirmed) return;

                const rows = (cand.slice(0, _batchPickState.topN).map(l=>{
                    const q = qIdx.get(l.quoteId)||{};
                    const checked = _batchPickState.sel.get(d.dealId) === l.quoteId ? 'checked' : '';
                    const cfm = l.confirmed ? '✅' : '';
                    return `
                        <tr>
                          <td><input type="radio" name="pick_${d.dealId}" ${checked}
                               onclick="_batchPickState.sel.set('${d.dealId}','${l.quoteId}')"></td>
                          <td>${q.code||''}</td>
                          <td>${q.name||''}</td>
                          <td>${q.side||''}</td>
                          <td>${q.yield==null?'-':Number(q.yield).toFixed(4)}%</td>
                          <td>${q.volumeWan||'-'}</td>
                          <td>${q.manager||'-'} ${cfm}</td>
                          <td>${l.score||'-'}</td>
                          <td style="color:#666;font-size:12px;">${(l.reason||[]).join(' | ')}</td>
                        </tr>`;
                }).join('')) || `<tr><td colspan="9" style="text-align:center;color:#999;">无候选（可点击下方“手动录入”）</td></tr>`;

                pieces.push(`
                  <div style="border:1px solid #eee;border-radius:8px;margin-bottom:10px;">
                    <div style="display:flex;justify-content:space-between;align-items:center;padding:8px 12px;background:#f8f9fa;border-bottom:1px solid #eee;">
                      <div><b>${d.code||''}</b> ${d.name||''} ｜ <b>${d.direction||''}</b> 需${d.expQuoteSide||''} ｜ 量 ${d.volumeWan||'-'} ｜ ${d.yield==null?'-':Number(d.yield).toFixed(4)}%</div>
                      <div style="display:flex;gap:6px;">
                        <button class="btn btn-sm" onclick="openLinkPickerModal('${d.raw?.指令ID || d.dealId}')">查看候选</button>
                        <button class="btn btn-sm" onclick="openManualQuoteModal('${d.raw?.指令ID || d.dealId}')">手动录入</button>
                      </div>
                    </div>
                    <table class="orders-table">
                      <thead><tr>
                        <th style="width:50px;">选</th><th>债券代码</th><th>债券名称</th><th>边</th>
                        <th>收益率</th><th>量(万)</th><th>投资经理</th><th>分数</th><th>依据</th>
                      </tr></thead>
                      <tbody>${rows}</tbody>
                    </table>
                  </div>
                `);
            });

            const body = document.getElementById('batchLinkPickerBody');
            if (body) body.innerHTML = pieces.join('') || `<div style="padding:16px;color:#888;text-align:center;">无符合条件的记录</div>`;
        }
        function confirmBatchLinkSelections(){
            const data = AppState.unifiedData || {};
            const { deals=[], links=[] } = data;
            const pick = _batchPickState.sel;
            if (!pick.size){ showToast('未选择任何匹配', 'warning'); return; }
            let cfm = 0;
            deals.forEach(d=>{
                const qid = pick.get(d.dealId);
                if (!qid) return;
                let l = links.find(x=>x.dealId===d.dealId && x.quoteId===qid);
                if (!l) {
                    l = { linkId: `L_${Date.now()}_${Math.random().toString(16).slice(2,6)}`, dealId: d.dealId, quoteId: qid };
                    l.score = l.score || 100;
                    l.reason = l.reason || ['batch'];
                    (AppState.unifiedData.links||[]).push(l);
                }
                l.confirmed = true;
                cfm++;
            });
            DataStorage.saveAppState();
            renderUnifiedBoard();
            showToast(`已确认 ${cfm} 条匹配`, 'success');
            closeModal('batchLinkPickerModal');
        }
        function applyBatchSelectionsAndAllocate(){
            try { if (typeof MatchEngine !== 'undefined') MatchEngine.run(); } catch(e){}
            const data = AppState.unifiedData || {};
            const { deals=[], quotes=[], links=[] } = data;
            const pick = _batchPickState?.sel || new Map();
            if (!deals.length || !quotes.length) { showToast('请先解析 DONE 与 报价文本', 'warning'); return; }
            if (!pick.size) { showToast('未选择任何匹配', 'warning'); return; }

            snapshotForUndo();

            deals.forEach(d => { d.fillWan = d.fillWan||0; });
            quotes.forEach(q => { q.filledWan = q.filledWan||0; q.fills = q.fills||[]; });
            links.forEach(l => { l.fillWan = l.fillWan||0; });

            const dIndex = new Map(deals.map(d=>[d.dealId,d]));
            const qIndex = new Map(quotes.map(q=>[q.quoteId,q]));
            let applied = 0;

            for (const [dealId, quoteId] of pick.entries()){
                const d = dIndex.get(dealId), q = qIndex.get(quoteId);
                if (!d || !q) continue;
                const need   = Math.max(0, (d.volumeWan||0) - (d.fillWan||0));
                const remain = Math.max(0, (q.volumeWan||0) - (q.filledWan||0));
                const alloc  = Math.min(need, remain);
                let l = (data.links||[]).find(x=>x.dealId===dealId && x.quoteId===quoteId);
                if (!l) {
                    l = { linkId:`L_${Date.now()}_${Math.random().toString(16).slice(2,6)}`, dealId, quoteId, score:100, reason:['batch'] };
                    (data.links||[]).push(l);
                }
                l.confirmed = true;
                if (alloc>0){
                    l.fillWan  = (l.fillWan||0) + alloc;
                    d.fillWan = (d.fillWan||0) + alloc;
                    d.state = (d.fillWan >= (d.volumeWan||0)) ? 'filled' : (d.fillWan>0?'partial':'unfilled');
                    q.filledWan = (q.filledWan||0) + alloc;
                    q.completed = (q.filledWan >= (q.volumeWan||0) - 1e-9);
                    if (!q.fills) q.fills = []; q.fills.push({ dealId, linkId:l.linkId, fillWan: alloc, at: Date.now() });
                }
                applied++;
            }

            data.stats.totalDeals = deals.length;
            data.stats.matchedDeals = deals.filter(d => d.state !== 'unfilled').length;
            data.stats.coverage = deals.length ? Math.round(100 * data.stats.matchedDeals / deals.length) : 0;
            data.stats.totalQuotes = quotes.length;
            data.stats.completedQuotes = quotes.filter(q => q.completed).length;
            data.stats.completionRate = quotes.length ? Math.round(100 * data.stats.completedQuotes / quotes.length) : 0;
            data.stats.totalQuoteWan = quotes.reduce((s,q)=> s + (q.volumeWan||0), 0);
            data.stats.filledQuoteWan = quotes.reduce((s,q)=> s + (q.filledWan||0), 0);
            data.stats.remainingQuoteWan = (data.stats.totalQuoteWan||0) - (data.stats.filledQuoteWan||0);

            DataStorage.saveAppState();
            renderUnifiedBoard();
            showToast(`已应用 ${applied} 条匹配并完成分配`, 'success');
            closeModal('batchLinkPickerModal');
        }
        // 手动录入报价
        let _manualQuoteDealId = null;
        function openManualQuoteModal(dealId) {
            _manualQuoteDealId = dealId || null;
            document.getElementById('manualQuoteModal')?.classList.add('active');
        }
        function saveManualQuote() {
            const code = (document.getElementById('mq_code')?.value || '').trim();
            const name = (document.getElementById('mq_name')?.value || '').trim();
            const sideRaw = (document.getElementById('mq_side')?.value || '').trim();
            const yd = parseFloat((document.getElementById('mq_yield')?.value || ''));
            const vol = parseFloat((document.getElementById('mq_vol')?.value || ''));
            const manager = (document.getElementById('mq_manager')?.value || '').trim();
            if (!code && !name) { showToast('请至少填写代码或名称', 'error'); return; }
            const qRec = {
                指令ID: `QTE_${Date.now()}`,
                债券代码: code || '',
                债券名称: name || '',
                方向: (/^(ofr|offer|卖出)$/i.test(sideRaw)?'卖出':'买入'),
                收益率: isNaN(yd)?null:yd,
                交易量: isNaN(vol)?0:vol,
                交易日期: new Date().toISOString().slice(0,10),
                投资经理: manager || (AppState.unifiedData?.prefs?.defaultManager || '')
            };
            const q = decorateQuoteRecord(qRec);
            const exists = (AppState.unifiedData.quotes||[]).some(x=>x.quoteId===q.quoteId);
            if (!exists) (AppState.unifiedData.quotes||[]).push(q);
            if (_manualQuoteDealId) {
                const d = (AppState.unifiedData.deals||[]).find(x => (x.raw?.指令ID || x.dealId) === _manualQuoteDealId);
                if (d) {
                    (AppState.unifiedData.links||[]).push({
                        linkId: `L_${Date.now()}`,
                        dealId: d.dealId,
                        quoteId: q.quoteId,
                        score: 100,
                        reason: ['manual'],
                        confirmed: true
                    });
                }
            }
            DataStorage.saveAppState();
            if (typeof MatchEngine !== 'undefined') MatchEngine.run();
            renderUnifiedBoard();
            closeModal('manualQuoteModal');
            closeModal('linkPickerModal');
            showToast('报价已保存并绑定', 'success');
        }

        function bulkSetManager() {
            const m = (document.getElementById('bulkManagerInput')?.value || '').trim();
            if (!m) { showToast('请输入经理名称', 'warning'); return; }
            const dealIds = Array.from(document.querySelectorAll('.sel-deal:checked')).map(x=>x.getAttribute('data-id'));
            const quoteIds = Array.from(document.querySelectorAll('.sel-quote:checked')).map(x=>x.getAttribute('data-id'));
            let cnt = 0;
            if (dealIds.length) {
                (AppState.unifiedData.deals||[]).forEach(d=>{
                    const id = d.dealId || (d.raw&&d.raw.指令ID);
                    if (dealIds.includes(id)) {
                        d.manager = m; if (d.raw) d.raw.投资经理 = m; cnt++;
                    }
                });
            }
            if (quoteIds.length) {
                (AppState.unifiedData.quotes||[]).forEach(q=>{
                    if (quoteIds.includes(q.quoteId)) { q.manager = m; if (q.raw) q.raw.投资经理 = m; cnt++; }
                });
            }
            DataStorage.saveAppState();
            renderUnifiedBoard();
            showToast(`已更新 ${cnt} 条记录的投资经理`, 'success');
        }

        function toggleSelectAllUnified(kind, checked) {
            const cls = (kind === 'deal') ? '.sel-deal' : '.sel-quote';
            document.querySelectorAll(cls).forEach(cb => cb.checked = checked);
        }

        function exportUnifiedDealsCSV(){
            const deals = (AppState.unifiedData.deals||[]);
            if (!deals.length) { showToast('没有 DONE 数据可导出', 'error'); return; }
            let csv = '\ufeff';
            csv += '投资经理,指令ID,债券代码,债券名称,方向,中介,原中介编号,做市商机构,终端机构,户名,交易量(万),收益率(%),收益率类型,净价,全价,交易日期,清算速度,交易场所,发单方式,对手交易员,备注,状态,完成进度(%),拆单策略,创建时间\n';
            deals.map(d=>d.raw||{}).forEach((record, index) => {
                const rowNum = index + 2;
                const bondCode = record.债券代码 || `=to_windcode(E${rowNum})`;
                const bondName = record.债券名称 || `=b_info_name(D${rowNum})`;
                const yieldValue = record.收益率 ? (typeof record.收益率 === 'string' && record.收益率.includes('%')
                                   ? parseFloat(record.收益率.replace('%','')).toFixed(4)+'%' : record.收益率) : '';
                csv += `${record.投资经理||''},${record.指令ID||''},${bondCode},${bondName},${record.方向||''},`;
                csv += `${record.中介||''},${record.原中介编号||''},${record.做市商机构名称||''},${record.终端机构名称||''},${record.户名||''},`;
                csv += `${record.交易量||''},${yieldValue},${record.收益率类型||''},${record.净价||''},${record.全价||''},${record.交易日期||''},`;
                csv += `${record.清算速度||''},${record.交易场所||''},${record.发单方式||''},${record.对手交易员||''},"${record.备注||''}",`;
                csv += `${record.状态||''},${record.完成进度||''},${record.拆单策略||''},${record.创建时间||''}\n`;
            });
            downloadFile(csv, `DONE_标准版_${new Date().toISOString().slice(0,10)}.csv`, 'text/csv;charset=utf-8');
            showToast('DONE（标准版）CSV导出成功', 'success');
        }

        function exportUnifiedQuotesCSV(){
            const quotes = (AppState.unifiedData.quotes||[]);
            if (!quotes.length) { showToast('没有 报价 数据可导出', 'error'); return; }
            let csv = '\ufeff';
            csv += '投资经理,指令ID,债券代码,债券名称,方向,中介,原中介编号,做市商机构,终端机构,户名,交易量(万),收益率(%),收益率类型,净价,全价,交易日期,清算速度,交易场所,发单方式,对手交易员,备注,状态,完成进度(%),拆单策略,创建时间\n';
            quotes.map(q=>q.raw||{}).forEach((order, index) => {
                const rowNum = index + 2;
                const bondCode = order.债券代码 || `=to_windcode(D${rowNum})`;
                const bondName = order.债券名称 || `=b_info_name(C${rowNum})`;
                const yieldDisplay = order.收益率 ? (typeof order.收益率 === 'number' ? order.收益率.toFixed(4)+'%' : order.收益率) : '';
                csv += `${order.投资经理||''},${order.指令ID||''},${bondCode},${bondName},${order.方向||''},${order.中介||''},${order.原中介编号||''},`;
                csv += `${order.做市商机构名称||''},${order.终端机构名称||''},${order.户名||''},${order.交易量||''},${yieldDisplay},${order.收益率类型||''},`;
                csv += `${order.净价||''},${order.全价||''},${order.交易日期||''},${order.清算速度||''},${order.交易场所||''},${order.发单方式||''},`;
                csv += `${order.对手交易员||''},"${order.备注||''}",${order.状态||''},${order.完成进度||''},${order.拆单策略||''},${order.创建时间||''}\n`;
            });
            downloadFile(csv, `报价_扩展版_${new Date().toISOString().slice(0,10)}.csv`, 'text/csv;charset=utf-8');
            showToast('报价（扩展版）CSV导出成功', 'success');
        }

        function deleteSelectedUnified(kind) {
            const cls = (kind === 'deal') ? '.sel-deal:checked' : '.sel-quote:checked';
            const ids = Array.from(document.querySelectorAll(cls)).map(x => x.getAttribute('data-id'));
            if (!ids.length) { showToast('请先勾选需要删除的记录', 'warning'); return; }
            if (!confirm(`确定删除选中的 ${ids.length} 条${kind==='deal'?'DONE':'报价'}吗？`)) return;

            if (kind === 'deal') {
                const idset = new Set(ids);
                AppState.unifiedData.deals = (AppState.unifiedData.deals||[]).filter(d => !idset.has(d.dealId));
                AppState.unifiedData.links = (AppState.unifiedData.links||[]).filter(l => !idset.has(l.dealId));
            } else {
                const idset = new Set(ids);
                AppState.unifiedData.quotes = (AppState.unifiedData.quotes||[]).filter(q => !idset.has(q.quoteId));
                AppState.unifiedData.links  = (AppState.unifiedData.links||[]).filter(l => !idset.has(l.quoteId));
            }

            if (typeof MatchEngine !== 'undefined') MatchEngine.run();
            if (typeof renderUnifiedBoard === 'function') renderUnifiedBoard();
            DataStorage.saveAppState();
            showToast(`已删除 ${ids.length} 条记录`, 'success');
        }

        function clearUnified(kind) {
            if (!confirm(`确定清空所有${kind==='deal'?'DONE':'报价'}吗？`)) return;
            if (kind === 'deal') {
                AppState.unifiedData.deals = [];
                AppState.unifiedData.links = (AppState.unifiedData.links||[]).filter(l => false);
            } else {
                AppState.unifiedData.quotes = [];
                AppState.unifiedData.links = (AppState.unifiedData.links||[]).filter(l => false);
            }
            AppState.unifiedData.stats = { totalDeals:0, matchedDeals:0, coverage:0, totalQuotes:0, completedQuotes:0, completionRate:0, totalQuoteWan:0, filledQuoteWan:0, remainingQuoteWan:0 };
            if (typeof recomputeUnifiedStats === 'function') recomputeUnifiedStats();
            if (typeof MatchEngine !== 'undefined') MatchEngine.run();
            if (typeof renderUnifiedBoard === 'function') renderUnifiedBoard();
            DataStorage.saveAppState();
            showToast('已清空', 'success');
        }

        // 筛选条渲染与状态
        const UnifiedViewState = {
          manager: '',
          side: '',
          matchedOnly: false,
          quoteDone: false,      // 报价表是否仅看已完成
          dealFilter: null,      // 看板钻取：对 DONE 的临时过滤函数
          quoteFilter: null,     // 看板钻取：对 报价 的临时过滤函数
          activeTab: 'deals'     // 默认先看 DONE
        };
        function renderUnifiedFilters() {
            const deals = (AppState.unifiedData.deals||[]);
            const quotes = (AppState.unifiedData.quotes||[]);
            const managers = Array.from(new Set([
                ...deals.map(d=>d.manager).filter(Boolean),
                ...quotes.map(q=>q.manager).filter(Boolean)
            ])).sort();
            const html = `
                <div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
                  <label>投资经理</label>
                  <select id="fltManager" onchange="applyUnifiedFilters()">
                    <option value="">全部</option>
                    ${managers.map(m=>`<option value="${m}">${m}</option>`).join('')}
                  </select>
                  <label>方向</label>
                  <select id="fltSide" onchange="applyUnifiedFilters()">
                    <option value="">全部</option>
                    <option value="买入">买入</option>
                    <option value="卖出">卖出</option>
                  </select>
                  <label style="display:flex;align-items:center;gap:6px;"><input type="checkbox" id="fltMatchedOnly" onchange="applyUnifiedFilters()"> 仅看已匹配</label>
                  <label style="display:flex;align-items:center;gap:6px;"><input type="checkbox" id="fltQuoteDone" onchange="applyUnifiedFilters()"> 仅看已完成报价</label>
                </div>`;
            const el = document.getElementById('unifiedFilters'); if (el) el.innerHTML = html;

            const s = UnifiedViewState || {};
            const cb1 = document.getElementById('fltMatchedOnly'); if (cb1) cb1.checked = !!s.matchedOnly;
            const cb2 = document.getElementById('fltQuoteDone');   if (cb2) cb2.checked = !!s.quoteDone;
        }

        function applyUnifiedFilters() {
            UnifiedViewState.manager     = (document.getElementById('fltManager')||{}).value || '';
            UnifiedViewState.side        = (document.getElementById('fltSide')||{}).value || '';
            UnifiedViewState.matchedOnly = !!(document.getElementById('fltMatchedOnly')||{}).checked;
            UnifiedViewState.quoteDone   = !!(document.getElementById('fltQuoteDone')||{}).checked;
            renderUnifiedBoard();
        }
        function renderUnifiedBoard() {
            const data = AppState.unifiedData || { stats:{}, deals:[], quotes:[], links:[] };
            // 实时重算统计，避免显示旧的缓存值
            if (typeof recomputeUnifiedStats === 'function') recomputeUnifiedStats();
            const stats = data.stats || {};
            const deals = data.deals || [];
            const quotes = data.quotes || [];
            const links = data.links || [];

            // 渲染筛选条
            renderUnifiedFilters();

            const statHTML = `
                <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:12px;">
                  <div class="stat-card" onclick="openStatsDrilldown('deals_all')">
                    <div class="s-label">DONE总数</div>
                    <div class="s-value">${stats.totalDeals||0}</div>
                  </div>
                  <div class="stat-card" onclick="openStatsDrilldown('deals_matched')">
                    <div class="s-label">已匹配</div>
                    <div class="s-value">${stats.matchedDeals||0}</div>
                  </div>
                  <div class="stat-card disabled">
                    <div class="s-label">覆盖率</div>
                    <div class="s-value">${stats.coverage||0}%</div>
                  </div>
                  <div class="stat-card" onclick="openStatsDrilldown('quotes_completed')">
                    <div class="s-label">报价完成（条）</div>
                    <div class="s-value">${(stats.completedQuotes||0)}/${(stats.totalQuotes||0)}（${stats.completionRate||0}%）</div>
                  </div>
                  <div class="stat-card" onclick="openStatsDrilldown('quotes_filled')">
                    <div class="s-label">报价完成（量）</div>
                    <div class="s-value">${(stats.filledQuoteWan||0)}/${(stats.totalQuoteWan||0)}（${(stats.totalQuoteWan?Math.round(100*stats.filledQuoteWan/stats.totalQuoteWan):0)}%）</div>
                  </div>
                </div>`;
            const toolsHTML = `
              <div style="display:flex; gap:8px; align-items:center; margin:8px 0; flex-wrap:wrap;">
                <button class="btn btn-primary" onclick="window.openAutoMatchPreview()">自动匹配（预览）</button>
                <button class="btn btn-secondary" onclick="window.openManualMatchWizard()">手动匹配</button>
                <button class="btn btn-secondary" onclick="window.undoAutoMatch()">撤销上一步</button>
                <button class="btn btn-success" onclick="window.exportUnifiedReport()">导出匹配</button>
              </div>`;
            const qs = document.getElementById('unifiedStats'); if (qs) qs.innerHTML = statHTML + toolsHTML;

            const qIndex = new Map(quotes.map(q=>[q.quoteId,q]));
            const dIndex = new Map(deals.map(d=>[d.dealId,d]));
            // 依据过滤状态筛选链接
            let filteredLinks = links.slice();
            if (UnifiedViewState.manager) {
                filteredLinks = filteredLinks.filter(l => {
                    const q = qIndex.get(l.quoteId)||{}; const d = dIndex.get(l.dealId)||{};
                    return q.manager === UnifiedViewState.manager || d.manager === UnifiedViewState.manager;
                });
            }
            if (UnifiedViewState.side) {
                filteredLinks = filteredLinks.filter(l => (qIndex.get(l.quoteId)||{}).side === UnifiedViewState.side);
            }
            if (UnifiedViewState.matchedOnly) {
                // 已匹配即有链接，filteredLinks 已满足
            }
            // 移除滑点过滤

            let rows = filteredLinks.map(l=>{
                const d=dIndex.get(l.dealId)||{}; const q=qIndex.get(l.quoteId)||{};
                const reason = (l.reason||[]).join(',');
                return `
                  <tr style="border-bottom:1px solid #eee;">
                    <td>${d.code||''}<br><span style="color:#666">${d.name||''}</span></td>
                    <td>${d.direction||''} → 需${d.expQuoteSide||''}</td>
                    <td>${d.yield!=null? Number(d.yield).toFixed(4)+'%':'-'}/${q.yield!=null? Number(q.yield).toFixed(4)+'%':'-'}</td>
                    <td>${d.volumeWan||'-'} / ${q.volumeWan||'-'}</td>
                    <td>${l.score}</td>
                    <td style="color:#666">${reason}</td>
                  </tr>`;
            }).join('');
            if (!rows) rows = `<tr><td colspan="6" style="text-align:center;color:#888;padding:24px;">暂无匹配结果</td></tr>`;

            const tableHTML = `
              <table style="width:100%;border-collapse:collapse;margin-top:8px;">
                <thead>
                  <tr style="text-align:left;background:#f1f3f5;">
                    <th style="padding:8px;">债券</th><th style="padding:8px;">方向</th>
                    <th style="padding:8px;">收益率(DONE/报价)</th><th style="padding:8px;">量(万)</th>
                    <th style="padding:8px;">分数</th><th style="padding:8px;">依据</th>
                  </tr>
                </thead>
                <tbody>${rows}</tbody>
              </table>`;
            // 合并后移除独立候选与报价进度表渲染

            // 同步渲染预览表
            if (document.getElementById('unifiedDealsPreview')) renderUnifiedDealsPreview();
            if (document.getElementById('unifiedQuotesPreview')) renderUnifiedQuotesPreview();
        }

        // 自动匹配与回撤、报价进度（全局可用）
        // 自动匹配预览与手动匹配向导
        function openAutoMatchPreview(){
            const data = AppState.unifiedData || {};
            const deals  = data.deals  || [];
            const quotes = data.quotes || [];
            const doneText  = (document.getElementById('unifiedDoneInput') && document.getElementById('unifiedDoneInput').value || '').trim();
            const quoteText = (document.getElementById('unifiedQuoteInput') && document.getElementById('unifiedQuoteInput').value || '').trim();
            const prefs = data.prefs || (data.prefs = {});

            if (!deals.length && doneText)  { try { parseUnifiedDone();  } catch(e){} }
            if (!quotes.length && quoteText){ try { parseUnifiedQuote(); } catch(e){} }

            if (prefs.previewBeforeMerge && ((!deals.length && doneText) || (!quotes.length && quoteText))) {
                window.UnifiedIntent = window.UnifiedIntent || { nextAction: null };
                window.UnifiedIntent.nextAction = 'auto';
                showToast('已打开解析确认窗口，请先“确认并导入”，系统将自动回到“自动匹配（预览）”', 'info');
                return;
            }

            try { if (typeof MatchEngine !== 'undefined') MatchEngine.run(); } catch(e){}
            openBatchLinkPickerModal();
            batchPickTop1();
        }

        function openManualMatchWizard() {
            const data = AppState.unifiedData || {};
            const deals  = data.deals  || [];
            const quotes = data.quotes || [];

            const doneText  = (document.getElementById('unifiedDoneInput') && document.getElementById('unifiedDoneInput').value || '').trim();
            const quoteText = (document.getElementById('unifiedQuoteInput') && document.getElementById('unifiedQuoteInput').value || '').trim();
            const prefs = data.prefs || (data.prefs = {});

            if (!deals.length && doneText)  { try { parseUnifiedDone();  } catch(e){} }
            if (!quotes.length && quoteText){ try { parseUnifiedQuote(); } catch(e){} }

            if (prefs.previewBeforeMerge && ((!deals.length && doneText) || (!quotes.length && quoteText))) {
                window.UnifiedIntent = window.UnifiedIntent || { nextAction: null };
                window.UnifiedIntent.nextAction = 'manual';
                showToast('已打开解析确认窗口，请先“确认并导入”，系统将自动回到“手动匹配”', 'info');
                return;
            }

            const dNow = (AppState.unifiedData.deals||[]);
            const qNow = (AppState.unifiedData.quotes||[]);
            if (!qNow.length) {
                if (!dNow.length) { showToast('请先输入 DONE 或 报价文本', 'warning'); return; }
                const firstUnmatched = dNow.find(d => (d.state||'unfilled') === 'unfilled');
                const first = firstUnmatched || dNow[0];
                openLinkPickerModal(first.raw && first.raw.指令ID || first.dealId);
                return;
            }

            try { if (typeof MatchEngine !== 'undefined') MatchEngine.run(); } catch(e){}
            openBatchLinkPickerModal();
            batchPickTop1();
        }
        function autoMatchAndAllocate() {
            try { if (typeof MatchEngine !== 'undefined') MatchEngine.run(); } catch(e){}
            const data = AppState.unifiedData || {};
            const { deals=[], quotes=[], links=[] } = data;
            if (!deals.length || !quotes.length) { showToast('请先解析 DONE 与 报价文本', 'warning'); return; }

            snapshotForUndo();

            deals.forEach(d => { d.fillWan = d.fillWan||0; });
            quotes.forEach(q => { q.filledWan = q.filledWan||0; q.fills = q.fills||[]; });

            const linksByDeal = (links||[]).reduce((m,l)=>{ 
                if (!m[l.dealId]) m[l.dealId] = [];
                m[l.dealId].push(l); 
                return m; 
            }, {});
            Object.values(linksByDeal).forEach(arr => arr.sort((a,b)=>(b.score||0)-(a.score||0)));

            const sortedDeals = [...deals].sort((a,b)=>{ const ax = a.bondKey ? 0 : 1, bx = b.bondKey ? 0 : 1; return ax - bx; });

            for (const d of sortedDeals) {
                const need = (d.volumeWan||0) - (d.fillWan||0);
                if (need <= 0) { d.state = 'filled'; continue; }
                const cands = linksByDeal[d.dealId] || [];
                let left = need;
                for (const l of cands) {
                    const q = quotes.find(x=>x.quoteId===l.quoteId);
                    if (!q) continue;
                    const qRemain = (q.volumeWan||0) - (q.filledWan||0);
                    if (qRemain <= 0) continue;
                    const alloc = Math.min(left, qRemain);
                    if (alloc <= 0) continue;
                    l.confirmed = true;
                    l.auto = true;
                    l.fillWan = (l.fillWan||0) + alloc;
                    d.fillWan = (d.fillWan||0) + alloc;
                    q.filledWan = (q.filledWan||0) + alloc;
                    if (!q.fills) q.fills = [];
                    q.fills.push({ linkId: l.linkId, dealId: d.dealId, fillWan: alloc, at: Date.now() });
                    left -= alloc;
                    if (left <= 0) break;
                }
                d.state = left <= 0 ? 'filled' : (d.fillWan > 0 ? 'partial' : 'unfilled');
            }

            quotes.forEach(q => { q.completed = (q.filledWan||0) >= (q.volumeWan||0) - 1e-6; });

            data.stats.totalDeals = deals.length;
            data.stats.matchedDeals = deals.filter(d => d.state !== 'unfilled').length;
            data.stats.coverage = deals.length ? Math.round(100 * data.stats.matchedDeals / deals.length) : 0;
            data.stats.totalQuotes = quotes.length;
            data.stats.completedQuotes = quotes.filter(q => q.completed).length;
            data.stats.completionRate = quotes.length ? Math.round(100 * data.stats.completedQuotes / quotes.length) : 0;
            data.stats.totalQuoteWan = quotes.reduce((s,q)=> s + (q.volumeWan||0), 0);
            data.stats.filledQuoteWan = quotes.reduce((s,q)=> s + (q.filledWan||0), 0);
            data.stats.remainingQuoteWan = (data.stats.totalQuoteWan||0) - (data.stats.filledQuoteWan||0);

            DataStorage.saveAppState();
            renderUnifiedBoard();
            showToast('自动匹配完成', 'success');
        }
        function snapshotForUndo() {
            const data = AppState.unifiedData || {};
            data._undo = {
                deals: (data.deals||[]).map(d=>({ id: d.dealId, fillWan: d.fillWan||0, state: d.state||'unfilled' })),
                quotes: (data.quotes||[]).map(q=>({ id: q.quoteId, filledWan: q.filledWan||0, completed: !!q.completed, fills: JSON.parse(JSON.stringify(q.fills||[])) })),
                links: (data.links||[]).map(l=>({ id: l.linkId, confirmed: !!l.confirmed, fillWan: l.fillWan||0 }))
            };
        }

        function undoAutoMatch() {
            const data = AppState.unifiedData || {};
            const u = data._undo;
            if (!u) { showToast('无可回撤记录', 'warning'); return; }
            const dMap = new Map((data.deals||[]).map(x=>[x.dealId,x]));
            const qMap = new Map((data.quotes||[]).map(x=>[x.quoteId,x]));
            const lMap = new Map((data.links||[]).map(x=>[x.linkId,x]));
            (u.deals||[]).forEach(s => { const d=dMap.get(s.id); if(d){ d.fillWan=s.fillWan; d.state=s.state; } });
            (u.quotes||[]).forEach(s => { const q=qMap.get(s.id); if(q){ q.filledWan=s.filledWan; q.completed=s.completed; q.fills = s.fills||[]; } });
            (u.links||[]).forEach(s => { const l=lMap.get(s.id); if(l){ l.confirmed=s.confirmed; l.fillWan=s.fillWan; } });
            delete data._undo;
            DataStorage.saveAppState();
            renderUnifiedBoard();
            showToast('已撤销上一步', 'success');
        }


        function clearQuoteAlloc(quoteId) {
            const data = AppState.unifiedData || {};
            const q = (data.quotes||[]).find(x=>x.quoteId===quoteId);
            if (!q) return;
            const links = data.links||[];
            (q.fills||[]).forEach(f=>{
                const l = links.find(x=>x.linkId===f.linkId);
                const d = (data.deals||[]).find(x=>x.dealId===f.dealId);
                if (l) l.fillWan = Math.max(0, (l.fillWan||0) - (f.fillWan||0));
                if (d) d.fillWan = Math.max(0, (d.fillWan||0) - (f.fillWan||0));
            });
            q.fills = [];
            q.filledWan = 0;
            q.completed = false;
            (data.deals||[]).forEach(d=>{
                const remain = (d.volumeWan||0) - (d.fillWan||0);
                d.state = remain<=0 ? 'filled' : (d.fillWan>0 ? 'partial' : 'unfilled');
            });
            DataStorage.saveAppState();
            renderUnifiedBoard();
            showToast('已清除该报价分配', 'success');
        }

        function renderQuoteProgress() {
            const data = AppState.unifiedData || {};
            const { quotes=[], links=[] } = data;
            const linksByQuote = links.filter(l=>l.confirmed).reduce((m,l)=>{ if (!m[l.quoteId]) m[l.quoteId] = []; m[l.quoteId].push(l); return m; }, {});
            let list = quotes.slice();
            if (UnifiedViewState.quoteDone) list = list.filter(q=>q.completed);
            const rows = list.map(q=>{
                const prog = (q.volumeWan>0) ? Math.min(100, Math.round(100*(q.filledWan||0)/q.volumeWan)) : 0;
                const dn = (linksByQuote[q.quoteId]||[]).length;
                const bar = `
      <div style=\"height:10px;background:#eee;border-radius:4px;overflow:hidden;\">\n        <div style=\"height:100%;width:${prog}%;background:#4caf50;\"></div>\n      </div>`;
                return `
      <tr>\n        <td>${q.code||'-'}</td>\n        <td>${q.name||'-'}</td>\n        <td>${q.side||'-'}</td>\n        <td>${q.volumeWan||'-'}</td>\n        <td>${q.filledWan||0}</td>\n        <td>${(q.volumeWan||0)-(q.filledWan||0)}</td>\n        <td style=\"min-width:140px;\">${bar} <div style=\"font-size:12px;color:#666;text-align:right;\">${prog}%</div></td>\n        <td>${dn}</td>\n        <td>${q.manager||'-'}</td>\n        <td style=\"text-align:center;\">\n          <button class=\"btn btn-sm\" onclick=\"openEditFromUnified('quote','${q.quoteId}')\">编辑</button>\n          <button class=\"btn btn-sm\" onclick=\"clearQuoteAlloc('${q.quoteId}')\">重置进度</button>\n        </td>\n      </tr>`;
            }).join('');
            const html = `
    <h4 style=\"margin:12px 0 6px;\">报价成交进度</h4>\n    <table class=\"orders-table\" style=\"width:100%; background:white; border-radius:8px;\">\n      <thead><tr>\n        <th>债券代码</th><th>债券名称</th><th>边</th>\n        <th>报价量(万)</th><th>已成交(万)</th><th>剩余(万)</th>\n        <th>进度</th><th>关联DONE</th><th>投资经理</th><th>操作</th>\n      </tr></thead>\n      <tbody>${rows || ''}</tbody>\n    </table>`;
            const el = document.getElementById('quoteProgressTable'); if (el) el.innerHTML = html;
        }

        function exportUnifiedReport() {
            const { deals=[], quotes=[], links=[] } = AppState.unifiedData || {};
            const qIndex = new Map(quotes.map(q=>[q.quoteId,q]));
            const dIndex = new Map(deals.map(d=>[d.dealId,d]));
            let csv = '债券代码,名称,DONE方向,期望匹配边,DONE收益率,报价收益率,DONE量,报价量,匹配分,依据,投资经理,DONE原文,报价原文\n';
            links.forEach(l=>{
                const d=dIndex.get(l.dealId)||{}; const q=qIndex.get(l.quoteId)||{};
                const row = [
                    d.code||'', d.name||'', d.direction||'', d.expQuoteSide||'',
                    d.yield!=null? Number(d.yield).toFixed(4):'', q.yield!=null? Number(q.yield).toFixed(4):'',
                    d.volumeWan||'', q.volumeWan||'', l.score||'', (l.reason||[]).join('|')||'',
                    q.manager||'',
                    (d.raw&&d.raw.原始文本)||'', (q.raw&&q.raw.原始文本)||q.raw?.原始指令文本||''
                ].map(x=>`"${String(x).replace(/\"/g,'\"\"')}"`).join(',');
                csv += row + '\n';
            });
            downloadFile('\uFEFF'+csv, `统一匹配报告_${new Date().toISOString().slice(0,10)}.csv`, 'text/csv;charset=utf-8;');
        }

        function showImportModal() {
            document.getElementById('importModal').classList.add('active');
        }

        function showAddOrderModal() {
            document.getElementById('addOrderModal').classList.add('active');
        }

        function showSplitModal() {
            document.getElementById('splitModal').classList.add('active');
            loadSplitOrdersList();
        }

        function showBatchProgressModal() {
            document.getElementById('batchProgressModal').classList.add('active');
            loadProgressOrdersList();
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }

        function importOrders() {
            // 检查解析器是否已初始化
            if (!enhancedParser) {
                showToast('解析器尚未初始化，请稍候重试', 'error');
                return;
            }
            
            const manager = document.getElementById('importManager').value.trim();
            const text = document.getElementById('importText').value.trim();
            
            if (!manager) {
                showToast('请输入投资经理名称', 'error');
                return;
            }
            
            if (!text) {
                showToast('请输入指令文本', 'error');
                return;
            }
            
            // 使用增强版解析器
            const parseResult = enhancedParser.parseEnhancedRecords(text, manager);
            const orders = parseResult.records;
            const stats = parseResult.stats;
            
            // 显示解析统计信息
            if (stats.total > 0) {
                const successMsg = `解析完成！共 ${stats.total} 条记录，成功识别 ${stats.done_count} 条，识别率 ${stats.success_rate}%`;
                showToast(successMsg, stats.success_rate > 70 ? 'success' : 'info');
                
                // 如果识别率较低，提示用户可以手动修正
                if (stats.success_rate < 80) {
                    showToast('识别率较低，建议检查并修正解析结果', 'warning');
                }
            }
            
            // 添加投资经理信息和指令ID
            orders.forEach((order, index) => {
                order.投资经理 = manager;
                order.指令ID = `${manager}_${Date.now()}_${index}`;
                order.创建时间 = new Date().toISOString();
                order.子单列表 = [];
                
                // 转换字段格式以适配UI
                order.债券代码 = order.债券代码 || '';
                order.债券名称 = order.债券名称 || '';
                order.交易量 = parseFloat(order.交易量) || 0;
                const yieldValue = parseFloat(order.收益率?.replace('%', ''));
                order.收益率 = isNaN(yieldValue) ? null : yieldValue;
                order.状态 = '待执行';
                order.完成进度 = 0;
            });
            
            // 显示解析结果编辑界面，让用户确认和修正
            if (orders.length > 0) {
                showParseResultsModal(orders, manager, text);
                closeModal('importModal');
            } else {
                showToast('没有识别到有效的交易指令，请检查输入格式', 'error');
            }
        }

        function addOrder() {
            const manager = document.getElementById('addManager').value.trim();
            const code = document.getElementById('addCode').value.trim();
            const name = document.getElementById('addName').value.trim();
            const direction = document.getElementById('addDirection').value;
            const volume = document.getElementById('addVolume').value;
            const yieldRate = document.getElementById('addYield').value;
            
            if (!manager || !code || !name || !volume) {
                showToast('请填写必要信息', 'error');
                return;
            }
            
            const order = {
                投资经理: manager,
                指令ID: `${manager}_${Date.now()}`,
                债券代码: code,
                债券名称: name,
                方向: direction,
                交易量: parseFloat(volume),
                收益率: parseFloat(yieldRate) || null,
                交易日期: new Date().toISOString().split('T')[0],
                状态: '待执行',
                完成进度: 0,
                创建时间: new Date().toISOString(),
                子单列表: []
            };
            
            if (!AppState.enhancedData.managers[manager]) {
                AppState.enhancedData.managers[manager] = [];
            }
            AppState.enhancedData.managers[manager].push(order);
            AppState.enhancedData.orders.push(order);
            // 统一数据旁路写入（单条quote）
            try {
                const q = decorateQuoteRecord({ ...order });
                const exists = (AppState.unifiedData.quotes || []).some(x => x.quoteId === q.quoteId);
                if (!exists) AppState.unifiedData.quotes.push(q);
                if (typeof MatchEngine !== 'undefined') { MatchEngine.run(); }
                if (typeof renderUnifiedBoard === 'function') { renderUnifiedBoard(); }
                DataStorage.saveAppState();
            } catch (e) { console.warn('Unified(single quote) write-through failed:', e); }
            
            updateDashboard();
            renderManagerList();
            closeModal('addOrderModal');
            showToast('指令添加成功', 'success');
            
            // 清空表单
            document.getElementById('addManager').value = '';
            document.getElementById('addCode').value = '';
            document.getElementById('addName').value = '';
            document.getElementById('addVolume').value = '';
            document.getElementById('addYield').value = '';
        }

        function loadOrdersForSplit() {
            const select = document.getElementById('splitOrderSelect');
            select.innerHTML = '';
            
            AppState.enhancedData.orders.forEach(order => {
                const option = document.createElement('option');
                option.value = order.指令ID;
                option.textContent = `${order.债券名称} - ${order.方向} - ${order.交易量}万`;
                select.appendChild(option);
            });
            
            updateSplitPreview();
        }

        function updateSplitPreview() {
            const orderId = document.getElementById('splitOrderSelect').value;
            const strategy = document.getElementById('splitStrategy').value;
            const count = parseInt(document.getElementById('splitCount').value);
            
            const order = AppState.enhancedData.orders.find(o => o.指令ID === orderId);
            if (!order) return;
            
            const preview = document.getElementById('splitPreview');
            let html = '<h4>拆单预览</h4><table style="width:100%; margin-top: 10px;">';
            html += '<tr><th>子单号</th><th>数量(万)</th><th>比例</th></tr>';
            
            const total = order.交易量;
            for (let i = 0; i < count; i++) {
                let amount;
                if (strategy === 'equal') {
                    amount = (total / count).toFixed(2);
                } else {
                    // 简化的不等额分配
                    const ratio = (i + 1) / ((count * (count + 1)) / 2);
                    amount = (total * ratio).toFixed(2);
                }
                
                html += `<tr><td>子单${i+1}</td><td>${amount}</td><td>${(amount/total*100).toFixed(1)}%</td></tr>`;
            }
            
            html += '</table>';
            preview.innerHTML = html;
        }

        function executeSplit() {
            const orderId = document.getElementById('splitOrderSelect').value;
            const strategy = document.getElementById('splitStrategy').value;
            const count = parseInt(document.getElementById('splitCount').value);
            
            const order = AppState.enhancedData.orders.find(o => o.指令ID === orderId);
            if (!order) {
                showToast('请选择要拆分的指令', 'error');
                return;
            }
            
            const total = order.交易量;
            order.子单列表 = [];
            
            // 根据不同策略生成拆单方案
            let amounts = [];
            
            if (strategy === 'equal') {
                // 等额拆分
                const baseAmount = Math.floor(total / count);
                const remainder = total - baseAmount * count;
                for (let i = 0; i < count; i++) {
                    amounts.push(i === 0 ? baseAmount + remainder : baseAmount);
                }
            } else if (strategy === 'twap') {
                // 时间加权平均（TWAP）- 每个时段相同数量
                const amountPerSlice = total / count;
                for (let i = 0; i < count; i++) {
                    amounts.push(amountPerSlice);
                }
            } else if (strategy === 'vwap') {
                // 成交量加权（VWAP）- 模拟日内成交量分布
                const vwapWeights = generateVWAPWeights(count);
                for (let i = 0; i < count; i++) {
                    amounts.push(total * vwapWeights[i]);
                }
            } else if (strategy === 'custom') {
                // 自定义策略 - 递增或递减
                const step = total * 0.1 / count;
                const base = total / count;
                for (let i = 0; i < count; i++) {
                    amounts.push(base + (i - count/2) * step);
                }
            } else {
                // 默认递增策略
                const ratio = (i + 1) / ((count * (count + 1)) / 2);
                for (let i = 0; i < count; i++) {
                    amounts.push(total * ratio);
                }
            }
            
            // 创建子单
            const now = new Date();
            for (let i = 0; i < count; i++) {
                const executeTime = new Date(now.getTime() + i * 30 * 60 * 1000); // 每30分钟一个
                
                order.子单列表.push({
                    子单ID: `${order.指令ID}_${i+1}`,
                    序号: i + 1,
                    计划数量: parseFloat(amounts[i].toFixed(2)),
                    实际成交: 0,
                    目标收益率: order.收益率 ? (order.收益率 + (Math.random() - 0.5) * 0.02).toFixed(4) : null,
                    执行时间: executeTime.toISOString(),
                    状态: '待执行',
                    创建时间: now.toISOString(),
                    策略: strategy
                });
            }
            
            order.状态 = '执行中';
            order.拆单策略 = strategy;
            order.拆单时间 = now.toISOString();
            
            updateDashboard();
            renderOrderDetails();
            closeModal('splitModal');
            showToast(`成功使用${getStrategyName(strategy)}策略拆分为 ${count} 个子单`, 'success');
        }
        
        // VWAP权重生成函数
        function generateVWAPWeights(count) {
            const weights = [];
            const midPoint = Math.floor(count / 2);
            
            // 模拟U型成交量分布
            for (let i = 0; i < count; i++) {
                const distanceFromMid = Math.abs(i - midPoint);
                const weight = 1 + distanceFromMid * 0.5;
                weights.push(weight);
            }
            
            // 归一化权重
            const sum = weights.reduce((a, b) => a + b, 0);
            return weights.map(w => w / sum);
        }
        
        // 获取策略名称
        function getStrategyName(strategy) {
            const names = {
                'equal': '等额拆分',
                'twap': 'TWAP',
                'vwap': 'VWAP',
                'custom': '自定义'
            };
            return names[strategy] || '智能';
        }

        function updateDashboard() {
            const stats = AppState.enhancedData.stats;
            const orders = AppState.enhancedData.orders;
            
            stats.total = orders.length;
            stats.executing = orders.filter(o => o.状态 === '执行中').length;
            stats.completed = orders.filter(o => o.状态 === '已完成').length;
            
            if (stats.total > 0) {
                const totalProgress = orders.reduce((sum, o) => sum + (o.完成进度 || 0), 0);
                stats.progress = Math.round(totalProgress / stats.total);
            } else {
                stats.progress = 0;
            }
            
            document.getElementById('totalOrders').textContent = stats.total;
            document.getElementById('executingOrders').textContent = stats.executing;
            document.getElementById('completedOrders').textContent = stats.completed;
            document.getElementById('totalProgress').textContent = stats.progress;
        }

        function renderManagerList() {
            const list = document.getElementById('managerList');
            list.innerHTML = '';
            
            Object.keys(AppState.enhancedData.managers).forEach(manager => {
                const orders = AppState.enhancedData.managers[manager];
                const li = document.createElement('li');
                li.className = 'manager-item';
                
                li.innerHTML = `
                    <div class="manager-header" onclick="toggleManager('${manager}')">
                        <span>${manager} (${orders.length})</span>
                        <span>▼</span>
                    </div>
                    <ul class="order-list" id="manager_${manager}">
                        ${orders.map(order => `
                            <li class="order-item" style="display: flex; align-items: center; gap: 8px; padding: 5px 0;">
                                <input type="checkbox" class="enhancedOrderCheckbox" data-order-id="${order.指令ID}" 
                                       onchange="updateEnhancedSelectedCount()" style="cursor: pointer;">
                                <span onclick="selectOrder('${order.指令ID}')" style="flex: 1; cursor: pointer;">
                                ${order.债券名称} - ${order.方向} - ${order.交易量}万
                                </span>
                                <button class="btn" style="background: #ff4444; color: white; padding: 2px 6px; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;" 
                                        onclick="event.stopPropagation(); deleteEnhancedOrder('${order.指令ID}')" title="删除指令">×</button>
                            </li>
                        `).join('')}
                    </ul>
                `;
                
                list.appendChild(li);
            });
            
            // 显示批量操作工具栏
            const hasSomeOrders = AppState.enhancedData.orders.length > 0;
            document.getElementById('enhancedBatchTools').style.display = hasSomeOrders ? 'block' : 'none';
            if (hasSomeOrders) {
                updateEnhancedSelectedCount();
            }
            
            // 更新表格视图和筛选选项
            updateFilterOptions();
            if (window.currentViewMode === 'table') {
                renderOrdersTable();
            }
        }

        function toggleManager(manager) {
            const list = document.getElementById(`manager_${manager}`);
            if (list) {
                list.classList.toggle('expanded');
            }
        }

        function selectOrder(orderId) {
            AppState.currentOrder = AppState.enhancedData.orders.find(o => o.指令ID === orderId);
            renderOrderDetails();
        }

        // 删除指定的指令
        function deleteEnhancedOrder(orderId) {
            if (confirm('确定要删除这条指令吗？')) {
                // 从orders数组中删除
                const orderIndex = AppState.enhancedData.orders.findIndex(o => o.指令ID === orderId);
                if (orderIndex !== -1) {
                    const deletedOrder = AppState.enhancedData.orders[orderIndex];
                    AppState.enhancedData.orders.splice(orderIndex, 1);
                    
                    // 从managers中删除
                    const manager = deletedOrder.投资经理;
                    if (AppState.enhancedData.managers[manager]) {
                        const managerOrderIndex = AppState.enhancedData.managers[manager].findIndex(o => o.指令ID === orderId);
                        if (managerOrderIndex !== -1) {
                            AppState.enhancedData.managers[manager].splice(managerOrderIndex, 1);
                            // 如果该投资经理没有指令了，删除整个经理条目
                            if (AppState.enhancedData.managers[manager].length === 0) {
                                delete AppState.enhancedData.managers[manager];
                            }
                        }
                    }
                    
                    // 如果删除的是当前选中的指令，清空详情显示
                    if (AppState.currentOrder && AppState.currentOrder.指令ID === orderId) {
                        AppState.currentOrder = null;
                    }
                    
                    // 更新界面
                    updateDashboard();
                    renderManagerList();
                    if (window.currentViewMode === 'detail') {
                        renderOrderDetails();
                    }
                    showToast('指令删除成功', 'success');
                }
            }
        }

        // 删除当前选中的指令
        function deleteCurrentOrder() {
            if (AppState.currentOrder) {
                deleteEnhancedOrder(AppState.currentOrder.指令ID);
            }
        }
        // 更新扩展版选中项数量
        function updateEnhancedSelectedCount() {
            const checkboxes = document.querySelectorAll('.enhancedOrderCheckbox');
            const checked = document.querySelectorAll('.enhancedOrderCheckbox:checked');
            const countElement = document.getElementById('enhancedSelectedCount');
            if (countElement) {
                countElement.textContent = `已选择: ${checked.length} 项`;
            }
        }

        // 全选扩展版指令
        function selectAllEnhancedOrders() {
            const checkboxes = document.querySelectorAll('.enhancedOrderCheckbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
            });
            updateEnhancedSelectedCount();
        }

        // 取消全选扩展版指令
        function deselectAllEnhancedOrders() {
            const checkboxes = document.querySelectorAll('.enhancedOrderCheckbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            updateEnhancedSelectedCount();
        }

        // 批量删除扩展版指令
        function batchDeleteEnhancedOrders() {
            const checkedCheckboxes = document.querySelectorAll('.enhancedOrderCheckbox:checked');
            if (checkedCheckboxes.length === 0) {
                showToast('请先选择要删除的指令', 'error');
                return;
            }
            
            if (confirm(`确定要删除选中的 ${checkedCheckboxes.length} 条指令吗？`)) {
                // 获取要删除的指令ID
                const orderIdsToDelete = Array.from(checkedCheckboxes)
                    .map(checkbox => checkbox.dataset.orderId);
                
                // 批量删除指令
                orderIdsToDelete.forEach(orderId => {
                    // 从orders数组中删除
                    const orderIndex = AppState.enhancedData.orders.findIndex(o => o.指令ID === orderId);
                    if (orderIndex !== -1) {
                        const deletedOrder = AppState.enhancedData.orders[orderIndex];
                        AppState.enhancedData.orders.splice(orderIndex, 1);
                        
                        // 从managers中删除
                        const manager = deletedOrder.投资经理;
                        if (AppState.enhancedData.managers[manager]) {
                            const managerOrderIndex = AppState.enhancedData.managers[manager].findIndex(o => o.指令ID === orderId);
                            if (managerOrderIndex !== -1) {
                                AppState.enhancedData.managers[manager].splice(managerOrderIndex, 1);
                                // 如果该投资经理没有指令了，删除整个经理条目
                                if (AppState.enhancedData.managers[manager].length === 0) {
                                    delete AppState.enhancedData.managers[manager];
                                }
                            }
                        }
                        
                        // 如果删除的是当前选中的指令，清空详情显示
                        if (AppState.currentOrder && AppState.currentOrder.指令ID === orderId) {
                            AppState.currentOrder = null;
                        }
                    }
                });
                
                // 更新界面
                updateDashboard();
                renderManagerList();
                if (window.currentViewMode === 'detail') {
                    renderOrderDetails();
                }
                showToast(`成功删除 ${orderIdsToDelete.length} 条指令`, 'success');
            }
        }

        // 全局变量存储当前视图模式和排序状态
        window.currentViewMode = 'table'; // 'table' 或 'detail'
        window.currentSort = { field: null, order: 'asc' };
        window.filteredOrders = [];

        // 渲染表格视图
        function renderOrdersTable() {
            const tbody = document.getElementById('ordersTableBody');
            const orders = window.filteredOrders.length > 0 ? window.filteredOrders : AppState.enhancedData.orders;
            
            if (!tbody) return;
            
            if (orders.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; padding: 40px; color: #999;">暂无交易指令数据</td></tr>';
                return;
            }
            
            let html = '';
            orders.forEach(order => {
                const directionClass = order.方向 === '买入' ? '#e8f5e9' : '#ffebee';
                const directionText = order.方向 === '买入' ? 'BID' : 'OFR';
                const progress = order.完成进度 || 0;
                
                // 状态颜色
                const statusColors = {
                    '待执行': '#ffc107',
                    '执行中': '#17a2b8', 
                    '已完成': '#28a745'
                };
                const statusColor = statusColors[order.状态] || '#6c757d';
                
                html += `
                    <tr style="border-bottom: 1px solid #dee2e6;" onmouseover="this.style.backgroundColor='#f8f9fa'" onmouseout="this.style.backgroundColor='white'">
                        <td style="padding: 12px;">
                            <div style="font-weight: bold; color: #212529;">${order.债券名称}</div>
                            <div style="font-size: 12px; color: #6c757d;">${order.债券代码}</div>
                        </td>
                        <td style="padding: 12px;">
                            <div style="font-weight: 500;">${order.投资经理}</div>
                        </td>
                        <td style="padding: 12px; text-align: center;">
                            <span style="background: ${directionClass}; color: ${order.方向 === '买入' ? '#2e7d32' : '#c62828'}; 
                                         padding: 4px 8px; border-radius: 12px; font-size: 12px; font-weight: bold;">
                                ${directionText}
                            </span>
                        </td>
                        <td style="padding: 12px; text-align: right; font-weight: bold;">
                            ${order.交易量 || '-'}
                        </td>
                        <td style="padding: 12px; text-align: right; font-weight: bold;">
                            ${order.收益率 ? (typeof order.收益率 === 'number' ? order.收益率.toFixed(4) + '%' : order.收益率) : '-'}
                        </td>
                        <td style="padding: 12px; text-align: center;">
                            <span style="background: ${statusColor}; color: white; padding: 4px 8px; border-radius: 12px; font-size: 12px; font-weight: bold;">
                                ${order.状态}
                            </span>
                        </td>
                        <td style="padding: 12px; text-align: center;">
                            <div style="display: flex; align-items: center; justify-content: center;">
                                <div style="width: 60px; height: 6px; background: #e9ecef; border-radius: 3px; margin-right: 8px;">
                                    <div style="width: ${progress}%; height: 100%; background: #28a745; border-radius: 3px;"></div>
                                </div>
                                <span style="font-size: 12px; font-weight: bold;">${progress}%</span>
                            </div>
                        </td>
                        <td style="padding: 12px; text-align: center;">
                            <div style="display: flex; gap: 4px; justify-content: center;">
                                <button class="btn btn-sm" style="padding: 4px 8px; font-size: 11px; background: #007bff; color: white;" 
                                        onclick="viewOrderDetail('${order.指令ID}')" title="查看详情">详情</button>
                                <button class="btn btn-sm" style="padding: 4px 8px; font-size: 11px; background: #28a745; color: white;" 
                                        onclick="editExistingOrder('${order.指令ID}')" title="编辑指令">编辑</button>
                                <button class="btn btn-sm" style="padding: 4px 8px; font-size: 11px; background: #6c757d; color: white;" 
                                        onclick="updateOrderProgress('${order.指令ID}')" title="更新进度">进度</button>
                                <button class="btn btn-sm" style="padding: 4px 8px; font-size: 11px; background: #dc3545; color: white;" 
                                        onclick="deleteEnhancedOrder('${order.指令ID}')" title="删除">删除</button>
                            </div>
                        </td>
                    </tr>
                `;
            });
            
            // 计算交易量合计
            let totalVolume = 0;
            let buyVolume = 0;
            let sellVolume = 0;
            
            orders.forEach(order => {
                const volume = parseFloat(order.交易量) || 0;
                totalVolume += volume;
                
                if (order.方向 === '买入') {
                    buyVolume += volume;
                } else if (order.方向 === '卖出') {
                    sellVolume += volume;
                }
            });
            
            // 添加合计行
            html += `
                <tr style="background: #f0f8ff; font-weight: bold; border-top: 2px solid #1976d2;">
                    <td colspan="3" style="padding: 12px; text-align: right; font-size: 14px;">合计:</td>
                    <td style="padding: 12px; text-align: right; font-size: 14px; color: #1976d2;">${totalVolume.toFixed(2)}</td>
                    <td colspan="4" style="padding: 12px; text-align: left; font-size: 12px; color: #666;">
                        买入: ${buyVolume.toFixed(2)}万 | 卖出: ${sellVolume.toFixed(2)}万 | 总计: ${totalVolume.toFixed(2)}万
                    </td>
                </tr>
            `;
            
            tbody.innerHTML = html;
        }

        // 更新筛选选项
        function updateFilterOptions() {
            const managerFilter = document.getElementById('managerFilter');
            if (managerFilter) {
                const managers = [...new Set(AppState.enhancedData.orders.map(order => order.投资经理))];
                managerFilter.innerHTML = '<option value="">全部</option>' + 
                    managers.map(manager => `<option value="${manager}">${manager}</option>`).join('');
            }
        }

        // 应用筛选
        function applyFilters() {
            const managerFilter = document.getElementById('managerFilter')?.value;
            const directionFilter = document.getElementById('directionFilter')?.value;
            const statusFilter = document.getElementById('statusFilter')?.value;
            const searchInput = document.getElementById('searchInput')?.value.toLowerCase();
            
            window.filteredOrders = AppState.enhancedData.orders.filter(order => {
                const matchesManager = !managerFilter || order.投资经理 === managerFilter;
                const matchesDirection = !directionFilter || order.方向 === directionFilter;
                const matchesStatus = !statusFilter || order.状态 === statusFilter;
                const matchesSearch = !searchInput || 
                    order.债券名称?.toLowerCase().includes(searchInput) ||
                    order.债券代码?.toLowerCase().includes(searchInput);
                
                return matchesManager && matchesDirection && matchesStatus && matchesSearch;
            });
            
            if (window.currentViewMode === 'table') {
                renderOrdersTable();
            }
        }

        // 表格排序
        function sortTable(field) {
            if (window.currentSort.field === field) {
                window.currentSort.order = window.currentSort.order === 'asc' ? 'desc' : 'asc';
            } else {
                window.currentSort.field = field;
                window.currentSort.order = 'asc';
            }
            
            const orders = window.filteredOrders.length > 0 ? window.filteredOrders : AppState.enhancedData.orders;
            
            orders.sort((a, b) => {
                let aVal = a[field];
                let bVal = b[field];
                
                // 处理数字类型
                if (field === '交易量' || field === '收益率' || field === '完成进度') {
                    aVal = parseFloat(aVal) || 0;
                    bVal = parseFloat(bVal) || 0;
                }
                
                if (aVal < bVal) return window.currentSort.order === 'asc' ? -1 : 1;
                if (aVal > bVal) return window.currentSort.order === 'asc' ? 1 : -1;
                return 0;
            });
            
            renderOrdersTable();
        }

        // 视图切换
        function switchToTableView() {
            window.currentViewMode = 'table';
            document.getElementById('ordersTableView').style.display = 'block';
            document.getElementById('orderDetailView').style.display = 'none';
            document.getElementById('tableViewBtn').style.background = '#3498db';
            document.getElementById('detailViewBtn').style.background = '#95a5a6';
            renderOrdersTable();
        }

        function switchToDetailView() {
            window.currentViewMode = 'detail';
            document.getElementById('ordersTableView').style.display = 'none';
            document.getElementById('orderDetailView').style.display = 'block';
            document.getElementById('tableViewBtn').style.background = '#95a5a6';
            document.getElementById('detailViewBtn').style.background = '#3498db';
            renderOrderDetails();
        }

        // 查看指令详情
        function viewOrderDetail(orderId) {
            AppState.currentOrder = AppState.enhancedData.orders.find(o => o.指令ID === orderId);
            switchToDetailView();
        }

        // 更新指令进度
        function updateOrderProgress(orderId) {
            const order = AppState.enhancedData.orders.find(o => o.指令ID === orderId);
            if (!order) return;
            
            const newProgress = prompt(`请输入新的完成进度 (0-100)：`, order.完成进度 || 0);
            if (newProgress === null) return;
            
            const progress = parseFloat(newProgress);
            if (isNaN(progress) || progress < 0 || progress > 100) {
                showToast('请输入有效的进度值 (0-100)', 'error');
                return;
            }
            
            order.完成进度 = progress;
            
            // 根据进度自动更新状态
            if (progress === 0) {
                order.状态 = '待执行';
            } else if (progress === 100) {
                order.状态 = '已完成';
            } else {
                order.状态 = '执行中';
            }
            
            // 更新界面
            updateDashboard();
            renderManagerList();
            if (window.currentViewMode === 'table') {
                renderOrdersTable();
            }
            
            showToast('进度更新成功', 'success');
        }



        // ===== 智能拆单功能占位 =====
        
        // 智能拆单功能已移除的占位函数
        function showSplitModal() {
            showToast('智能拆单功能已移除', 'info');
        }

        // ===== 批量进度更新功能 =====
        
        // 加载批量进度更新指令列表
        function loadProgressOrdersList() {
            const container = document.getElementById('progressOrdersList');
            const orders = AppState.enhancedData.orders;
            
            if (orders.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #999; padding: 20px;">暂无指令</div>';
                return;
            }
            
            let html = '';
            orders.forEach(order => {
                const directionText = order.方向 === '买入' ? 'BID' : 'OFR';
                const directionColor = order.方向 === '买入' ? '#28a745' : '#dc3545';
                const progress = order.完成进度 || 0;
                
                html += `
                    <div class="order-select-item">
                        <label style="display: flex; align-items: center; gap: 10px; font-weight: normal; cursor: pointer; width: 100%;">
                            <input type="checkbox" class="progressOrderCheckbox" value="${order.指令ID}" onchange="updateProgressPreview()">
                            <div style="flex: 1;">
                                <div style="font-weight: bold; font-size: 14px;">${order.债券名称}</div>
                                <div style="font-size: 12px; color: #666; margin-top: 2px;">
                                    ${order.投资经理} • 
                                    <span style="color: ${directionColor}; font-weight: bold;">${directionText}</span> • 
                                    ${order.交易量}万 • 当前进度: <span style="font-weight: bold; color: #007bff;">${progress}%</span>
                                </div>
                            </div>
                        </label>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        // 全选/取消全选进度更新指令
        function toggleAllProgressOrders(selectAllCheckbox) {
            const checkboxes = document.querySelectorAll('.progressOrderCheckbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = selectAllCheckbox.checked;
            });
            updateProgressPreview();
        }
        
        // 切换进度更新模式
        function switchProgressMode() {
            const mode = document.querySelector('input[name="progressMode"]:checked').value;
            const uniformArea = document.getElementById('uniformProgressArea');
            const incrementArea = document.getElementById('incrementProgressArea');
            
            if (mode === 'uniform') {
                uniformArea.style.display = 'block';
                incrementArea.style.display = 'none';
            } else if (mode === 'increment') {
                uniformArea.style.display = 'none';
                incrementArea.style.display = 'block';
            }
            
            updateProgressPreview();
        }
        
        // 更新进度预览
        function updateProgressPreview() {
            const checkedBoxes = document.querySelectorAll('.progressOrderCheckbox:checked');
            const selectedOrderIds = Array.from(checkedBoxes).map(cb => cb.value);
            const preview = document.getElementById('progressPreview');
            
            if (selectedOrderIds.length === 0) {
                preview.innerHTML = '<div style="text-align: center; color: #999; padding: 20px;">请选择要更新的指令</div>';
                return;
            }
            
            const mode = document.querySelector('input[name="progressMode"]:checked').value;
            let updateDetails = [];
            
            selectedOrderIds.forEach(orderId => {
                const order = AppState.enhancedData.orders.find(o => o.指令ID === orderId);
                if (order) {
                    const currentProgress = order.完成进度 || 0;
                    let newProgress = currentProgress;
                    
                    if (mode === 'uniform') {
                        const uniformValue = parseFloat(document.getElementById('uniformProgress').value) || 0;
                        newProgress = Math.max(0, Math.min(100, uniformValue));
                    } else if (mode === 'increment') {
                        const incrementValue = parseFloat(document.getElementById('incrementProgress').value) || 0;
                        newProgress = Math.max(0, Math.min(100, currentProgress + incrementValue));
                    }
                    
                    updateDetails.push({
                        order: order,
                        currentProgress: currentProgress,
                        newProgress: newProgress
                    });
                }
            });
            
            let html = `<h4>进度更新预览 - 将更新 ${updateDetails.length} 个指令的进度</h4>`;
            html += '<div style="max-height: 180px; overflow-y: auto;">';
            html += '<table style="width: 100%; border-collapse: collapse;">';
            html += '<tr style="background: #f8f9fa; font-weight: bold;"><th style="padding: 8px; border: 1px solid #ddd;">指令</th><th style="padding: 8px; border: 1px solid #ddd;">当前进度</th><th style="padding: 8px; border: 1px solid #ddd;">新进度</th><th style="padding: 8px; border: 1px solid #ddd;">变化</th></tr>';
            
            updateDetails.forEach(detail => {
                const change = detail.newProgress - detail.currentProgress;
                const changeText = change > 0 ? `+${change.toFixed(1)}%` : change < 0 ? `${change.toFixed(1)}%` : '无变化';
                const changeColor = change > 0 ? '#28a745' : change < 0 ? '#dc3545' : '#6c757d';
                
                html += `
                    <tr>
                        <td style="padding: 8px; border: 1px solid #ddd;">${detail.order.债券名称}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${detail.currentProgress}%</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center; font-weight: bold;">${detail.newProgress}%</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center; color: ${changeColor}; font-weight: bold;">${changeText}</td>
                    </tr>
                `;
            });
            
            html += '</table></div>';
            preview.innerHTML = html;
        }
        
        // 执行批量进度更新
        function executeBatchProgress() {
            const checkedBoxes = document.querySelectorAll('.progressOrderCheckbox:checked');
            const selectedOrderIds = Array.from(checkedBoxes).map(cb => cb.value);
            
            if (selectedOrderIds.length === 0) {
                showToast('请选择要更新进度的指令', 'error');
                return;
            }
            
            const mode = document.querySelector('input[name="progressMode"]:checked').value;
            
            if (confirm(`确定要更新选中的 ${selectedOrderIds.length} 个指令的进度吗？`)) {
                let successCount = 0;
                
                selectedOrderIds.forEach(orderId => {
                    const order = AppState.enhancedData.orders.find(o => o.指令ID === orderId);
                    if (order) {
                        const currentProgress = order.完成进度 || 0;
                        let newProgress = currentProgress;
                        
                        if (mode === 'uniform') {
                            const uniformValue = parseFloat(document.getElementById('uniformProgress').value) || 0;
                            newProgress = Math.max(0, Math.min(100, uniformValue));
                        } else if (mode === 'increment') {
                            const incrementValue = parseFloat(document.getElementById('incrementProgress').value) || 0;
                            newProgress = Math.max(0, Math.min(100, currentProgress + incrementValue));
                        }
                        
                        order.完成进度 = newProgress;
                        
                        // 根据进度自动更新状态
                        if (newProgress === 0) {
                            order.状态 = '待执行';
                        } else if (newProgress === 100) {
                            order.状态 = '已完成';
                        } else {
                            order.状态 = '执行中';
                        }
                        
                        successCount++;
                    }
                });
                
                updateDashboard();
                renderManagerList();
                closeModal('batchProgressModal');
                showToast(`成功更新 ${successCount} 个指令的进度`, 'success');
            }
        }
        function renderOrderDetails() {
            const container = document.getElementById('orderDetails');
            const order = AppState.currentOrder;
            
            if (!order) {
                container.innerHTML = '<div style="text-align: center; color: #999; padding: 50px;">请选择一个指令查看详情</div>';
                return;
            }
            
            const progress = order.完成进度 || 0;
            const directionClass = order.方向 === '买入' ? 'buy' : 'sell';
            const directionText = order.方向 === '买入' ? 'BID' : 'OFR';
            
            let html = `
                <div class="order-detail">
                    <div class="order-header">
                        <div class="order-info">
                            <span class="bond-code">${order.债券代码}</span>
                            <span class="bond-name">${order.债券名称}</span>
                            <span class="direction ${directionClass}">${directionText}</span>
                        </div>
                        <div>
                            <button class="btn btn-success" onclick="editExistingOrder('${order.指令ID}')">编辑指令</button>
                            <button class="btn btn-primary" onclick="updateOrderProgress()">更新进度</button>
                            <button class="btn btn-secondary" onclick="showSplitModal()">拆单</button>
                            <button class="btn" style="background: #ff4444; color: white;" onclick="deleteCurrentOrder()">删除指令</button>
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin: 20px 0;">
                        <div>
                            <label style="color: #999;">投资经理</label>
                            <div style="font-size: 18px; font-weight: bold;">${order.投资经理}</div>
                        </div>
                        <div>
                            <label style="color: #999;">交易量</label>
                            <div style="font-size: 18px; font-weight: bold;">${order.交易量}万元</div>
                        </div>
                        <div>
                            <label style="color: #999;">目标收益率</label>
                            <div style="font-size: 18px; font-weight: bold;">${order.收益率 ? (typeof order.收益率 === 'number' ? order.收益率.toFixed(4) + '%' : order.收益率) : '-'}</div>
                        </div>
                        <div>
                            <label style="color: #999;">收益率类型</label>
                            <div style="font-size: 14px; font-weight: bold;">${order.收益率类型 || '-'}</div>
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin: 20px 0; padding: 15px; background: #f9f9f9; border-radius: 8px;">
                        <div>
                            <label style="color: #666; font-size: 12px;">中介</label>
                            <div style="font-size: 14px;">${order.中介 || '-'}</div>
                        </div>
                        <div>
                            <label style="color: #666; font-size: 12px;">做市商</label>
                            <div style="font-size: 14px;">${order.做市商机构名称 || '-'}</div>
                        </div>
                        <div>
                            <label style="color: #666; font-size: 12px;">终端机构</label>
                            <div style="font-size: 14px;">${order.终端机构名称 || '-'}</div>
                        </div>
                        <div>
                            <label style="color: #666; font-size: 12px;">户名</label>
                            <div style="font-size: 14px;">${order.户名 || '-'}</div>
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin: 20px 0; padding: 15px; background: #f0f7ff; border-radius: 8px;">
                        <div>
                            <label style="color: #666; font-size: 12px;">交易日期</label>
                            <div style="font-size: 14px;">${order.交易日期 || '-'}</div>
                        </div>
                        <div>
                            <label style="color: #666; font-size: 12px;">清算速度</label>
                            <div style="font-size: 14px;">${order.清算速度 || '-'}</div>
                        </div>
                        <div>
                            <label style="color: #666; font-size: 12px;">交易场所</label>
                            <div style="font-size: 14px;">${order.交易场所 || '-'}</div>
                        </div>
                        <div>
                            <label style="color: #666; font-size: 12px;">发单方式</label>
                            <div style="font-size: 14px;">${order.发单方式 || '-'}</div>
                        </div>
                    </div>
                    
                    ${order.净价 || order.全价 || order.对手交易员 ? `
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin: 20px 0; padding: 15px; background: #fff8e1; border-radius: 8px;">
                        <div>
                            <label style="color: #666; font-size: 12px;">净价</label>
                            <div style="font-size: 14px;">${order.净价 || '-'}</div>
                        </div>
                        <div>
                            <label style="color: #666; font-size: 12px;">全价</label>
                            <div style="font-size: 14px;">${order.全价 || '-'}</div>
                        </div>
                        <div>
                            <label style="color: #666; font-size: 12px;">对手交易员</label>
                            <div style="font-size: 14px;">${order.对手交易员 || '-'}</div>
                        </div>
                    </div>
                    ` : ''}
                    
                    ${(order.原始文本 || order.原始指令文本) ? `
                    <div style="margin: 20px 0; padding: 15px; background: #f8f9fa; border: 1px solid #e0e0e0; border-radius: 8px;">
                        <label style="color: #666; font-size: 12px; font-weight: bold;">原始指令文本</label>
                        <div style="font-size: 13px; margin-top: 8px; padding: 10px; background: #fff; border-radius: 4px; border-left: 4px solid #007bff; font-family: monospace; color: #333;">${order.原始文本 || order.原始指令文本}</div>
                    </div>
                    ` : ''}
                    
                    ${order.备注 ? `
                    <div style="margin: 20px 0; padding: 15px; background: #fff; border: 1px solid #e0e0e0; border-radius: 8px;">
                        <label style="color: #666; font-size: 12px;">备注信息</label>
                        <div style="font-size: 14px; margin-top: 5px;">${order.备注}</div>
                    </div>
                    ` : ''}
                    
                    <div class="progress-container">
                        <label style="color: #999;">执行进度</label>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${progress}%">
                                ${progress}%
                            </div>
                        </div>
                    </div>
            `;
            
            // 如果有子单，显示子单表格
            if (order.子单列表 && order.子单列表.length > 0) {
                html += `
                    <div class="split-table">
                        <h4 style="margin: 20px 0 10px 0;">拆单明细</h4>
                        <table>
                            <thead>
                                <tr>
                                    <th>子单号</th>
                                    <th>计划数量</th>
                                    <th>实际成交</th>
                                    <th>状态</th>
                                    <th>操作</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                order.子单列表.forEach(subOrder => {
                    const statusClass = subOrder.状态 === '已完成' ? 'completed' : 
                                       subOrder.状态 === '执行中' ? 'executing' : 'pending';
                    html += `
                        <tr>
                            <td>子单${subOrder.序号}</td>
                            <td>${subOrder.计划数量}万</td>
                            <td>${subOrder.实际成交 || 0}万</td>
                            <td><span class="status-badge ${statusClass}">${subOrder.状态}</span></td>
                            <td>
                                <button class="btn btn-sm" onclick="updateSubOrder('${subOrder.子单ID}')">更新</button>
                            </td>
                        </tr>
                    `;
                });
                
                html += '</tbody></table></div>';
            }
            
            html += '</div>';
            container.innerHTML = html;
        }

        function updateOrderProgress() {
            if (!AppState.currentOrder) return;
            
            const newProgress = prompt('请输入新的进度百分比 (0-100):', AppState.currentOrder.完成进度 || 0);
            if (newProgress !== null) {
                const progress = Math.min(100, Math.max(0, parseFloat(newProgress)));
                AppState.currentOrder.完成进度 = progress;
                
                if (progress >= 100) {
                    AppState.currentOrder.状态 = '已完成';
                } else if (progress > 0) {
                    AppState.currentOrder.状态 = '执行中';
                }
                
                updateDashboard();
                renderManagerList();
                if (window.currentViewMode === 'detail') {
                renderOrderDetails();
                }
                showToast('进度更新成功', 'success');
            }
        }

        function updateSubOrder(subOrderId) {
            if (!AppState.currentOrder) return;
            
            const subOrder = AppState.currentOrder.子单列表.find(s => s.子单ID === subOrderId);
            if (!subOrder) return;
            
            const amount = prompt('请输入实际成交量（万元）:', subOrder.实际成交 || 0);
            if (amount !== null) {
                subOrder.实际成交 = parseFloat(amount);
                if (subOrder.实际成交 >= subOrder.计划数量) {
                    subOrder.状态 = '已完成';
                } else if (subOrder.实际成交 > 0) {
                    subOrder.状态 = '执行中';
                }
                
                // 更新主订单进度
                const totalPlan = AppState.currentOrder.子单列表.reduce((sum, s) => sum + s.计划数量, 0);
                const totalDone = AppState.currentOrder.子单列表.reduce((sum, s) => sum + (s.实际成交 || 0), 0);
                AppState.currentOrder.完成进度 = Math.round(totalDone / totalPlan * 100);
                
                updateDashboard();
                renderManagerList();
                if (window.currentViewMode === 'detail') {
                renderOrderDetails();
                }
                showToast('子单更新成功', 'success');
            }
        }

        function exportReport() {
            const orders = AppState.enhancedData.orders;
            if (orders.length === 0) {
                showToast('没有数据可导出', 'error');
                return;
            }
            
            // 提供多种导出格式选项
            const format = prompt('选择导出格式：\n1. CSV（Excel兼容）\n2. JSON（完整数据）\n3. HTML报告\n请输入数字（默认1）：', '1');
            
            if (format === '2') {
                // JSON格式导出
                const jsonData = {
                    exportTime: new Date().toISOString(),
                    summary: AppState.enhancedData.stats,
                    managers: AppState.enhancedData.managers,
                    orders: orders
                };
                const json = JSON.stringify(jsonData, null, 2);
                downloadFile(json, `交易指令数据_${new Date().toISOString().slice(0,10)}.json`, 'application/json');
                showToast('JSON数据导出成功', 'success');
            } else if (format === '3') {
                // HTML报告格式
                const html = generateHTMLReport(orders);
                downloadFile(html, `交易指令报告_${new Date().toISOString().slice(0,10)}.html`, 'text/html');
                showToast('HTML报告导出成功', 'success');
            } else {
                // 默认CSV格式（增强版）
                let csv = '\ufeff'; // BOM for Excel UTF-8
                csv += '投资经理,指令ID,债券代码,债券名称,方向,中介,原中介编号,做市商机构,终端机构,户名,交易量(万),收益率(%),收益率类型,净价,全价,交易日期,清算速度,交易场所,发单方式,对手交易员,备注,状态,完成进度(%),拆单策略,创建时间\n';
                
                orders.forEach((order, index) => {
                    const rowNum = index + 2; // CSV中数据从第2行开始（第1行是标题）
                    
                    // 债券代码：如果缺失则使用Wind公式 (债券代码在C列，债券名称在D列)
                    const bondCode = order.债券代码 || `=to_windcode(D${rowNum})`;
                    
                    // 债券名称：如果缺失则使用Wind公式
                    const bondName = order.债券名称 || `=b_info_name(C${rowNum})`;
                    
                    csv += `${order.投资经理},${order.指令ID},${bondCode},${bondName},`;
                    csv += `${order.方向},${order.中介 || ''},${order.原中介编号 || ''},${order.做市商机构名称 || ''},${order.终端机构名称 || ''},${order.户名 || ''},`;
                    const yieldDisplay = order.收益率 ? (typeof order.收益率 === 'number' ? order.收益率.toFixed(4) + '%' : order.收益率) : '';
                    csv += `${order.交易量},${yieldDisplay},${order.收益率类型 || ''},`;
                    csv += `${order.净价 || ''},${order.全价 || ''},${order.交易日期 || ''},${order.清算速度 || ''},${order.交易场所 || ''},`;
                    csv += `${order.发单方式 || ''},${order.对手交易员 || ''},"${order.备注 || ''}",${order.状态},`;
                    csv += `${order.完成进度},${order.拆单策略 || '未拆单'},${order.创建时间}\n`;
                    
                    // 添加子单信息
                    if (order.子单列表 && order.子单列表.length > 0) {
                        csv += '\n,子单序号,,,,,,,,,计划数量(万),实际成交(万),目标收益率(%),,,,,,,,,状态,执行时间,策略\n';
                        order.子单列表.forEach(subOrder => {
                            csv += `,子单${subOrder.序号},,,,,,,,,,${subOrder.计划数量},${subOrder.实际成交 || 0},`;
                            csv += `${subOrder.目标收益率 || ''},,,,,,,,,,${subOrder.状态},${subOrder.执行时间},${subOrder.策略 || ''}\n`;
                        });
                        csv += '\n';
                    }
                });
                
                downloadFile(csv, `交易指令报告_${new Date().toISOString().slice(0,10)}.csv`, 'text/csv;charset=utf-8');
                showToast('CSV报告导出成功（含Wind函数自动填充）', 'success');
            }
        }
        
        // 生成HTML报告
        function generateHTMLReport(orders) {
            const stats = AppState.enhancedData.stats;
            let html = `<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>交易指令报告 - ${new Date().toLocaleDateString()}</title>
    <style>
        body { font-family: 'Microsoft YaHei', sans-serif; padding: 20px; background: #f5f5f5; }
        .header { background: #1976d2; color: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
        .summary { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin-bottom: 30px; }
        .stat-card { background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .stat-value { font-size: 24px; font-weight: bold; color: #1976d2; }
        .orders { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { padding: 10px; text-align: left; border-bottom: 1px solid #e0e0e0; }
        th { background: #f5f5f5; font-weight: 600; }
        .direction-buy { color: #4caf50; }
        .direction-sell { color: #f44336; }
        .status-completed { color: #4caf50; }
        .status-executing { color: #ff9800; }
        .status-pending { color: #2196f3; }
    </style>
</head>
<body>
    <div class="header">
        <h1>交易指令执行报告</h1>
        <p>生成时间：${new Date().toLocaleString()}</p>
    </div>
    
    <div class="summary">
        <div class="stat-card">
            <div>总指令数</div>
            <div class="stat-value">${stats.total}</div>
        </div>
        <div class="stat-card">
            <div>执行中</div>
            <div class="stat-value">${stats.executing}</div>
        </div>
        <div class="stat-card">
            <div>已完成</div>
            <div class="stat-value">${stats.completed}</div>
        </div>
        <div class="stat-card">
            <div>总进度</div>
            <div class="stat-value">${stats.progress}%</div>
        </div>
    </div>
    
    <div class="orders">
        <h2>指令明细</h2>
                        <table>
                    <thead>
                        <tr>
                            <th>投资经理</th>
                            <th>债券代码</th>
                            <th>债券名称</th>
                            <th>方向</th>
                            <th>中介</th>
                            <th>交易量(万)</th>
                            <th>收益率(%)</th>
                            <th>收益率类型</th>
                            <th>交易日期</th>
                            <th>清算速度</th>
                            <th>状态</th>
                            <th>进度(%)</th>
                        </tr>
                    </thead>
                    <tbody>`;
            
            orders.forEach(order => {
                const directionClass = order.方向 === '买入' ? 'direction-buy' : 'direction-sell';
                const statusClass = order.状态 === '已完成' ? 'status-completed' : 
                                  order.状态 === '执行中' ? 'status-executing' : 'status-pending';
                
                html += `
                <tr>
                    <td>${order.投资经理}</td>
                    <td>${order.债券代码}</td>
                    <td>${order.债券名称}</td>
                    <td class="${directionClass}">${order.方向}</td>
                    <td>${order.中介 || '-'}</td>
                    <td>${order.交易量}</td>
                    <td>${order.收益率 || '-'}</td>
                    <td>${order.收益率类型 || '-'}</td>
                    <td>${order.交易日期 || '-'}</td>
                    <td>${order.清算速度 || '-'}</td>
                    <td class="${statusClass}">${order.状态}</td>
                    <td>${order.完成进度}</td>
                </tr>`;
            });
            
            html += `
            </tbody>
        </table>
    </div>
</body>
</html>`;
            return html;
        }

        // 工具函数
        function showToast(message, type = 'info') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast ${type} show`;
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        function downloadFile(content, filename, type) {
            const blob = new Blob([content], { type: type });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        // 初始化事件监听器
        document.addEventListener('DOMContentLoaded', function() {
            // 初始化所有解析器
            initializeParsers();
        });

        // 本地数据持久化功能
        const DataStorage = {
            // 保存数据到localStorage
            save: function(key, data) {
                try {
                    localStorage.setItem(key, JSON.stringify(data));
                    return true;
                } catch (e) {
                    console.error('保存数据失败:', e);
                    return false;
                }
            },
            
            // 从localStorage加载数据
            load: function(key) {
                try {
                    const data = localStorage.getItem(key);
                    return data ? JSON.parse(data) : null;
                } catch (e) {
                    console.error('加载数据失败:', e);
                    return null;
                }
            },
            
            // 删除数据
            remove: function(key) {
                localStorage.removeItem(key);
            },
            
            // 保存应用状态
            saveAppState: function() {
                this.save('bondAppState', AppState);
                showToast('数据已自动保存', 'info');
            },
            
            // 恢复应用状态
            loadAppState: function() {
                const savedState = this.load('bondAppState');
                if (savedState) {
                    Object.assign(AppState, savedState);
                    showToast('已恢复上次的数据', 'success');
                    return true;
                }
                return false;
            }
        };
        
        // 自动保存功能
        let autoSaveTimer = null;
        function enableAutoSave() {
            // 每30秒自动保存一次
            autoSaveTimer = setInterval(() => {
                DataStorage.saveAppState();
            }, 30000);
        }
        
        function disableAutoSave() {
            if (autoSaveTimer) {
                clearInterval(autoSaveTimer);
                autoSaveTimer = null;
            }
        }
        
        // 模式选择函数
        function selectMode(mode) {
            AppState.mode = mode;
            
            // 隐藏模式选择界面
                document.getElementById('modeSelector').style.display = 'none';
            
            if (mode === 'standard') {
                // 显示标准版
                    document.getElementById('standardApp').style.display = 'block';
                    document.getElementById('enhancedApp').style.display = 'none';
                    const ua=document.getElementById('unifiedApp'); if(ua) ua.style.display='none';
                
                // 初始化解析器
                if (!parser) {
                    initializeParsers();
                }
                
                showToast('欢迎使用标准版 - 债券解析器', 'success');
            } else if (mode === 'enhanced') {
                // 显示扩展版
                    document.getElementById('standardApp').style.display = 'none';
                    document.getElementById('enhancedApp').style.display = 'flex';
                    const ua=document.getElementById('unifiedApp'); if(ua) ua.style.display='none';
                
                // 初始化解析器
                if (!enhancedParser) {
                    initializeParsers();
                }
                
                // 初始化增强版
                try {
                    initEnhancedApp();
                    showToast('欢迎使用扩展版 - 指令管理系统', 'success');
                } catch (error) {
                    console.error('增强版初始化失败:', error);
                    showToast('增强版初始化失败，请刷新页面重试', 'error');
                }
            } else if (mode === 'unified') {
                // 显示统一模式
                    document.getElementById('standardApp').style.display = 'none';
                    document.getElementById('enhancedApp').style.display = 'none';
                    const ua=document.getElementById('unifiedApp'); if(ua) ua.style.display='block';
                if (!parser || !enhancedParser) { initializeParsers(); }
                try { initUnifiedApp(); showToast('欢迎使用统一模式', 'success'); } catch(e){ console.error('统一模式初始化失败:', e); }
            }
            
            // 启用自动保存
                enableAutoSave();
            
            // 保存当前状态
            DataStorage.saveAppState();
        }
        
        // 返回模式选择界面
        function returnToModeSelector() {
            document.getElementById('modeSelector').style.display = 'flex';
            document.getElementById('standardApp').style.display = 'none';
            document.getElementById('enhancedApp').style.display = 'none';
            AppState.mode = null;
            DataStorage.saveAppState();
        }
        
        // 确保重要函数在全局作用域中可用
        window.selectMode = selectMode;
        window.returnToModeSelector = returnToModeSelector;

        // === 统一模式：所有会被 HTML onclick 使用的函数一律暴露到 window ===
        // 解析与清空
        window.parseUnifiedDone   = parseUnifiedDone;
        window.parseUnifiedQuote  = parseUnifiedQuote;
        window.clearUnified       = clearUnified;

        // 预览切换/筛选/编辑
        window.toggleUnifiedPreview = toggleUnifiedPreview;
        window.applyUnifiedFilters  = applyUnifiedFilters;
        window.openEditFromUnified  = openEditFromUnified;
        window.toggleSelectAllUnified = toggleSelectAllUnified;

        // 匹配工作流（预览/手动向导/撤销/报告/分配）
        window.openAutoMatchPreview  = openAutoMatchPreview;
        window.openManualMatchWizard = openManualMatchWizard;
        window.undoAutoMatch         = undoAutoMatch;
        window.exportUnifiedReport   = exportUnifiedReport;
        window.autoMatchAndAllocate  = autoMatchAndAllocate;

        // Link Picker（单条/批量）与手动录入
        window.openLinkPickerModal             = openLinkPickerModal;
        window.confirmLinkSelection            = confirmLinkSelection;
        window.openBatchLinkPickerModal        = openBatchLinkPickerModal;
        window.batchPickTop1                   = batchPickTop1;
        window.batchClearSelections            = batchClearSelections;
        window.confirmBatchLinkSelections      = confirmBatchLinkSelections;
        window.applyBatchSelectionsAndAllocate = applyBatchSelectionsAndAllocate;
        window.openManualQuoteModal            = openManualQuoteModal;
        window.saveManualQuote                 = saveManualQuote;
        window.clearQuoteAlloc                 = clearQuoteAlloc;

        // 其他在统一模式中通过onclick使用的函数
        window.deleteSelectedUnified           = deleteSelectedUnified;
        window.bulkSetManager                  = bulkSetManager;
        window.exportUnifiedDealsCSV           = exportUnifiedDealsCSV;
        window.exportUnifiedQuotesCSV          = exportUnifiedQuotesCSV;
        window.closeModal                      = closeModal;
        
        // 页面加载时恢复数据
        window.addEventListener('load', function() {
            // 调试：确认函数已定义
            console.log('selectMode函数是否定义:', typeof selectMode);
            console.log('initializeParsers函数是否定义:', typeof initializeParsers);
            console.log('initEnhancedApp函数是否定义:', typeof initEnhancedApp);
            
            const hasData = DataStorage.loadAppState();
            if (hasData && AppState.mode) {
                // 如果有保存的数据，直接进入对应模式
                selectMode(AppState.mode);
            }
        });
        
        // 页面关闭前保存数据
        window.addEventListener('beforeunload', function() {
            DataStorage.saveAppState();
        });
        
        // 键盘快捷键
        document.addEventListener('keydown', function(e) {
            // Esc关闭模态框
            if (e.key === 'Escape') {
                document.querySelectorAll('.modal.active').forEach(modal => {
                    modal.classList.remove('active');
                });
            }
            
            // Ctrl+N 新增指令
            if (e.ctrlKey && e.key === 'n') {
                e.preventDefault();
                if (AppState.mode === 'enhanced') {
                    showAddOrderModal();
                }
            }
            
            // Ctrl+I 导入指令
            if (e.ctrlKey && e.key === 'i') {
                e.preventDefault();
                if (AppState.mode === 'enhanced') {
                    showImportModal();
                }
            }
            
            // Ctrl+E 导出报告
            if (e.ctrlKey && e.key === 'e') {
                e.preventDefault();
                if (AppState.mode === 'standard') {
                    exportStandardCSV();
                } else if (AppState.mode === 'enhanced') {
                    exportReport();
                }
            }
            
            // Ctrl+S 手动保存
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                DataStorage.saveAppState();
            }
            
            // Ctrl+Shift+C 清除保存的数据
            if (e.ctrlKey && e.shiftKey && e.key === 'C') {
                e.preventDefault();
                if (confirm('确定要清除所有保存的数据吗？')) {
                    DataStorage.remove('bondAppState');
                    location.reload();
                }
            }
        });
    </script>
</body>
</html>
</body>
</html>
